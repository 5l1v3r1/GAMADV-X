#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# GAM
#
# Copyright 2015, LLC All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
u"""GAM is a command line tool which allows Administrators to control their G Suite domain and accounts.

With GAM you can programatically create users, turn on/off services for users like POP and Forwarding and much more.
For more information, see https://github.com/taers232c/GAMADV-X
"""

__author__ = u'Ross Scroggs <ross.scroggs@gmail.com>'
__version__ = u'4.42.05'
__license__ = u'Apache License 2.0 (http://www.apache.org/licenses/LICENSE-2.0)'

import sys
import os
import string
import time
import base64
import codecs
import collections
import ConfigParser
import csv
import datetime
from htmlentitydefs import name2codepoint
from HTMLParser import HTMLParser, HTMLParseError
import httplib
import json
import mimetypes
import platform
import random
import re
import signal
import socket
import StringIO

from gamlib import glaction
from gamlib import glclargs
from gamlib import glentity
from gamlib import glindent

import googleapiclient
import googleapiclient.discovery
import googleapiclient.errors
import googleapiclient.http
import httplib2
from iso8601 import iso8601
import oauth2client.client
from oauth2client.contrib.multiprocess_file_storage import MultiprocessFileStorage
import oauth2client.service_account
import oauth2client.tools

Action = glaction.GamAction()
CLArgs = glclargs.GamCLArgs()
Entity = glentity.GamEntity()
Indent = glindent.GamIndent()

# Override some oauth2client.tools strings saving us a few GAM-specific mods to oauth2client
oauth2client.tools._FAILED_START_MESSAGE = """
Failed to start a local webserver listening on either port 8080
or port 8090. Please check your firewall settings and locally
running programs that may be blocking or using those ports.

Falling back to nobrowser.txt  and continuing with
authorization.
"""

oauth2client.tools._BROWSER_OPENED_MESSAGE = """
Your browser has been opened to visit:

    {address}

If your browser is on a different machine then press CTRL+C,
set no_browser = true in gam.cfg and re-run this command.
"""

oauth2client.tools._GO_TO_LINK_MESSAGE = """
Go to the following link in your browser:

    {address}
"""

GIT_USER = u'taers232c'
GAM = u'GAMADV-X'
GAM_URL = u'https://github.com/{0}/{1}'.format(GIT_USER, GAM)
GAM_INFO = u'GAM {0} - {1} / {2} / Python {3}.{4}.{5} {6} / {7} {8} /'.format(__version__, GAM_URL,
                                                                              __author__,
                                                                              sys.version_info[0], sys.version_info[1], sys.version_info[2],
                                                                              sys.version_info[3],
                                                                              platform.platform(), platform.machine())
GAM_RELEASES = u'https://github.com/{0}/{1}/releases'.format(GIT_USER, GAM)
GAM_WIKI = u'https://github.com/{0}/{1}/wiki'.format(GIT_USER, GAM)
GAM_ALL_RELEASES = u'https://api.github.com/repos/{0}/{1}/releases'.format(GIT_USER, GAM)
GAM_LATEST_RELEASE = GAM_ALL_RELEASES+u'/latest'
GAM_LATEST_SOURCE = u'https://raw.githubusercontent.com/{0}/{1}/master/src'.format(GIT_USER, GAM)
GAM_PROJECT_APIS = GAM_LATEST_SOURCE+u'/project-apis.txt'

TRUE = u'true'
FALSE = u'false'
TRUE_VALUES = [TRUE, u'on', u'yes', u'enabled', u'1']
FALSE_VALUES = [FALSE, u'off', u'no', u'disabled', u'0']
TRUE_FALSE = [TRUE, FALSE]
ERROR = u'ERROR'
ERROR_PREFIX = ERROR+u': '
WARNING = u'WARNING'
WARNING_PREFIX = WARNING+u': '
NEVER = u'Never'
DEFAULT_CHARSET = [u'mbcs', u'utf-8'][os.name != u'nt']
ONE_KILO_BYTES = 1000
ONE_MEGA_BYTES = 1000000
ONE_GIGA_BYTES = 1000000000
SECONDS_PER_MINUTE = 60
SECONDS_PER_HOUR = 3600
SECONDS_PER_DAY = 86400
FN_GAM_CFG = u'gam.cfg'
FN_CLIENT_SECRETS_JSON = u'client_secrets.json'
FN_EXTRA_ARGS_TXT = u'extra-args.txt'
FN_LAST_UPDATE_CHECK_TXT = u'lastupdatecheck.txt'
FN_OAUTH2SERVICE_JSON = u'oauth2service.json'
FN_OAUTH2_TXT = u'oauth2.txt'
FN_GAMCOMMANDS_TXT = u'GamCommands.txt'
MY_CUSTOMER = u'my_customer'

# Global variables

# The following GM_XXX constants are arbitrary but must be unique
# Most errors print a message and bail out with a return code
# Some commands want to set a non-zero return code but not bail
GM_SYSEXITRC = u'sxrc'
# Process ID
GM_PID = u'pid '
# Path to gam
GM_GAM_PATH = u'gpth'
# Are we on Windows?
GM_WINDOWS = u'wndo'
# Encodings
GM_SYS_ENCODING = u'syen'
# Extra arguments to pass to GAPI functions
GM_EXTRA_ARGS_LIST = u'exad'
# GAM admin user
GM_ADMIN = u'admin'
# Current API user
GM_CURRENT_API_USER = u'capu'
# Current API scope
GM_CURRENT_API_SCOPES = u'scoc'
# Values retrieved from oauth2service.json
GM_OAUTH2SERVICE_JSON_DATA = u'oajd'
GM_OAUTH2_CLIENT_ID = u'oaci'
# gam.cfg parser
GM_PARSER = u'pars'
# gam.cfg file
GM_GAM_CFG_PATH = u'gcpa'
GM_GAM_CFG_FILE = u'gcfi'
# redirected file: name, mode, encoding, delimiter, write header, multiproces, queue
GM_STDOUT = u'stdo'
GM_STDERR = u'stde'
GM_CSVFILE = u'csvf'
GM_SAVED_STDOUT = u'svso'
GM_REDIRECT_NAME = u'rdfn'
GM_REDIRECT_MODE = u'rdmo'
GM_REDIRECT_FD = u'rdfd'
GM_REDIRECT_MULTI_FD = u'rdmf'
GM_REDIRECT_ENCODING = u'rden'
GM_REDIRECT_COLUMN_DELIMITER = u'rddl'
GM_REDIRECT_WRITE_HEADER = u'rdwh'
GM_REDIRECT_MULTIPROCESS = u'rdmp'
GM_REDIRECT_QUEUE = u'rdqu'
REDIRECT_QUEUE_NAME = u'name'
REDIRECT_QUEUE_TODRIVE = u'todrive'
REDIRECT_QUEUE_TITLES = u'titles'
REDIRECT_QUEUE_DATA = u'rows'
REDIRECT_QUEUE_ARGS = u'args'
REDIRECT_QUEUE_GLOBALS = u'globals'
REDIRECT_QUEUE_VALUES = u'values'
REDIRECT_QUEUE_START = u'start'
REDIRECT_QUEUE_END = u'end'
REDIRECT_QUEUE_EOF = u'eof'
# File containing time of last GAM update check
GM_LAST_UPDATE_CHECK_TXT = u'lupc'
# Index of start of <UserTypeEntity> in command line
GM_ENTITY_CL_START = u'ecls'
GM_ENTITY_CL_DELAY_START = u'eclD'
# csvfile keyfield <FieldName> [delimiter <String>] (matchfield <FieldName> <MatchPattern>)* [datafield <FieldName>(:<FieldName>*) [delimiter <String>]]
# { key: [datafieldvalues]}
GM_CSV_DATA_DICT = u'csdd'
GM_CSV_KEY_FIELD = u'cskf'
GM_CSV_SUBKEY_FIELD = u'cssk'
GM_CSV_DATA_FIELD = u'csdf'
# Dictionary mapping OrgUnit ID to Name
GM_MAP_ORGUNIT_ID_TO_NAME = u'oi2n'
# Dictionary mapping Role ID to Name
GM_MAP_ROLE_ID_TO_NAME = u'ri2n'
# Dictionary mapping Role Name to ID
GM_MAP_ROLE_NAME_TO_ID = u'rn2i'
# Dictionary mapping User ID to Name
GM_MAP_USER_ID_TO_NAME = u'ui2n'
# oauth2.txt.lock lockfile
GM_OAUTH2_TXT_LOCK = u'oalk'
# GAM cache directory. If no_cache is True, this variable will be set to None
GM_CACHE_DIR = u'gacd'
# Reset GAM cache directory after discovery
GM_CACHE_DISCOVERY_ONLY = u'gcdo'
#
GM_Globals = {
  GM_SYSEXITRC: 0,
  GM_PID: 0,
  GM_GAM_PATH: os.path.dirname(os.path.realpath(__file__)) if not getattr(sys, u'frozen', False) else os.path.dirname(sys.executable),
  GM_WINDOWS: os.name == u'nt',
  GM_SYS_ENCODING: DEFAULT_CHARSET,
  GM_EXTRA_ARGS_LIST:  [(u'prettyPrint', False)],
  GM_ADMIN: None,
  GM_CURRENT_API_USER: None,
  GM_CURRENT_API_SCOPES: [],
  GM_OAUTH2SERVICE_JSON_DATA: None,
  GM_OAUTH2_CLIENT_ID: None,
  GM_PARSER: None,
  GM_GAM_CFG_PATH: u'',
  GM_GAM_CFG_FILE: u'',
  GM_STDOUT: {},
  GM_STDERR: {},
  GM_CSVFILE: {},
  GM_SAVED_STDOUT: None,
  GM_LAST_UPDATE_CHECK_TXT: u'',
  GM_ENTITY_CL_START: 1,
  GM_ENTITY_CL_DELAY_START: 1,
  GM_CSV_DATA_DICT: {},
  GM_CSV_KEY_FIELD: None,
  GM_CSV_SUBKEY_FIELD: None,
  GM_CSV_DATA_FIELD: None,
  GM_MAP_ORGUNIT_ID_TO_NAME: None,
  GM_MAP_ROLE_ID_TO_NAME: None,
  GM_MAP_ROLE_NAME_TO_ID: None,
  GM_MAP_USER_ID_TO_NAME: None,
  GM_OAUTH2_TXT_LOCK: None,
  GM_CACHE_DIR: None,
  GM_CACHE_DISCOVERY_ONLY: False,
  }

# Global variables defined in gam.cfg

# The following GC_XXX constants are the names of the items in gam.cfg
# When retrieving lists of Google Drive activities from API, how many should be retrieved in each chunk
GC_ACTIVITY_MAX_RESULTS = u'activity_max_results'
# Automatically generate gam batch command if number of users specified in gam users xxx command exceeds this number
# Default: 0, don't automatically generate gam batch commands
GC_AUTO_BATCH_MIN = u'auto_batch_min'
# When processing items in batches, how many should be processed in each batch
GC_BATCH_SIZE = u'batch_size'
# GAM cache directory
GC_CACHE_DIR = u'cache_dir'
# GAM cache discovery only. If no_cache is False, only API discovery calls will be cached
GC_CACHE_DISCOVERY_ONLY = u'cache_discovery_only'
# Character set of batch, csv, data files
GC_CHARSET = u'charset'
# When retrieving lists of Google Classroom items from API, how many should be retrieved in each chunk
GC_CLASSROOM_MAX_RESULTS = u'classroom_max_results'
# Path to client_secrets.json
GC_CLIENT_SECRETS_JSON = u'client_secrets_json'
# GAM config directory containing client_secrets.json, oauth2.txt, oauth2service.json, extra_args.txt
GC_CONFIG_DIR = u'config_dir'
# When retrieving lists of Google Contacts from API, how many should be retrieved in each chunk
GC_CONTACT_MAX_RESULTS = u'contact_max_results'
# Column delimiter in CSV input file
GC_CSV_INPUT_COLUMN_DELIMITER = u'csv_input_column_delimiter'
# Convert newlines in text fields to "\n" in CSV output file
GC_CSV_OUTPUT_CONVERT_CR_NL = u'csv_output_convert_cr_nl'
# Column delimiter in CSV output file
GC_CSV_OUTPUT_COLUMN_DELIMITER = u'csv_output_column_delimiter'
# Field list delimiter in CSV output file
GC_CSV_OUTPUT_FIELD_DELIMITER = u'csv_output_field_delimiter'
# custmerId from gam.cfg or retrieved from Google
GC_CUSTOMER_ID = u'customer_id'
# If debug_level > 0: extra_args[u'prettyPrint'] = True, httplib2.debuglevel = gam_debug_level, appsObj.debug = True
GC_DEBUG_LEVEL = u'debug_level'
# When retrieving lists of ChromeOS/Mobile devices from API, how many should be retrieved in each chunk
GC_DEVICE_MAX_RESULTS = u'device_max_results'
# Domain obtained from gam.cfg or oauth2.txt
GC_DOMAIN = u'domain'
# Google Drive download directory
GC_DRIVE_DIR = u'drive_dir'
# When retrieving lists of Drive files/folders from API, how many should be retrieved in each chunk
GC_DRIVE_MAX_RESULTS = u'drive_max_results'
# When processing email messages in batches, how many should be processed in each batch
GC_EMAIL_BATCH_SIZE = u'email_batch_size'
# Path to extra_args.txt
GC_EXTRA_ARGS = u'extra_args'
# When retrieving lists of Google Group members from API, how many should be retrieved in each chunk
GC_MEMBER_MAX_RESULTS = u'member_max_results'
# When deleting or modifying Gmail messages, how many should be processed in each batch
GC_MESSAGE_BATCH_SIZE = u'message_batch_size'
# When retrieving lists of Gmail messages from API, how many should be retrieved in each chunk
GC_MESSAGE_MAX_RESULTS = u'message_max_results'
# If no_browser is False, writeCSVfile won't open a browser when todrive is set
# and doOAuthRequest prints a link and waits for the verification code when oauth2.txt is being created
GC_NO_BROWSER = u'no_browser'
# Disable GAM API caching
GC_NO_CACHE = u'no_cache'
# Disable GAM update check
GC_NO_UPDATE_CHECK = u'no_update_check'
# Disable SSL certificate validation
GC_NO_VERIFY_SSL = u'no_verify_ssl'
# Number of threads for gam batch
GC_NUM_THREADS = u'num_threads'
# Path to oauth2.txt
GC_OAUTH2_TXT = u'oauth2_txt'
# Path to oauth2service.json
GC_OAUTH2SERVICE_JSON = u'oauth2service_json'
# Default section to use for processing
GC_SECTION = u'section'
# Convert newlines in text fields to "\n" in show commands
GC_SHOW_CONVERT_CR_NL = u'show_convert_cr_nl'
# Add (n/m) to end of messages if number of items to be processed exceeds this number
GC_SHOW_COUNTS_MIN = u'show_counts_min'
# Enable/disable "Getting ... " messages
GC_SHOW_GETTINGS = u'show_gettings'
# Enable/disable showing multiprocess info in redirected stdout/stderr
GC_SHOW_MULTIPROCESS_INFO = u'show_multiprocess_info'
# Time Zone
GC_TIMEZONE = u'timezone'
# Enable conversion to Google Sheets when uploading todrive files
GC_TODRIVE_CONVERSION = u'todrive_conversion'
# ID/Name of parent folder for todrive files
GC_TODRIVE_PARENT = u'todrive_parent'
# Append timestamp to todrive file name
GC_TODRIVE_TIMESTAMP = u'todrive_timestamp'
# When retrieving lists of Users from API, how many should be retrieved in each chunk
GC_USER_MAX_RESULTS = u'user_max_results'

GC_Defaults = {
  GC_ACTIVITY_MAX_RESULTS: 100,
  GC_AUTO_BATCH_MIN: 0,
  GC_BATCH_SIZE: 50,
  GC_CACHE_DIR: u'',
  GC_CACHE_DISCOVERY_ONLY: FALSE,
  GC_CHARSET: DEFAULT_CHARSET,
  GC_CLASSROOM_MAX_RESULTS: 0,
  GC_CLIENT_SECRETS_JSON: FN_CLIENT_SECRETS_JSON,
  GC_CONFIG_DIR: u'',
  GC_CONTACT_MAX_RESULTS: 100,
  GC_CSV_INPUT_COLUMN_DELIMITER: u',',
  GC_CSV_OUTPUT_CONVERT_CR_NL: FALSE,
  GC_CSV_OUTPUT_COLUMN_DELIMITER: u',',
  GC_CSV_OUTPUT_FIELD_DELIMITER: u"' '",
  GC_CUSTOMER_ID: MY_CUSTOMER,
  GC_DEBUG_LEVEL: 0,
  GC_DEVICE_MAX_RESULTS: 500,
  GC_DOMAIN: u'',
  GC_DRIVE_DIR: u'',
  GC_DRIVE_MAX_RESULTS: 1000,
  GC_EMAIL_BATCH_SIZE: 100,
  GC_EXTRA_ARGS: u'',
  GC_MEMBER_MAX_RESULTS: 200,
  GC_MESSAGE_BATCH_SIZE: 1000,
  GC_MESSAGE_MAX_RESULTS: 1000,
  GC_NO_BROWSER: FALSE,
  GC_NO_CACHE: FALSE,
  GC_NO_UPDATE_CHECK: FALSE,
  GC_NO_VERIFY_SSL: FALSE,
  GC_NUM_THREADS: 25,
  GC_OAUTH2_TXT: FN_OAUTH2_TXT,
  GC_OAUTH2SERVICE_JSON: FN_OAUTH2SERVICE_JSON,
  GC_SECTION: u'',
  GC_SHOW_CONVERT_CR_NL: FALSE,
  GC_SHOW_COUNTS_MIN: 1,
  GC_SHOW_GETTINGS: TRUE,
  GC_SHOW_MULTIPROCESS_INFO: FALSE,
  GC_TIMEZONE: u'utc',
  GC_TODRIVE_CONVERSION: TRUE,
  GC_TODRIVE_PARENT: u'root',
  GC_TODRIVE_TIMESTAMP: FALSE,
  GC_USER_MAX_RESULTS: 500,
  }

GC_Values = {GC_DEBUG_LEVEL: 0}

GC_TYPE_BOOLEAN = u'bool'
GC_TYPE_CHOICE = u'choi'
GC_TYPE_DATETIME = u'datm'
GC_TYPE_DIRECTORY = u'dire'
GC_TYPE_EMAIL = u'emai'
GC_TYPE_FILE = u'file'
GC_TYPE_INTEGER = u'inte'
GC_TYPE_LANGUAGE = u'lang'
GC_TYPE_STRING = u'stri'
GC_TYPE_TIMEZONE = u'tmzn'

GC_VAR_TYPE = u'type'
GC_VAR_ENVVAR = u'enva'
GC_VAR_LIMITS = u'lmit'
GC_VAR_SFFT = u'sfft'
GC_VAR_SIGFILE = u'sigf'

GC_VAR_INFO = {
  GC_ACTIVITY_MAX_RESULTS: {GC_VAR_TYPE: GC_TYPE_INTEGER, GC_VAR_ENVVAR: u'GAM_ACTIVITY_MAX_RESULTS', GC_VAR_LIMITS: (1, 500)},
  GC_AUTO_BATCH_MIN: {GC_VAR_TYPE: GC_TYPE_INTEGER, GC_VAR_ENVVAR: u'GAM_AUTOBATCH', GC_VAR_LIMITS: (0, None)},
  GC_BATCH_SIZE: {GC_VAR_TYPE: GC_TYPE_INTEGER, GC_VAR_ENVVAR: u'GAM_BATCH_SIZE', GC_VAR_LIMITS: (1, 1000)},
  GC_CACHE_DIR: {GC_VAR_TYPE: GC_TYPE_DIRECTORY, GC_VAR_ENVVAR: u'GAMCACHEDIR'},
  GC_CACHE_DISCOVERY_ONLY: {GC_VAR_TYPE: GC_TYPE_BOOLEAN, GC_VAR_SIGFILE: u'cachediscoveryonly.txt', GC_VAR_SFFT: (FALSE, TRUE)},
  GC_CHARSET: {GC_VAR_TYPE: GC_TYPE_STRING, GC_VAR_ENVVAR: u'GAM_CHARSET'},
  GC_CLASSROOM_MAX_RESULTS: {GC_VAR_TYPE: GC_TYPE_INTEGER, GC_VAR_ENVVAR: u'GAM_CLASSROOM_MAX_RESULTS', GC_VAR_LIMITS: (0, 1000)},
  GC_CLIENT_SECRETS_JSON: {GC_VAR_TYPE: GC_TYPE_FILE, GC_VAR_ENVVAR: u'CLIENTSECRETS'},
  GC_CONFIG_DIR: {GC_VAR_TYPE: GC_TYPE_DIRECTORY, GC_VAR_ENVVAR: u'GAMUSERCONFIGDIR'},
  GC_CONTACT_MAX_RESULTS: {GC_VAR_TYPE: GC_TYPE_INTEGER, GC_VAR_ENVVAR: u'GAM_CONTACT_MAX_RESULTS', GC_VAR_LIMITS: (1, 10000)},
  GC_CSV_INPUT_COLUMN_DELIMITER: {GC_VAR_TYPE: GC_TYPE_STRING, GC_VAR_ENVVAR: u'GAM_CSV_INPUT_COLUMN_DELIMITER', GC_VAR_LIMITS: (1, 1)},
  GC_CSV_OUTPUT_CONVERT_CR_NL: {GC_VAR_TYPE: GC_TYPE_BOOLEAN, GC_VAR_ENVVAR: u'GAM_CSV_OUTPUT_CONVERT_CR_NL', GC_VAR_SFFT: (FALSE, TRUE)},
  GC_CSV_OUTPUT_COLUMN_DELIMITER: {GC_VAR_TYPE: GC_TYPE_STRING, GC_VAR_ENVVAR: u'GAM_CSV_OUTPUT_COLUMN_DELIMITER', GC_VAR_LIMITS: (1, 1)},
  GC_CSV_OUTPUT_FIELD_DELIMITER: {GC_VAR_TYPE: GC_TYPE_STRING, GC_VAR_ENVVAR: u'GAM_CSV_OUTPUT_FIELD_DELIMITER', GC_VAR_LIMITS: (1, 1)},
  GC_CUSTOMER_ID: {GC_VAR_TYPE: GC_TYPE_STRING, GC_VAR_ENVVAR: u'CUSTOMER_ID'},
  GC_DEBUG_LEVEL: {GC_VAR_TYPE: GC_TYPE_INTEGER, GC_VAR_SIGFILE: u'debug.gam', GC_VAR_LIMITS: (0, None), GC_VAR_SFFT: (u'0', u'4')},
  GC_DEVICE_MAX_RESULTS: {GC_VAR_TYPE: GC_TYPE_INTEGER, GC_VAR_ENVVAR: u'GAM_DEVICE_MAX_RESULTS', GC_VAR_LIMITS: (1, 1000)},
  GC_DOMAIN: {GC_VAR_TYPE: GC_TYPE_STRING, GC_VAR_ENVVAR: u'GA_DOMAIN'},
  GC_DRIVE_DIR: {GC_VAR_TYPE: GC_TYPE_DIRECTORY, GC_VAR_ENVVAR: u'GAMDRIVEDIR'},
  GC_DRIVE_MAX_RESULTS: {GC_VAR_TYPE: GC_TYPE_INTEGER, GC_VAR_ENVVAR: u'GAM_DRIVE_MAX_RESULTS', GC_VAR_LIMITS: (1, 1000)},
  GC_EMAIL_BATCH_SIZE: {GC_VAR_TYPE: GC_TYPE_INTEGER, GC_VAR_ENVVAR: u'GAM_EMAIL_BATCH_SIZE', GC_VAR_LIMITS: (1, 100)},
  GC_EXTRA_ARGS: {GC_VAR_TYPE: GC_TYPE_FILE, GC_VAR_SIGFILE: FN_EXTRA_ARGS_TXT, GC_VAR_SFFT: (u'', FN_EXTRA_ARGS_TXT)},
  GC_MEMBER_MAX_RESULTS: {GC_VAR_TYPE: GC_TYPE_INTEGER, GC_VAR_ENVVAR: u'GAM_MEMBER_MAX_RESULTS', GC_VAR_LIMITS: (1, 10000)},
  GC_MESSAGE_BATCH_SIZE: {GC_VAR_TYPE: GC_TYPE_INTEGER, GC_VAR_ENVVAR: u'GAM_MESSAGE_BATCH_SIZE', GC_VAR_LIMITS: (1, 1000)},
  GC_MESSAGE_MAX_RESULTS: {GC_VAR_TYPE: GC_TYPE_INTEGER, GC_VAR_ENVVAR: u'GAM_MESSAGE_MAX_RESULTS', GC_VAR_LIMITS: (1, 10000)},
  GC_NO_BROWSER: {GC_VAR_TYPE: GC_TYPE_BOOLEAN, GC_VAR_SIGFILE: u'nobrowser.txt', GC_VAR_SFFT: (FALSE, TRUE)},
  GC_NO_CACHE: {GC_VAR_TYPE: GC_TYPE_BOOLEAN, GC_VAR_SIGFILE: u'nocache.txt', GC_VAR_SFFT: (FALSE, TRUE)},
  GC_NO_UPDATE_CHECK: {GC_VAR_TYPE: GC_TYPE_BOOLEAN, GC_VAR_SIGFILE: u'noupdatecheck.txt', GC_VAR_SFFT: (FALSE, TRUE)},
  GC_NO_VERIFY_SSL: {GC_VAR_TYPE: GC_TYPE_BOOLEAN, GC_VAR_SIGFILE: u'noverifyssl.txt', GC_VAR_SFFT: (FALSE, TRUE)},
  GC_NUM_THREADS: {GC_VAR_TYPE: GC_TYPE_INTEGER, GC_VAR_ENVVAR: u'GAM_THREADS', GC_VAR_LIMITS: (1, None)},
  GC_OAUTH2_TXT: {GC_VAR_TYPE: GC_TYPE_FILE, GC_VAR_ENVVAR: u'OAUTHFILE'},
  GC_OAUTH2SERVICE_JSON: {GC_VAR_TYPE: GC_TYPE_FILE, GC_VAR_ENVVAR: u'OAUTHSERVICEFILE'},
  GC_SECTION: {GC_VAR_TYPE: GC_TYPE_STRING, GC_VAR_ENVVAR: u'GAM_SECTION'},
  GC_SHOW_CONVERT_CR_NL: {GC_VAR_TYPE: GC_TYPE_BOOLEAN, GC_VAR_ENVVAR: u'GAM_SHOW_CONVERT_CR_NL', GC_VAR_SFFT: (FALSE, TRUE)},
  GC_SHOW_COUNTS_MIN: {GC_VAR_TYPE: GC_TYPE_INTEGER, GC_VAR_ENVVAR: u'GAM_SHOW_COUNTS_MIN', GC_VAR_LIMITS: (0, None)},
  GC_SHOW_GETTINGS: {GC_VAR_TYPE: GC_TYPE_BOOLEAN, GC_VAR_ENVVAR: u'GAM_SHOW_GETTINGS'},
  GC_SHOW_MULTIPROCESS_INFO: {GC_VAR_TYPE: GC_TYPE_BOOLEAN, GC_VAR_ENVVAR: u'GAM_SHOW_MULTI_INFO'},
  GC_TIMEZONE: {GC_VAR_TYPE: GC_TYPE_TIMEZONE, GC_VAR_ENVVAR: u'GAM_TIMEZONE'},
  GC_TODRIVE_CONVERSION: {GC_VAR_TYPE: GC_TYPE_BOOLEAN, GC_VAR_ENVVAR: u'GAM_TODRIVE_CONVERSION'},
  GC_TODRIVE_PARENT: {GC_VAR_TYPE: GC_TYPE_STRING, GC_VAR_ENVVAR: u'GAM_TODRIVE_PARENT'},
  GC_TODRIVE_TIMESTAMP: {GC_VAR_TYPE: GC_TYPE_BOOLEAN, GC_VAR_ENVVAR: u'GAM_TODRIVE_TIMESTAMP'},
  GC_USER_MAX_RESULTS: {GC_VAR_TYPE: GC_TYPE_INTEGER, GC_VAR_ENVVAR: u'GAM_USER_MAX_RESULTS', GC_VAR_LIMITS: (1, 500)},
  }

# Google API constants
APPLICATION_VND_GOOGLE_APPS = u'application/vnd.google-apps.'
MIMETYPE_GA_DOCUMENT = APPLICATION_VND_GOOGLE_APPS+u'document'
MIMETYPE_GA_DRAWING = APPLICATION_VND_GOOGLE_APPS+u'drawing'
MIMETYPE_GA_FOLDER = APPLICATION_VND_GOOGLE_APPS+u'folder'
MIMETYPE_GA_FORM = APPLICATION_VND_GOOGLE_APPS+u'form'
MIMETYPE_GA_FUSIONTABLE = APPLICATION_VND_GOOGLE_APPS+u'fusiontable'
MIMETYPE_GA_MAP = APPLICATION_VND_GOOGLE_APPS+u'map'
MIMETYPE_GA_PRESENTATION = APPLICATION_VND_GOOGLE_APPS+u'presentation'
MIMETYPE_GA_SCRIPT = APPLICATION_VND_GOOGLE_APPS+u'script'
MIMETYPE_GA_SITES = APPLICATION_VND_GOOGLE_APPS+u'sites'
MIMETYPE_GA_SPREADSHEET = APPLICATION_VND_GOOGLE_APPS+u'spreadsheet'

GOOGLE_NAMESERVERS = [u'8.8.8.8', u'8.8.4.4']
NEVER_TIME = u'1970-01-01T00:00:00.000Z'
NEVER_START_DATE = u'1970-01-01'
NEVER_END_DATE = u'1969-12-31'
PROJECTION_CHOICES_MAP = {u'basic': u'BASIC', u'full': u'FULL',}
SORTORDER_CHOICES_MAP = {u'ascending': u'ASCENDING', u'descending': u'DESCENDING',}
ME_IN_OWNERS = u"'me' in owners"
ME_IN_OWNERS_AND = ME_IN_OWNERS+u" and "
AND_ME_IN_OWNERS = u" and "+ME_IN_OWNERS
NOT_ME_IN_OWNERS = u"not "+ME_IN_OWNERS
NOT_ME_IN_OWNERS_AND = NOT_ME_IN_OWNERS+u" and "
AND_NOT_ME_IN_OWNERS = u" and "+NOT_ME_IN_OWNERS
# Cloudprint
CLOUDPRINT_ACCESS_URL = u'https://www.google.com/cloudprint/addpublicprinter.html?printerid={0}&key={1}'
# Valid language codes
LANGUAGE_CODES_MAP = {
  u'af': u'af', #Afrikaans
  u'am': u'am', #Amharic
  u'ar': u'ar', #Arabica
  u'az': u'az', #Azerbaijani
  u'bg': u'bg', #Bulgarian
  u'bn': u'bn', #Bengali
  u'ca': u'ca', #Catalan
  u'chr': u'chr', #Cherokee
  u'cs': u'cs', #Czech
  u'cy': u'cy', #Welsh
  u'da': u'da', #Danish
  u'de': u'de', #German
  u'el': u'el', #Greek
  u'en': u'en', #English
  u'en-gb': u'en-GB', #English (UK)
  u'en-us': u'en-US', #English (US)
  u'es': u'es', #Spanish
  u'es-419': u'es-419', #Spanish (Latin America)
  u'et': u'et', #Estonian
  u'eu': u'eu', #Basque
  u'fa': u'fa', #Persian
  u'fi': u'fi', #Finnish
  u'fr': u'fr', #French
  u'fr-ca': u'fr-ca', #French (Canada)
  u'ag': u'ga', #Irish
  u'gl': u'gl', #Galician
  u'gu': u'gu', #Gujarati
  u'he': u'he', #Hebrew
  u'hi': u'hi', #Hindi
  u'hr': u'hr', #Croatian
  u'hu': u'hu', #Hungarian
  u'hy': u'hy', #Armenian
  u'id': u'id', #Indonesian
  u'in': u'in',
  u'is': u'is', #Icelandic
  u'it': u'it', #Italian
  u'iw': u'he', #Hebrew
  u'ja': u'ja', #Japanese
  u'ka': u'ka', #Georgian
  u'km': u'km', #Khmer
  u'kn': u'kn', #Kannada
  u'ko': u'ko', #Korean
  u'lo': u'lo', #Lao
  u'lt': u'lt', #Lithuanian
  u'lv': u'lv', #Latvian
  u'ml': u'ml', #Malayalam
  u'mn': u'mn', #Mongolian
  u'mr': u'mr', #Marathi
  u'ms': u'ms', #Malay
  u'my': u'my', #Burmese
  u'ne': u'ne', #Nepali
  u'nl': u'nl', #Dutch
  u'no': u'no', #Norwegian
  u'or': u'or', #Oriya
  u'pl': u'pl', #Polish
  u'pt-br': u'pt-BR', #Portuguese (Brazil)
  u'pt-pt': u'pt-PT', #Portuguese (Portugal)
  u'ro': u'ro', #Romanian
  u'ru': u'ru', #Russian
  u'si': u'si', #Sinhala
  u'sk': u'sk', #Slovak
  u'sl': u'sl', #Slovenian
  u'sr': u'sr', #Serbian
  u'sv': u'sv', #Swedish
  u'sw': u'sw', #Swahili
  u'ta': u'ta', #Tamil
  u'te': u'te', #Telugu
  u'th': u'th', #Thai
  u'tl': u'tl', #Tagalog
  u'tr': u'tr', #Turkish
  u'uk': u'uk', #Ukrainian
  u'ur': u'ur', #Urdu
  u'vi': u'vi', #Vietnamese
  u'zh-cn': u'zh-CN', #Chinese (Simplified)
  u'zh-hk': u'zh-HK', #Chinese (Hong Kong/Traditional)
  u'zh-tw': u'zh-TW', #Chinese (Taiwan/Traditional)
  u'zu': u'zu', #Zulu
  }
# APIs
ADMIN_SETTINGS_API = u'admin-settings'
APPSACTIVITY_API = u'appsactivity'
CALENDAR_API = u'calendar'
CLASSROOM_API = u'classroom'
CLOUDPRINT_API = u'cloudprint'
CONTACTS_API = u'contacts'
DATATRANSFER_API = u'datatransfer'
DIRECTORY_API = u'directory'
DRIVE_API = u'drive'
EMAIL_AUDIT_API = u'email-audit'
EMAIL_SETTINGS_API = u'email-settings'
GMAIL_API = u'gmail'
GPLUS_API = u'plus'
GROUPSMIGRATION_API = u'groupsmigration'
GROUPSSETTINGS_API = u'groupssettings'
LICENSING_API = u'licensing'
REPORTS_API = u'reports'
RESELLER_API = u'reseller'
SITES_API = u'sites'
SITEVERIFICATION_API = u'siteVerification'
# callGData throw errors
GDATA_BAD_GATEWAY = 601
GDATA_BAD_REQUEST = 602
GDATA_DOES_NOT_EXIST = 1301
GDATA_ENTITY_EXISTS = 1300
GDATA_FORBIDDEN = 603
GDATA_INSUFFICIENT_PERMISSIONS = 604
GDATA_INTERNAL_SERVER_ERROR = 1000
GDATA_INVALID_DOMAIN = 605
GDATA_INVALID_VALUE = 1801
GDATA_NAME_NOT_VALID = 1303
GDATA_NOT_FOUND = 606
GDATA_NOT_IMPLEMENTED = 607
GDATA_PRECONDITION_FAILED = 608
GDATA_QUOTA_EXCEEDED = 609
GDATA_SERVICE_NOT_APPLICABLE = 1410
GDATA_SERVICE_UNAVAILABLE = 610
GDATA_TOKEN_EXPIRED = 611
GDATA_TOKEN_INVALID = 403
GDATA_UNKNOWN_ERROR = 600
#
GDATA_NON_TERMINATING_ERRORS = [GDATA_BAD_GATEWAY, GDATA_QUOTA_EXCEEDED, GDATA_SERVICE_UNAVAILABLE, GDATA_TOKEN_EXPIRED]
GDATA_EMAILSETTINGS_THROW_LIST = [GDATA_INVALID_DOMAIN, GDATA_DOES_NOT_EXIST, GDATA_SERVICE_NOT_APPLICABLE, GDATA_BAD_REQUEST, GDATA_NAME_NOT_VALID, GDATA_INTERNAL_SERVER_ERROR, GDATA_INVALID_VALUE]
# oauth errors
OAUTH2_TOKEN_ERRORS = [u'access_denied', u'invalid_grant', u'unauthorized_client: Unauthorized client or scope in request.', u'access_denied: Requested client not authorized.',
                       u'invalid_grant: Not a valid email.', u'invalid_grant: Invalid email or User ID', u'invalid_grant: Bad Request',
                       u'invalid_request: Invalid impersonation prn email address.', u'internal_failure: Backend Error']
# callGAPI throw reasons
GAPI_ABORTED = u'aborted'
GAPI_ALREADY_EXISTS = u'alreadyExists'
GAPI_AUTH_ERROR = u'authError'
GAPI_BACKEND_ERROR = u'backendError'
GAPI_BAD_GATEWAY = u'badGateway'
GAPI_BAD_REQUEST = u'badRequest'
GAPI_CANNOT_CHANGE_OWN_ACL = u'cannotChangeOwnAcl'
GAPI_CANNOT_CHANGE_OWNER_ACL = u'cannotChangeOwnerAcl'
GAPI_CANNOT_DELETE_PRIMARY_CALENDAR = u'cannotDeletePrimaryCalendar'
GAPI_CANNOT_DELETE_PRIMARY_SENDAS = u'cannotDeletePrimarySendAs'
GAPI_CONDITION_NOT_MET = u'conditionNotMet'
GAPI_CUSTOMER_NOT_FOUND = u'customerNotFound'
GAPI_CYCLIC_MEMBERSHIPS_NOT_ALLOWED = u'cyclicMembershipsNotAllowed'
GAPI_DELETED = u'deleted'
GAPI_DELETED_USER_NOT_FOUND = u'deletedUserNotFound'
GAPI_DOMAIN_ALIAS_NOT_FOUND = u'domainAliasNotFound'
GAPI_DOMAIN_NOT_FOUND = u'domainNotFound'
GAPI_DOMAIN_NOT_VERIFIED_SECONDARY = u'domainNotVerifiedSecondary'
GAPI_DUPLICATE = u'duplicate'
GAPI_FAILED_PRECONDITION = u'failedPrecondition'
GAPI_FILE_NOT_FOUND = u'fileNotFound'
GAPI_FORBIDDEN = u'forbidden'
GAPI_GROUP_NOT_FOUND = u'groupNotFound'
GAPI_ILLEGAL_ACCESS_ROLE_FOR_DEFAULT = u'illegalAccessRoleForDefault'
GAPI_INSUFFICIENT_PERMISSIONS = u'insufficientPermissions'
GAPI_INTERNAL_ERROR = u'internalError'
GAPI_INVALID = u'invalid'
GAPI_INVALID_ARGUMENT = u'invalidArgument'
GAPI_INVALID_CUSTOMER_ID = u'invalidCustomerId'
GAPI_INVALID_INPUT = u'invalidInput'
GAPI_INVALID_MEMBER = u'invalidMember'
GAPI_INVALID_MESSAGE_ID = u'invalidMessageId'
GAPI_INVALID_ORGUNIT = u'invalidOrgunit'
GAPI_INVALID_OWNERSHIP_TRANSFER = u'invalidOwnershipTransfer'
GAPI_INVALID_PARAMETER = u'invalidParameter'
GAPI_INVALID_PARENT_ORGUNIT = u'invalidParentOrgunit'
GAPI_INVALID_QUERY = u'invalidQuery'
GAPI_INVALID_RESOURCE = u'invalidResource'
GAPI_INVALID_SCHEMA_VALUE = u'invalidSchemaValue'
GAPI_INVALID_SCOPE_VALUE = u'invalidScopeValue'
GAPI_INVALID_SHARING_REQUEST = u'invalidSharingRequest'
GAPI_LOGIN_REQUIRED = u'loginRequired'
GAPI_MEMBER_NOT_FOUND = u'memberNotFound'
GAPI_NOT_A_CALENDAR_USER = u'notACalendarUser'
GAPI_NOT_FOUND = u'notFound'
GAPI_NOT_IMPLEMENTED = u'notImplemented'
GAPI_ORGUNIT_NOT_FOUND = u'orgunitNotFound'
GAPI_PERMISSION_DENIED = u'permissionDenied'
GAPI_PERMISSION_NOT_FOUND = u'permissionNotFound'
GAPI_PHOTO_NOT_FOUND = u'photoNotFound'
GAPI_QUOTA_EXCEEDED = u'quotaExceeded'
GAPI_RATE_LIMIT_EXCEEDED = u'rateLimitExceeded'
GAPI_REQUIRED = u'required'
GAPI_RESOURCE_ID_NOT_FOUND = u'resourceIdNotFound'
GAPI_RESOURCE_NOT_FOUND = u'resourceNotFound'
GAPI_SERVICE_LIMIT = u'serviceLimit'
GAPI_SERVICE_NOT_AVAILABLE = u'serviceNotAvailable'
GAPI_SYSTEM_ERROR = u'systemError'
GAPI_TIME_RANGE_EMPTY = u'timeRangeEmpty'
GAPI_UNKNOWN_ERROR = u'unknownError'
GAPI_USER_NOT_FOUND = u'userNotFound'
GAPI_USER_RATE_LIMIT_EXCEEDED = u'userRateLimitExceeded'
#
GCP_CANT_MODIFY_FINISHED_JOB = u'Can\'t modify the finished job.'
GCP_FAILED_TO_SHARE_THE_PRINTER = u'Failed to share the printer.'
GCP_NO_PRINT_JOBS = u'No print job available on specified printer.'
GCP_UNKNOWN_JOB_ID = u'Unknown job id.'
GCP_UNKNOWN_PRINTER = u'Unknown printer.'
GCP_USER_IS_NOT_AUTHORIZED = u'User is not authorized.'
#
GAPI_DEFAULT_RETRY_REASONS = [GAPI_QUOTA_EXCEEDED, GAPI_RATE_LIMIT_EXCEEDED, GAPI_USER_RATE_LIMIT_EXCEEDED, GAPI_BACKEND_ERROR, GAPI_BAD_GATEWAY, GAPI_INTERNAL_ERROR]
GAPI_ACTIVITY_THROW_REASONS = [GAPI_SERVICE_NOT_AVAILABLE]
GAPI_CALENDAR_THROW_REASONS = [GAPI_SERVICE_NOT_AVAILABLE, GAPI_AUTH_ERROR, GAPI_NOT_A_CALENDAR_USER]
GAPI_DRIVE_THROW_REASONS = [GAPI_SERVICE_NOT_AVAILABLE, GAPI_AUTH_ERROR]
GAPI_GMAIL_THROW_REASONS = [GAPI_SERVICE_NOT_AVAILABLE, GAPI_BAD_REQUEST]
GAPI_GMAIL_SMIME_THROW_REASONS = [GAPI_SERVICE_NOT_AVAILABLE, GAPI_BAD_REQUEST, GAPI_FORBIDDEN]
GAPI_GPLUS_THROW_REASONS = [GAPI_SERVICE_NOT_AVAILABLE]
GAPI_GROUP_GET_RETRY_REASONS = [GAPI_INVALID, GAPI_SYSTEM_ERROR]
GAPI_GROUP_GET_THROW_REASONS = [GAPI_GROUP_NOT_FOUND, GAPI_DOMAIN_NOT_FOUND, GAPI_FORBIDDEN, GAPI_BAD_REQUEST]
GAPI_GROUP_SETTINGS_THROW_REASONS = [GAPI_GROUP_NOT_FOUND, GAPI_DOMAIN_NOT_FOUND, GAPI_FORBIDDEN, GAPI_SYSTEM_ERROR]
GAPI_GROUP_SETTINGS_RETRY_REASONS = [GAPI_INVALID, GAPI_SERVICE_LIMIT]
GAPI_MEMBERS_THROW_REASONS = [GAPI_GROUP_NOT_FOUND, GAPI_DOMAIN_NOT_FOUND, GAPI_INVALID, GAPI_FORBIDDEN]
GAPI_MEMBERS_RETRY_REASONS = [GAPI_SYSTEM_ERROR]
GAPI_USER_GET_THROW_REASONS = [GAPI_USER_NOT_FOUND, GAPI_DOMAIN_NOT_FOUND, GAPI_FORBIDDEN, GAPI_BAD_REQUEST, GAPI_SYSTEM_ERROR]
#
DRIVE_API_VERSION = u'v2'
#
DRIVE_FILE_CREATED_DATE_TIME = u'createdDate'
DRIVE_FILE_MARKED_VIEWED_BY_ME_DATE_TIME = u'markedViewedByMeDate'
DRIVE_FILE_LAST_VIEWED_BY_ME_DATE_TIME = u'lastViewedByMeDate'
DRIVE_FILE_MODIFIED_BY_ME_DATE_TIME = u'modifiedByMeDate'
DRIVE_FILE_MODIFIED_DATE_TIME = u'modifiedDate'
DRIVE_FILE_NAME = u'title'
DRIVE_FILE_SHARED_WITH_ME_DATE_TIME = u'sharedWithMeDate'
DRIVE_FILE_SIZE = u'fileSize'
DRIVE_FILE_VIEW_LINK = u'alternateLink'
DRIVE_FILE_LABEL_RESTRICTED = u'restricted'
DRIVE_FILE_LABEL_VIEWED = u'viewed'
#
DRIVE_FILES_LIST = u'items'
DRIVE_CREATE_FILE = u'insert'
DRIVE_PATCH_FILE = u'patch'
DRIVE_UPDATE_FILE = u'update'
#
DRIVE_PERMISSIONS_DOMAIN_TYPE_VALUE = u'value'
DRIVE_PERMISSIONS_EXPIRATION_DATE_TIME = u'expirationDate'
DRIVE_PERMISSIONS_GROUP_USER_TYPE_VALUE = u'value'
DRIVE_PERMISSIONS_LIST = u'items'
DRIVE_PERMISSIONS_NAME = u'name'
#
DRIVE_CREATE_PERMISSIONS = u'insert'
DRIVE_PATCH_PERMISSIONS = u'patch'
#
DRIVE_REVISIONS_LIST = u'items'
#
DRIVE_PARENTS_ID = u'parents(id)'
#
DFA_IGNORE_DEFAULT_VISIBILITY = u'ignoreDefaultVisibility'
DFA_KEEP_REVISION_FOREVER = u'keepRevisionForever'
DFA_LOCALFILEPATH = u'localFilepath'
DFA_LOCALFILENAME = u'localFilename'
DFA_LOCALMIMETYPE = u'localMimeType'
DFA_CONVERT = u'convert'
DFA_OCR = u'ocr'
DFA_OCRLANGUAGE = u'ocrLanguage'
DFA_PARENTQUERY = u'parentQuery'
DFA_ADD_PARENTS = u'addParents'
DFA_REMOVE_PARENTS = u'removeParents'
DFA_USE_CONTENT_AS_INDEXABLE_TEXT = u'useContentAsIndexableText'
#
OAUTH2_FAM1_SCOPES = u'fam1'
OAUTH2_FAM2_SCOPES = u'fam2'
OAUTH2_FAM_LIST = [OAUTH2_FAM1_SCOPES, OAUTH2_FAM2_SCOPES]
OAUTH2_PREV_FAM_LIST = [u'gapi', u'gdata']
# Object BNF names
OB_ACCESS_TOKEN = u'AccessToken'
OB_ACL_SCOPE = u'ACLScope'
OB_ACL_SCOPE_ENTITY = u'ACLScopeEntity'
OB_ARGUMENT = u'argument'
OB_ASP_ID = u'AspID'
OB_CALENDAR_ENTITY = U'CalendarEntity'
OB_CALENDAR_ITEM = U'CalendarItem'
OB_CHAR_SET = u'CharacterSet'
OB_CIDR_NETMASK = u'CIDRnetmask'
OB_CLIENT_ID = u'ClientID'
OB_CONTACT_EMAIL_TYPE = u'ContactEmailType'
OB_CONTACT_ENTITY = u'ContactEntity'
OB_CONTACT_GROUP_ENTITY = u'ContactGroupEntity'
OB_CONTACT_GROUP_ITEM = u'ContactGroupItem'
OB_COURSE_ALIAS = u'CourseAlias'
OB_COURSE_ALIAS_ENTITY = u'CourseAliasEntity'
OB_COURSE_ENTITY = u'CourseEntity'
OB_COURSE_ID = u'CourseID'
OB_CROS_DEVICE_ENTITY = u'CrOSDeviceEntity'
OB_CROS_ENTITY = u'CrOSEntity'
OB_CUSTOMER_ID = u'CustomerID'
OB_DELIMITER = u'Delimiter'
OB_DOMAIN_ALIAS = u'DomainAlias'
OB_DOMAIN_NAME = u'DomainName'
OB_DOMAIN_NAME_ENTITY = u'DomainNameEntity'
OB_DRIVE_FILE_ENTITY = u'DriveFileEntity'
OB_DRIVE_FILE_ID = u'DriveFileID'
OB_DRIVE_FILE_NAME = u'DriveFileName'
OB_DRIVE_FILE_PERMISSION_ENTITY = u'DriveFilePermissionEntity'
OB_DRIVE_FILE_PERMISSION_ID = u'DriveFilePermissionID'
OB_DRIVE_FILE_PERMISSION_ID_ENTITY = u'DriveFilePermissionIDEntity'
OB_DRIVE_FOLDER_ID = u'DriveFolderID'
OB_DRIVE_FOLDER_ID_LIST = u'DriveFolderIDList'
OB_DRIVE_FOLDER_NAME = u'DriveFolderName'
OB_EMAIL_ADDRESS = u'EmailAddress'
OB_EMAIL_ADDRESS_ENTITY = u'EmailAddressEntity'
OB_EMAIL_ADDRESS_OR_UID = u'EmailAaddress|UniqueID'
OB_ENTITY = u'Entity'
OB_ENTITY_TYPE = u'EntityType'
OB_EVENT_ID = u'EventID'
OB_EVENT_ID_ENTITY = u'EventIDEntity'
OB_FIELD_NAME = u'FieldName'
OB_FIELD_NAME_LIST = "FieldNameList"
OB_FILE_NAME = u'FileName'
OB_FILE_NAME_FIELD_NAME = OB_FILE_NAME+u'(:'+OB_FIELD_NAME+u')+'
OB_FILE_NAME_OR_URL = u'FileName|URL'
OB_FILE_PATH = u'FilePath'
OB_FILTER_ID_ENTITY = u'FilterIDEntity'
OB_FORMAT_LIST = u'FormatList'
OB_GAM_ARGUMENT_LIST = u'GAM argument list'
OB_GROUP_ENTITY = u'GroupEntity'
OB_GROUP_ITEM = u'GroupItem'
OB_GUARDIAN_INVITATION_ID = U'GuardianInvitationID'
OB_GUARDIAN_ITEM = U'GuardianItem'
OB_GUARDIAN_STATE_LIST = u'GuardianStateList'
OB_HOST_NAME = u'HostName'
OB_JOB_ID = u'JobID'
OB_JOB_OR_PRINTER_ID = u'JobID|PrinterID'
OB_LABEL_NAME = u'LabelName'
OB_LABEL_REPLACEMENT = u'LabelReplacement'
OB_MESSAGE_ID = u'MessageID'
OB_MOBILE_DEVICE_ENTITY = u'MobileDeviceEntity'
OB_MOBILE_ENTITY = u'MobileEntity'
OB_NAME = u'Name'
OB_NOTIFICATION_ID = u'NotificationID'
OB_ORGUNIT_ENTITY = u'OrgUnitEntity'
OB_ORGUNIT_ITEM = u'OrgUnitItem'
OB_ORGUNIT_PATH = u'OrgUnitPath'
OB_PARAMETER_KEY = u'ParameterKey'
OB_PARAMETER_VALUE = u'ParameterValue'
OB_PASSWORD = u'Password'
OB_PHOTO_FILENAME_PATTERN = u'FilenameNamePattern'
OB_PRINTER_ID = u'PrinterID'
OB_PRINTER_ID_ENTITY = u'PrinterIDEntity'
OB_PRINTJOB_AGE = u'PrintJobAge'
OB_PRINTJOB_ID = u'PrintJobID'
OB_PRODUCT_ID = u'ProductID'
OB_PRODUCT_ID_LIST = u'ProductIDList'
OB_PROPERTY_KEY = u'PropertyKey'
OB_PROPERTY_VALUE = u'PropertyValue'
OB_QUERY = u'Query'
OB_RECURRENCE = u'RRULE EXRULE RDATE and EXDATE lines'
OB_REQUEST_ID = u'RequestID'
OB_RESOURCE_ENTITY = u'ResourceEntity'
OB_RESOURCE_ID = u'ResourceID'
OB_RE_PATTERN = u'REPattern'
OB_ROLE_ASSIGNMENT_ID = u'RoleAssignmentId'
OB_ROLE_ID = u'RoleId'
OB_ROLE_LIST = u'RoleList'
OB_SCHEMA_ENTITY = u'SchemaEntity'
OB_SCHEMA_NAME = u'SchemaName'
OB_SCHEMA_NAME_FIELD_NAME = u'SchemaName.FieldName'
OB_SCHEMA_NAME_LIST = u'SchemaNameList'
OB_SECTION_NAME = u'SectionName'
OB_SERVICE_NAME = u'ServiceName'
OB_SITE_ENTITY = u'SiteEntity'
OB_SKU_ID = u'SKUID'
OB_SKU_ID_LIST = u'SKUIDList'
OB_SMIME_ID = u'S/MIMEID'
OB_STRING = u'String'
OB_STUDENT_ITEM = u'StudentItem'
OB_TAG = u'Tag'
OB_THREAD_ID = u'ThreadID'
OB_TRANSFER_ID = u'TransferID'
OB_URI = u'URI'
OB_URL = u'URL'
OB_USER_ENTITY = u'UserEntity'
OB_USER_ITEM = u'UserItem'
# GAM entity types as specified on the command line
CL_ENTITY_COURSEPARTICIPANTS = u'courseparticipants'
CL_ENTITY_CROS = u'cros'
CL_ENTITY_CROS_QUERY = u'crosquery'
CL_ENTITY_CROS_OU = u'cros_ou'
CL_ENTITY_CROS_OU_AND_CHILDREN = u'cros_ou_and_children'
CL_ENTITY_CROS_OUS = u'cros_ous'
CL_ENTITY_CROS_OUS_AND_CHILDREN = u'cros_ous_and_children'
CL_ENTITY_GROUP = u'group'
CL_ENTITY_GROUPS = u'groups'
CL_ENTITY_GROUP_USERS = u'group_users'
CL_ENTITY_LICENSES = u'licenses'
CL_ENTITY_OU = u'ou'
CL_ENTITY_OU_AND_CHILDREN = u'ou_and_children'
CL_ENTITY_OUS = u'ous'
CL_ENTITY_OUS_AND_CHILDREN = u'ous_and_children'
CL_ENTITY_QUERY = u'query'
CL_ENTITY_STUDENTS = u'students'
CL_ENTITY_TEACHERS = u'teachers'
CL_ENTITY_USER = u'user'
CL_ENTITY_USERS = u'users'
#
CL_CROS_ENTITIES = [
  CL_ENTITY_CROS,
  CL_ENTITY_CROS_QUERY,
  CL_ENTITY_CROS_OU,
  CL_ENTITY_CROS_OU_AND_CHILDREN,
  CL_ENTITY_CROS_OUS,
  CL_ENTITY_CROS_OUS_AND_CHILDREN,
  ]
CL_USER_ENTITIES = [
  CL_ENTITY_COURSEPARTICIPANTS,
  CL_ENTITY_GROUP,
  CL_ENTITY_GROUPS,
  CL_ENTITY_GROUP_USERS,
  CL_ENTITY_LICENSES,
  CL_ENTITY_OU,
  CL_ENTITY_OU_AND_CHILDREN,
  CL_ENTITY_OUS,
  CL_ENTITY_OUS_AND_CHILDREN,
  CL_ENTITY_QUERY,
  CL_ENTITY_STUDENTS,
  CL_ENTITY_TEACHERS,
  CL_ENTITY_USER,
  CL_ENTITY_USERS,
  ]
# Aliases for CL entity types
CL_ENTITY_ALIAS_MAP = {
  u'crosorg': CL_ENTITY_CROS_OU,
  u'crosorg_and_child': CL_ENTITY_CROS_OU_AND_CHILDREN,
  u'crosorg_and_children': CL_ENTITY_CROS_OU_AND_CHILDREN,
  u'crosorgs': CL_ENTITY_CROS_OUS,
  u'crosorgs_and_child': CL_ENTITY_CROS_OUS_AND_CHILDREN,
  u'crosorgs_and_children': CL_ENTITY_CROS_OUS_AND_CHILDREN,
  u'crosou_and_child': CL_ENTITY_CROS_OU_AND_CHILDREN,
  u'crosou_and_childen': CL_ENTITY_CROS_OU_AND_CHILDREN,
  u'crosous_and_child': CL_ENTITY_CROS_OUS_AND_CHILDREN,
  u'cros_org': CL_ENTITY_CROS_OU,
  u'cros_org_and_child': CL_ENTITY_CROS_OU_AND_CHILDREN,
  u'cros_org_and_children': CL_ENTITY_CROS_OU_AND_CHILDREN,
  u'cros_orgs': CL_ENTITY_CROS_OUS,
  u'cros_orgs_and_child': CL_ENTITY_CROS_OUS_AND_CHILDREN,
  u'cros_orgs_and_children': CL_ENTITY_CROS_OUS_AND_CHILDREN,
  u'cros_ou_and_child': CL_ENTITY_CROS_OU_AND_CHILDREN,
  u'cros_ou_and_childen': CL_ENTITY_CROS_OU_AND_CHILDREN,
  u'cros_ous_and_child': CL_ENTITY_CROS_OUS_AND_CHILDREN,
  u'license': CL_ENTITY_LICENSES,
  u'licence': CL_ENTITY_LICENSES,
  u'licences': CL_ENTITY_LICENSES,
  u'org': CL_ENTITY_OU,
  u'org_and_child': CL_ENTITY_OU_AND_CHILDREN,
  u'org_and_children': CL_ENTITY_OU_AND_CHILDREN,
  u'orgs': CL_ENTITY_OUS,
  u'orgs_and_child': CL_ENTITY_OUS_AND_CHILDREN,
  u'orgs_and_children': CL_ENTITY_OUS_AND_CHILDREN,
  u'ou_and_child': CL_ENTITY_OU_AND_CHILDREN,
  u'ous_and_child': CL_ENTITY_OUS_AND_CHILDREN,
  }
# CL entity source selectors
CL_ENTITY_SELECTOR_ALL = u'all'
CL_ENTITY_SELECTOR_CSV = u'csv'
CL_ENTITY_SELECTOR_CSVFILE = u'csvfile'
CL_ENTITY_SELECTOR_FILE = u'file'
CL_ENTITY_SELECTOR_DATAFILE = u'datafile'
CL_ENTITY_SELECTOR_CROSCSV = u'croscsv'
CL_ENTITY_SELECTOR_CROSCSVFILE = u'croscsvfile'
CL_ENTITY_SELECTOR_CROSFILE = u'crosfile'
CL_ENTITY_SELECTOR_CSVKMD = u'csvkmd'
CL_ENTITY_SELECTOR_CSVSUBKEY = u'csvsubkey'
CL_ENTITY_SELECTOR_CSVDATA = u'csvdata'
CL_ENTITY_SELECTOR_CSVCROS = u'csvcros'
#
CL_CROS_ENTITY_SELECTORS = [
  CL_ENTITY_SELECTOR_CROSCSV,
  CL_ENTITY_SELECTOR_CROSCSVFILE,
  CL_ENTITY_SELECTOR_CROSFILE,
  ]
CL_ENTITY_SELECTORS = [
  CL_ENTITY_SELECTOR_ALL,
  CL_ENTITY_SELECTOR_CSV,
  CL_ENTITY_SELECTOR_CSVFILE,
  CL_ENTITY_SELECTOR_FILE,
  CL_ENTITY_SELECTOR_DATAFILE,
  CL_ENTITY_SELECTOR_CSVKMD,
  CL_ENTITY_SELECTOR_CSVSUBKEY,
  ]
CL_CSVCROS_ENTITY_SELECTORS = [
  CL_ENTITY_SELECTOR_CSVCROS,
  ]
CL_CSVDATA_ENTITY_SELECTORS = [
  CL_ENTITY_SELECTOR_CSVDATA,
  ]
# Allowed values for CL source selector all
CL_CROS_ENTITY_SELECTOR_ALL_SUBTYPES = [
  CL_ENTITY_CROS,
  ]
CL_USER_ENTITY_SELECTOR_ALL_SUBTYPES = [
  CL_ENTITY_USERS,
  ]
#
CL_ENTITY_ALL_CROS = CL_ENTITY_SELECTOR_ALL+u' '+CL_ENTITY_CROS
CL_ENTITY_ALL_USERS = CL_ENTITY_SELECTOR_ALL+u' '+CL_ENTITY_USERS
#
CL_ENTITY_SELECTOR_ALL_SUBTYPES_MAP = {
  CL_ENTITY_CROS: CL_ENTITY_ALL_CROS,
  CL_ENTITY_USERS: CL_ENTITY_ALL_USERS,
  }
# Allowed values for CL source selector args, datafile, csvkmd
CL_CROS_ENTITY_SELECTOR_DATAFILE_CSVKMD_SUBTYPES = [
  CL_ENTITY_CROS,
  CL_ENTITY_CROS_OUS,
  CL_ENTITY_CROS_OUS_AND_CHILDREN,
  ]
CL_USER_ENTITY_SELECTOR_DATAFILE_CSVKMD_SUBTYPES = [
  CL_ENTITY_USERS,
  CL_ENTITY_GROUPS,
  CL_ENTITY_GROUP_USERS,
  CL_ENTITY_OUS,
  CL_ENTITY_OUS_AND_CHILDREN,
  CL_ENTITY_COURSEPARTICIPANTS,
  CL_ENTITY_STUDENTS,
  CL_ENTITY_TEACHERS,
  ]
# Command line objects
CL_OB_ACL = u'acl'
CL_OB_ACLS = u'acls'
CL_OB_ADMIN = u'admin'
CL_OB_ADMINS = u'admins'
CL_OB_ADMINROLES = u'adminroles'
CL_OB_ALIAS = u'alias'
CL_OB_ALIASES = u'aliases'
CL_OB_ASP = u'asp'
CL_OB_ASPS = u'asps'
CL_OB_BACKUPCODES = u'backupcodes'
CL_OB_CALATTENDEES = u'calattendees'
CL_OB_CALENDAR = u'calendar'
CL_OB_CALENDARS = u'calendars'
CL_OB_CALENDARACL = u'calendaracl'
CL_OB_CALENDARACLS = u'calendaracls'
CL_OB_CALSETTINGS = u'calsettings'
CL_OB_CONTACT = u'contact'
CL_OB_CONTACTS = u'contacts'
CL_OB_CONTACT_GROUP = u'contactgroup'
CL_OB_CONTACT_GROUPS = u'contactgroups'
CL_OB_COURSE = u'course'
CL_OB_COURSES = u'courses'
CL_OB_COURSE_PARTICIPANTS = u'course-participants'
CL_OB_CROS = u'cros'
CL_OB_CROSES = u'croses'
CL_OB_CUSTOMER = u'customer'
CL_OB_DATA_TRANSFER = u'datatransfer'
CL_OB_DATA_TRANSFERS = u'datatransfers'
CL_OB_DELEGATE = u'delegate'
CL_OB_DELEGATES = u'delegates'
CL_OB_DOMAIN = u'domain'
CL_OB_DOMAINS = u'domains'
CL_OB_DOMAIN_ALIAS = u'domainalias'
CL_OB_DOMAIN_ALIASES = u'domainaliases'
CL_OB_DRIVE = u'drive'
CL_OB_DRIVEACTIVITY = u'driveactivity'
CL_OB_DRIVEFILE = u'drivefile'
CL_OB_DRIVEFILEACL = u'drivefileacl'
CL_OB_DRIVEFILEACLS = u'drivefileacls'
CL_OB_DRIVESETTINGS = u'drivesettings'
CL_OB_DRIVETRASH = u'drivetrash'
CL_OB_EMPTYDRIVEFOLDERS = u'emptydrivefolders'
CL_OB_EVENT = u'event'
CL_OB_EVENTS = u'events'
CL_OB_FILEINFO = u'fileinfo'
CL_OB_FILELIST = u'filelist'
CL_OB_FILEPATH = u'filepath'
CL_OB_FILEREVISIONS = u'filerevisions'
CL_OB_FILETREE = u'filetree'
CL_OB_FILTER = u'filter'
CL_OB_FILTERS = u'filters'
CL_OB_FORWARD = u'forward'
CL_OB_FORWARDINGADDRESS = u'forwardingaddress'
CL_OB_FORWARDINGADDRESSES = u'forwardingaddresses'
CL_OB_GAL = u'gal'
CL_OB_GMAILPROFILE = u'gmailprofile'
CL_OB_GPLUSPROFILE = u'gplusprofile'
CL_OB_GROUP = u'group'
CL_OB_GROUPS = u'groups'
CL_OB_GROUP_MEMBERS = u'group-members'
CL_OB_GUARDIAN = u'guardian'
CL_OB_GUARDIANS = u'guardians'
CL_OB_GUARDIAN_INVITATION = u'guardianinvitation'
CL_OB_GUARDIAN_INVITATIONS = u'guardianinvitations'
CL_OB_IMAP = u'imap'
CL_OB_INSTANCE = u'instance'
CL_OB_LABEL = u'label'
CL_OB_LABELS = u'labels'
CL_OB_LABELSETTINGS = u'labelsettings'
CL_OB_LICENSE = u'license'
CL_OB_LICENSES = u'licenses'
CL_OB_LOGO = u'logo'
CL_OB_MESSAGE = u'message'
CL_OB_MESSAGES = u'messages'
CL_OB_MOBILE = u'mobile'
CL_OB_MOBILES = u'mobiles'
CL_OB_NOTE = u'note'
CL_OB_NOTIFICATION = u'notification'
CL_OB_ORG = u'org'
CL_OB_ORGS = u'orgs'
CL_OB_ORGTREE = u'orgtree'
CL_OB_OWNERSHIP = u'ownership'
CL_OB_PERMISSIONS = u'permissions'
CL_OB_PHOTO = u'photo'
CL_OB_POP = u'pop'
CL_OB_PRINTER = u'printer'
CL_OB_PRINTERS = u'printers'
CL_OB_PRINTJOBS = u'printjobs'
CL_OB_PROFILE = u'profile'
CL_OB_PROJECT = u'project'
CL_OB_PROJECTS = u'projects'
CL_OB_RESOURCE = u'resource'
CL_OB_RESOURCES = u'resources'
CL_OB_SCHEMA = u'schema'
CL_OB_SCHEMAS = u'schemas'
CL_OB_SENDAS = u'sendas'
CL_OB_SERVICEACCOUNT = u'serviceaccount'
CL_OB_SIGNATURE = u'signature'
CL_OB_SITE = u'site'
CL_OB_SITES = u'sites'
CL_OB_SITEACL = u'siteacl'
CL_OB_SITEACLS = u'siteacls'
CL_OB_SITEACTIVITY = u'siteactivity'
CL_OB_SMIME = u'smime'
CL_OB_SMIMES = u'smimes'
CL_OB_THREAD = u'thread'
CL_OB_THREADS = u'threads'
CL_OB_TOKEN = u'token'
CL_OB_TOKENS = u'tokens'
CL_OB_TRANSFERAPPS = u'transferapps'
CL_OB_USER = u'user'
CL_OB_USERS = u'users'
CL_OB_VACATION = u'vacation'
CL_OB_VERIFY = u'verify'
# Command line batch/csv/loop keywords
GAM_CMD = u'gam'
COMMIT_BATCH_CMD = u'commit-batch'
LOOP_CMD = u'loop'
# Command line select/config/redirect arguments
SELECT_CMD = u'select'
CONFIG_CMD = u'config'
REDIRECT_CMD = u'redirect'
GAM_META_COMMANDS = [SELECT_CMD, CONFIG_CMD, REDIRECT_CMD,]
#
CLEAR_NONE_ARGUMENT = [u'clear', u'none',]
CLIENTID_ARGUMENT = [u'clientid',]
COLUMN_DELIMITER_ARGUMENT = [u'columndelimiter',]
DATA_ARGUMENT = [u'data',]
FILE_ARGUMENT = [u'file',]
FROM_ARGUMENT = [u'from',]
IDS_ARGUMENT = [u'ids',]
ID_ARGUMENT = [u'id',]
LOGO_ARGUMENT = [u'logo',]
MODE_ARGUMENT = [u'mode',]
MOVE_ADD_ARGUMENT = [u'move', u'add',]
MULTIVALUE_ARGUMENT = [u'multivalued', u'multivalue', u'value', u'multinonempty']
NOINFO_ARGUMENT = [u'noinfo',]
NORMALIZE_ARGUMENT = [u'normalize',]
NOTSUSPENDED_ARGUMENT = [u'notsuspended',]
ORG_OU_ARGUMENT = [u'org', u'ou',]
PRIMARY_ARGUMENT = [u'primary',]
PRIMARY_NOTPRIMARY_CHOICE_MAP = {u'primary': True, u'notprimary': False}
QUERY_ARGUMENT = [u'query',]
SHOWTITLES_ARGUMENT = [u'showtitles',]
TODRIVE_ARGUMENT = [u'todrive',]
TO_ARGUMENT = [u'to',]
UNSTRUCTURED_FORMATTED_ARGUMENT = [u'unstructured', u'formatted',]

# These values can be translated into other languages
PHRASE_ACCESS_FORBIDDEN = u'Access Forbidden'
PHRASE_ACTION_APPLIED = u'Action Applied'
PHRASE_ADMIN_STATUS_CHANGED_TO = u'Admin Status Changed to'
PHRASE_ALL = u'All'
PHRASE_ALREADY_EXISTS_USE_MERGE_ARGUMENT = u'Already exists; use the "merge" argument to merge the labels'
PHRASE_API_ERROR_SETTINGS = u'API error, some settings not set'
PHRASE_AS = u'as'
PHRASE_AUTHORIZED = u'Authorized'
PHRASE_BAD_REQUEST = u'Bad Request'
PHRASE_BATCH = u'Batch'
PHRASE_CAN_NOT_BE_DOWNLOADED = u'Can not be downloaded'
PHRASE_CHECKING = u'Checking'
PHRASE_COMPLETE = u'Complete'
PHRASE_CONTAINS_AT_LEAST_1_ITEM = u'Contains at least 1 item'
PHRASE_COUNT_N_EXCEEDS_MAX_TO_PROCESS_M = u'Count {0} exceeds maximum to {1} {2}'
PHRASE_DATA_UPLOADED_TO_DRIVE_FILE = u'Data uploaded to Drive File'
PHRASE_DELEGATE_ACCESS_TO = u'Delegate Access to'
PHRASE_DENIED = u'DENIED'
PHRASE_DIRECTLY_IN_THE = u' directly in the {0}'
PHRASE_DOES_NOT_EXIST = u'Does not exist'
PHRASE_DOMAIN_NOT_VERIFIED_SECONDARY = u'Domain is not a verified secondary domain'
PHRASE_DO_NOT_EXIST = u'Do not exist'
PHRASE_DUPLICATE = u'Duplicate'
PHRASE_EITHER = u'Either'
PHRASE_ENTITY_DOES_NOT_EXIST = u'{0} does not exist'
PHRASE_ERROR = u'error'
PHRASE_EXISTS = u'Exists'
PHRASE_EXPECTED = u'Expected'
PHRASE_FAILED_TO_PARSE_AS_JSON = u'Failed to parse as JSON'
PHRASE_FIELD_NOT_FOUND_IN_SCHEMA = u'Field {0} not found in schema {1}'
PHRASE_FINISHED = u'Finished'
PHRASE_FOR = u'for'
PHRASE_FORBIDDEN = u'Forbidden'
PHRASE_FORMAT_NOT_AVAILABLE = u'Format ({0}) not available'
PHRASE_FORMAT_NOT_DOWNLOADABLE = u'Format not downloadable'
PHRASE_FROM = u'From'
PHRASE_GETTING = u'Getting'
PHRASE_GETTING_ALL = u'Getting all'
PHRASE_GOOGLE_EARLIEST_REPORT_TIME = u'Google earliest report time'
PHRASE_GOT = u'Got'
PHRASE_GUARDIAN_INVITATION_STATUS_NOT_PENDING = 'Guardian invitation status is not PENDING'
PHRASE_HAS_CHILD_ORGS = 'Has child {0}'
PHRASE_INVALID = u'Invalid'
PHRASE_INVALID_ALIAS = u'Invalid Alias'
PHRASE_INVALID_CUSTOMER_ID = u'Invalid Customer ID'
PHRASE_INVALID_DOMAIN = u'Invalid Domain'
PHRASE_INVALID_ENTITY_MESSAGE = 'Invalid {0}, {1}'
PHRASE_INVALID_GROUP = u'Invalid Group'
PHRASE_INVALID_MESSAGE_ID = 'Invalid message id(s)'
PHRASE_INVALID_ORGUNIT = u'Invalid Organizational Unit'
PHRASE_INVALID_OWNER_TYPE = u'role {0} not allowed with {1}'
PHRASE_INVALID_PATH = u'Invalid Path'
PHRASE_INVALID_QUERY = u'Invalid Query'
PHRASE_INVALID_REQUEST = u'Invalid Request'
PHRASE_INVALID_ROLE = u'Invalid Role'
PHRASE_INVALID_SCHEMA_VALUE = u'Invalid Schema Value'
PHRASE_INVALID_SCOPE = u'Invalid Scope'
PHRASE_INVALID_SITE = u'Invalid Site ({0}), must match pattern ({1})'
PHRASE_IS_REQD_TO_CHG_PWD_NO_DELEGATION = u'is required to change password at next login. You must change password or clear changepassword flag for delegation.'
PHRASE_IS_SUSPENDED_NO_DELEGATION = u'is suspended. You must unsuspend for delegation.'
PHRASE_LABELS_NOT_FOUND = u'Labels ({0}) not found'
PHRASE_LIST = u'List'
PHRASE_LOOKING_UP_GOOGLE_UNIQUE_ID = u'Looking up Google Unique ID'
PHRASE_MARKED_AS = u'Marked as'
PHRASE_MAXIMUM_OF = u'maximum of'
PHRASE_MATCHED_THE_FOLLOWING = u'Matched the following'
PHRASE_MAY_TAKE_SOME_TIME_ON_A_LARGE = u'may take some time on a large'
PHRASE_NESTED_LOOP_CMD_NOT_ALLOWED = u'Command can not be nested.'
PHRASE_NEW_OWNER_MUST_DIFFER_FROM_OLD_OWNER = u'New owner must differ from old owner'
PHRASE_NON_BLANK = u'Non-blank'
PHRASE_NON_EMPTY = u'Non-empty'
PHRASE_NOT_A = u'Not a'
PHRASE_NOT_ALLOWED = u'Not Allowed'
PHRASE_NOT_FOUND = u'Not Found'
PHRASE_NOW_THE_PRIMARY_DOMAIN = u'Now the primary domain'
PHRASE_NO_ENTITIES_FOUND = u'No {0} found'
PHRASE_NO_ENTITIES_MATCHED = u'No {0} matched'
PHRASE_NO_FILTER_CRITERIA = U'No {0} criteria specified'
PHRASE_NO_FILTER_ACTIONS = U'No {0} actions specified'
PHRASE_NO_LABELS_MATCH = u'No Labels match'
PHRASE_NO_MESSAGES_WITH_LABEL = u'No Messages with Label'
PHRASE_NO_PRINT_JOBS = u'No Print Jobs'
PHRASE_NOT_A_GUARDIAN_OR_INVITATION = 'Not a Guardian or Guardian Invitation'
PHRASE_NOT_A_GUARDIAN_INVITATION_NOT_PENDING = 'Not a Guardian and Guardian Invitation status is not PENDING, '
PHRASE_NOT_AN_ENTITY = u'Not a {0}'
PHRASE_NOT_OWNED_BY = u'Not owned by {0}'
PHRASE_NOT_REQUESTED = u'Not requested'
PHRASE_ONLY_ONE_OWNER_ALLOWED = u'Only one owner allowed'
PHRASE_OR = u'or'
PHRASE_PATH_NOT_AVAILABLE = u'Path not available'
PHRASE_PLEASE_SELECT_ENTITY_TO_PROCESS = u'{0} {1} found, please select the correct one to {2} and specify with {3}'
PHRASE_SCHEMA_WOULD_HAVE_NO_FIELDS = u'{0} would have no {1}'
PHRASE_SELECTED = u'Selected'
PHRASE_SERVICE_NOT_APPLICABLE = u'Service not applicable/Does not exist'
PHRASE_STARTING_N_WORKER_THREADS = u'Starting {0} worker threads...\n'
PHRASE_STARTING_THREAD = u'Starting thread'
PHRASE_STRING_LENGTH = u'string length'
PHRASE_THAT_MATCHED_QUERY = u'that matched query'
PHRASE_THAT_MATCH_QUERY = u'that match query'
PHRASE_TO = u'To'
PHRASE_UNAVAILABLE = u'Unavailable'
PHRASE_UNKNOWN = u'Unknown'
PHRASE_UNKNOWN_COMMAND_SELECTOR = u'Unknown command or selector'
PHRASE_USE_DOIT_ARGUMENT_TO_PERFORM_ACTION = u'Use the "doit" argument to perform action'
PHRASE_USE_RECURSIVE_ARGUMENT_TO_COPY_FOLDERS = u'Use "recursive" argument to copy folders'
PHRASE_USER_IN_OTHER_DOMAIN = '{0}: {1} in other domain.'
PHRASE_WAITING_FOR_PROCESSES_TO_COMPLETE = u'Waiting for running processes to finish before proceeding...'
PHRASE_WITH = u'with'
PHRASE_WOULD_MAKE_MEMBERSHIP_CYCLE = u'Would make membership cycle'

MESSAGE_BATCH_CSV_LOOP_DASH_DEBUG_INCOMPATIBLE = u'"gam {0} - ..." is not compatible with debugging. Disable debugging by setting debug_level = 0 in gam.cfg'
MESSAGE_CHECK_VACATION_DATES = u'Check vacation dates, end date must be greater than/equal to start date'
MESSAGE_CSV_DATA_ALREADY_SAVED = u'CSV data already saved'
MESSAGE_DATA_FIELD_MISMATCH = u'datafield {0} does not match saved datafield {1}'
MESSAGE_DOES_NOT_EXIST_OR_HAS_INVALID_FORMAT = u'{0}: {1}, Does not exist or has invalid format'
MESSAGE_SUBKEY_FIELD_MISMATCH = u'subkeyfield {0} does not match saved subkeyfield {1}'
MESSAGE_GAM_EXITING_FOR_UPDATE = u'GAM is now exiting so that you can overwrite this old version with the latest release'
MESSAGE_GAM_OUT_OF_MEMORY = u'GAM has run out of memory. If this is a large G Suite instance, you should use a 64-bit version of GAM on Windows or a 64-bit version of Python on other systems.'
MESSAGE_HEADER_NOT_FOUND_IN_CSV_HEADERS = u'Header "{0}" not found in CSV headers of "{1}".'
MESSAGE_HELP_SYNTAX = u'Help: Syntax in file {0}\n'
MESSAGE_HELP_WIKI = u'Help: Documentation is at {0}\n'
MESSAGE_HIT_CONTROL_C_TO_UPDATE = u'\n\nHit CTRL+C to visit the GAM website and download the latest release or wait 15 seconds continue with this boring old version. GAM won\'t bother you with this announcement for 1 week or you can turn off update checks by setting no_update_check = true in gam.cfg'
MESSAGE_INSUFFICIENT_PERMISSIONS_TO_PERFORM_TASK = u'Insufficient permissions to perform this task'
MESSAGE_INVALID_JSON_INFORMATION = u'Google API reported Invalid JSON Information'
MESSAGE_INVALID_TIME_RANGE = u'{0} {1} must be greater than/equal to {2} {3}'
MESSAGE_MISMATCH_SEARCH_REPLACE_SUBFIELDS = u'The number of subfields ({0}) in search "{1}" does not match the number of subfields ({2}) in replace "{3}"'
MESSAGE_NO_CSV_FILE_DATA_SAVED = u'No CSV file data saved'
MESSAGE_NO_CSV_FILE_SUBKEYS_SAVED = u'No CSV file subkeys saved'
MESSAGE_NO_CSV_HEADERS_IN_FILE = u'No headers found in CSV file "{0}".'
MESSAGE_NO_PYTHON_SSL = u'You don\'t have the Python SSL module installed so we can\'t verify SSL Certificates. You can fix this by installing the Python SSL module or you can live on the edge and turn SSL validation off by setting no_verify_ssl = true in gam.cfg'
MESSAGE_NO_SCOPES_FOR_API = u'There are no scopes authorized for the {0}'
MESSAGE_NO_TRANSFER_LACK_OF_DISK_SPACE = u'Cowardly refusing to perform migration due to lack of target drive space.'
MESSAGE_REFUSING_TO_DEPROVISION_DEVICES = u'Refusing to deprovision {0} devices because acknowledge_device_touch_requirement not specified.\nDeprovisioning a device means the device will have to be physically wiped and re-enrolled to be managed by your domain again.\nThis requires physical access to the device and is very time consuming to perform for each device.\nPlease add "acknowledge_device_touch_requirement" to the GAM command if you understand this and wish to proceed with the deprovision.\nPlease also be aware that deprovisioning can have an effect on your device license count.\nSee https://support.google.com/chrome/a/answer/3523633 for full details.'
MESSAGE_REQUEST_COMPLETED_NO_FILES = u'Request completed but no results/files were returned, try requesting again'
MESSAGE_REQUEST_NOT_COMPLETE = u'Request needs to be completed before downloading, current status is: {0}'
MESSAGE_RESULTS_TOO_LARGE_FOR_GOOGLE_SPREADSHEET = u'Results are too large for Google Spreadsheets. Uploading as a regular CSV file.'
MESSAGE_SKU_PRODUCT_MISMATCH = u'Product {0} of old SKU does not match product {1} of new SKU'
MESSAGE_UNKNOWN_API_OR_VERSION = u'Unknown Google API or version: ({{0}}), contact {0}'.format(__author__)
#
MESSAGE_API_ACCESS_DENIED = u'API access Denied.\nPlease make sure the Client ID: {0} is authorized for the appropriate scopes {1}'
MESSAGE_EXECUTE_GAM_OAUTH_CREATE = u'\nPlease execute "gam oauth create"\n'
MESSAGE_INSTRUCTIONS_CHECK_AUTHORIZATIONS = u'Please run\n\ngam oauth info\ngam user <user> check serviceaccount\n\nto verify authorizations.\n'
MESSAGE_INSTRUCTIONS_CLIENT_SECRETS_JSON = u'Please run\n\ngam create project\ngam oauth create\n\nto create and authorize a Client account.\n'
MESSAGE_INSTRUCTIONS_OAUTH2SERVICE_JSON = u'Please run\n\ngam create project\ngam user <user> check serviceaccount\n\nto create and authorizee a Service account.\n'
MESSAGE_SCOPE_AUTHORIZATION_FAILED = u'Some scopes failed! Please go to:\n\nhttps://admin.google.com/{0}/AdminHome?#OGX:ManageOauthClients\n\nand grant Service Account Client name:\n\n{1}\n\nAccess to scopes:\n\n{2}'
MESSAGE_SCOPE_AUTHORIZATION_PASSED = u'All scopes passed!\nService Account Client name {0} is fully authorized.'
MESSAGE_SERVICE_NOT_APPLICABLE = u'Service not applicable for this address: {0}'
#
# Error message types; keys into ARGUMENT_ERROR_NAMES; arbitrary values but must be unique
ARGUMENT_BLANK = u'blnk'
ARGUMENT_EMPTY = u'empt'
ARGUMENT_EXTRANEOUS = u'extr'
ARGUMENT_INVALID = u'inva'
ARGUMENT_MISSING = u'miss'
# ARGUMENT_ERROR_NAMES[0] is plural,ARGUMENT_ERROR_NAMES[1] is singular
# These values can be translated into other languages
ARGUMENT_ERROR_NAMES = {
  ARGUMENT_BLANK: [u'Blank arguments', u'Blank argument'],
  ARGUMENT_EMPTY: [u'Empty arguments', u'Empty argument'],
  ARGUMENT_EXTRANEOUS: [u'Extra arguments', u'Extra argument'],
  ARGUMENT_INVALID: [u'Invalid arguments', u'Invalid argument'],
  ARGUMENT_MISSING: [u'Missing arguments', u'Missing argument'],
  }
# Program return codes
UNKNOWN_ERROR_RC = 1
USAGE_ERROR_RC = 2
SOCKET_ERROR_RC = 3
GOOGLE_API_ERROR_RC = 4
NETWORK_ERROR_RC = 5
FILE_ERROR_RC = 6
MEMORY_ERROR_RC = 7
KEYBOARD_INTERRUPT_RC = 8
HTTP_ERROR_RC = 9
SCOPES_NOT_AUTHORIZED = 10
API_ACCESS_DENIED_RC = 12
CONFIG_ERROR_RC = 13
CERTIFICATE_VALIDATION_UNSUPPORTED_RC = 14
NO_SCOPES_FOR_API_RC = 15
CLIENT_SECRETS_JSON_REQUIRED_RC = 16
OAUTH2SERVICE_JSON_REQUIRED_RC = 16
OAUTH2_TXT_REQUIRED_RC = 16
INVALID_JSON_RC = 17
AUTHENTICATION_TOKEN_REFRESH_ERROR_RC = 18
HARD_ERROR_RC = 19
# Information
ENTITY_IS_A_USER_RC = 20
ENTITY_IS_A_USER_ALIAS_RC = 21
ENTITY_IS_A_GROUP_RC = 22
ENTITY_IS_A_GROUP_ALIAS_RC = 23
# Warnings/Errors
AC_FAILED_RC = 50
AC_NOT_PERFORMED_RC = 51
BAD_REQUEST_RC = 53
DATA_NOT_AVALIABLE_RC = 55
ENTITY_DOES_NOT_EXIST_RC = 56
ENTITY_DUPLICATE_RC = 57
ENTITY_IS_NOT_AN_ALIAS_RC = 58
ENTITY_IS_UKNOWN_RC = 59
NO_ENTITIES_FOUND = 60
INVALID_DOMAIN_RC = 61
INVALID_DOMAIN_VALUE_RC = 62
INVALID_TOKEN_RC = 63
JSON_LOADS_ERROR_RC = 64
MULTIPLE_DELETED_USERS_FOUND_RC = 65
NO_CSV_HEADERS_ERROR_RC = 66
INSUFFICIENT_PERMISSIONS_RC = 67
REQUEST_COMPLETED_NO_RESULTS_RC = 71
REQUEST_NOT_COMPLETED_RC = 72
SERVICE_NOT_APPLICABLE_RC = 73
TARGET_DRIVE_SPACE_ERROR_RC = 74
USER_REQUIRED_TO_CHANGE_PASSWORD_ERROR_RC = 75
USER_SUSPENDED_ERROR_RC = 76
#
def convertUTF8(data):
  if isinstance(data, str):
    return data
  if isinstance(data, unicode):
    return data.encode(GM_Globals[GM_SYS_ENCODING], 'replace')
  if isinstance(data, collections.Mapping):
    return dict(map(convertUTF8, data.iteritems()))
  if isinstance(data, collections.Iterable):
    return type(data)(map(convertUTF8, data))
  return data

def writeStdout(data):
  try:
    GM_Globals[GM_STDOUT].get(GM_REDIRECT_MULTI_FD, sys.stdout).write(data)
  except IOError as e:
    systemErrorExit(FILE_ERROR_RC, e)

def writeStderr(data):
  try:
    GM_Globals[GM_STDERR].get(GM_REDIRECT_MULTI_FD, sys.stderr).write(data)
  except IOError as e:
    systemErrorExit(FILE_ERROR_RC, e)

def flushStderr():
  try:
    GM_Globals[GM_STDERR].get(GM_REDIRECT_MULTI_FD, sys.stderr).flush()
  except IOError as e:
    systemErrorExit(FILE_ERROR_RC, e)

class _DeHTMLParser(HTMLParser):
  def __init__(self):
    HTMLParser.__init__(self)
    self.__text = []

  def handle_data(self, data):
    self.__text.append(data)

  def handle_charref(self, name):
    self.__text.append(unichr(int(name[1:], 16)) if name.startswith('x') else unichr(int(name)))

  def handle_entityref(self, name):
    cp = name2codepoint.get(name)
    if cp:
      self.__text.append(unichr(cp))
    else:
      self.__text.append(u'&'+name)

  def handle_starttag(self, tag, attrs):
    if tag == 'p':
      self.__text.append('\n\n')
    elif tag == 'br':
      self.__text.append('\n')
    elif tag == 'a':
      for attr in attrs:
        if attr[0] == 'href':
          self.__text.append('({0}) '.format(attr[1]))
          break
    elif tag == 'div':
      if not attrs:
        self.__text.append('\n')
    elif tag in ['http:', 'https']:
      self.__text.append(' ({0}//{1}) '.format(tag, attrs[0][0]))

  def handle_startendtag(self, tag, attrs):
    if tag == 'br':
      self.__text.append('\n\n')

  def text(self):
    return re.sub(r'\n{2}\n+', '\n\n', re.sub(r'\n +', '\n', ''.join(self.__text))).strip()

def dehtml(text):
  try:
    parser = _DeHTMLParser()
    parser.feed(text.encode(u'utf-8'))
    parser.close()
    return parser.text()
  except HTMLParseError:
    from traceback import print_exc
    print_exc(file=sys.stderr)
    return text

# Format a key value list
#   key, value	-> "key: value" + ", " if not last item
#   key, ''	-> "key:" + ", " if not last item
#   key, None	-> "key" + " " if not last item
def formatKeyValueList(prefixStr, kvList, suffixStr):
  msg = prefixStr
  i = 0
  l = len(kvList)
  while i < l:
    if isinstance(kvList[i], (bool, int)):
      msg += str(kvList[i])
    else:
      msg += kvList[i]
    i += 1
    if i < l:
      val = kvList[i]
      if (val is not None) or (i == l-1):
        msg += u':'
        if (val is not None) and (not isinstance(val, (str, unicode)) or len(val) > 0):
          msg += u' '
          if isinstance(val, (bool, int)):
            msg += str(val)
          else:
            msg += val
        i += 1
        if i < l:
          msg += u', '
      else:
        i += 1
        if i < l:
          msg += u' '
  msg += suffixStr
  return msg.encode(GM_Globals[GM_SYS_ENCODING], 'replace')

def formatEntityValueList(entityValueList):
  evList = []
  for j in range(0, len(entityValueList), 2):
    evList.append(Entity.Singular(entityValueList[j]))
    evList.append(entityValueList[j+1])
  return evList

# Error exits
def formatExceptionMessage(e, message=u''):
  return convertUTF8(u'{0} - {1}{2}'.format(e.errno, e.strerror, message))

def setSysExitRC(sysRC):
  GM_Globals[GM_SYSEXITRC] = sysRC

def printErrorMessage(sysRC, message):
  setSysExitRC(sysRC)
  writeStderr(formatKeyValueList(Indent.Spaces(), [ERROR, message], u'\n'))

def stderrErrorMsg(message):
  writeStderr(convertUTF8(u'\n{0}{1}\n'.format(ERROR_PREFIX, message)))

def stderrWarningMsg(message):
  writeStderr(convertUTF8(u'\n{0}{1}\n'.format(WARNING_PREFIX, message)))

def systemErrorExit(sysRC, message):
  if message:
    stderrErrorMsg(message)
  sys.exit(sysRC)

# Something's wrong with CustomerID
def accessErrorMessage(cd):
  try:
    callGAPI(cd.customers(), u'get',
             throw_reasons=[GAPI_BAD_REQUEST, GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN],
             customerKey=GC_Values[GC_CUSTOMER_ID], fields=u'id')
  except GAPI_badRequest:
    return formatKeyValueList(u'',
                              [Entity.Singular(Entity.CUSTOMER_ID), GC_Values[GC_CUSTOMER_ID],
                               PHRASE_INVALID],
                              u'')
  except GAPI_resourceNotFound:
    return formatKeyValueList(u'',
                              [Entity.Singular(Entity.CUSTOMER_ID), GC_Values[GC_CUSTOMER_ID],
                               PHRASE_DOES_NOT_EXIST],
                              u'')
  except GAPI_forbidden:
    return formatKeyValueList(u'',
                              formatEntityValueList([Entity.CUSTOMER_ID, GC_Values[GC_CUSTOMER_ID],
                                                     Entity.DOMAIN, GC_Values[GC_DOMAIN],
                                                     Entity.USER, GM_Globals[GM_ADMIN]])+[PHRASE_ACCESS_FORBIDDEN],
                              u'')
  return None

def accessErrorExit(cd):
  systemErrorExit(INVALID_DOMAIN_RC, accessErrorMessage(cd or buildGAPIObject(DIRECTORY_API)))

def APIAccessDeniedExit():
  stderrErrorMsg(MESSAGE_API_ACCESS_DENIED.format(GM_Globals[GM_OAUTH2_CLIENT_ID], u','.join(GM_Globals[GM_CURRENT_API_SCOPES])))
  writeStderr(MESSAGE_INSTRUCTIONS_CHECK_AUTHORIZATIONS)
  systemErrorExit(API_ACCESS_DENIED_RC, None)

def checkEntityDNEorAccessErrorExit(cd, entityType, entityName, i=0, count=0):
  message = accessErrorMessage(cd)
  if message:
    systemErrorExit(INVALID_DOMAIN_RC, message)
  entityDoesNotExistWarning(entityType, entityName, i, count)

def checkEntityAFDNEorAccessErrorExit(cd, entityType, entityName, i=0, count=0):
  message = accessErrorMessage(cd)
  if message:
    systemErrorExit(INVALID_DOMAIN_RC, message)
  entityActionFailedWarning([entityType, entityName], PHRASE_DOES_NOT_EXIST, i, count)

def checkEntityItemValueAFDNEorAccessErrorExit(cd, entityType, entityName, itemType, itemValue, i=0, count=0):
  message = accessErrorMessage(cd)
  if message:
    systemErrorExit(INVALID_DOMAIN_RC, message)
  entityActionFailedWarning([entityType, entityName, itemType, itemValue], PHRASE_DOES_NOT_EXIST, i, count)

def invalidClientSecretsJsonExit():
  stderrErrorMsg(MESSAGE_DOES_NOT_EXIST_OR_HAS_INVALID_FORMAT.format(Entity.Singular(Entity.CLIENT_SECRETS_JSON_FILE), GC_Values[GC_CLIENT_SECRETS_JSON]))
  writeStderr(MESSAGE_INSTRUCTIONS_CLIENT_SECRETS_JSON)
  systemErrorExit(CLIENT_SECRETS_JSON_REQUIRED_RC, None)

def invalidOauth2serviceJsonExit():
  stderrErrorMsg(MESSAGE_DOES_NOT_EXIST_OR_HAS_INVALID_FORMAT.format(Entity.Singular(Entity.OAUTH2SERVICE_JSON_FILE), GC_Values[GC_OAUTH2SERVICE_JSON]))
  writeStderr(MESSAGE_INSTRUCTIONS_OAUTH2SERVICE_JSON)
  systemErrorExit(OAUTH2SERVICE_JSON_REQUIRED_RC, None)

def invalidOauth2TxtExit():
  stderrErrorMsg(MESSAGE_DOES_NOT_EXIST_OR_HAS_INVALID_FORMAT.format(Entity.Singular(Entity.OAUTH2_TXT_FILE), GC_Values[GC_OAUTH2_TXT]))
  writeStderr(MESSAGE_EXECUTE_GAM_OAUTH_CREATE)
  systemErrorExit(OAUTH2_TXT_REQUIRED_RC, None)

def invalidDiscoveryJsonExit(fileName):
  stderrErrorMsg(MESSAGE_DOES_NOT_EXIST_OR_HAS_INVALID_FORMAT.format(Entity.Singular(Entity.DISCOVERY_JSON_FILE), fileName))
  systemErrorExit(INVALID_JSON_RC, None)

def noPythonSSLExit():
  systemErrorExit(CERTIFICATE_VALIDATION_UNSUPPORTED_RC, MESSAGE_NO_PYTHON_SSL)

def usageErrorExit(message, extraneous=False):
  writeStderr(convertUTF8(CLArgs.CommandLineWithBadArgumentMarked(extraneous)))
  stderrErrorMsg(message)
  writeStderr(MESSAGE_HELP_SYNTAX.format(os.path.join(GM_Globals[GM_GAM_PATH], FN_GAMCOMMANDS_TXT)))
  writeStderr(MESSAGE_HELP_WIKI.format(GAM_WIKI))
  sys.exit(USAGE_ERROR_RC)

def badEntitiesExit(entityType, count, phraseList, backupArg=False):
  if backupArg:
    CLArgs.Backup()
  usageErrorExit(u'{0} {1} {2}'.format(count, Entity.Choose(entityType, count), phraseList[count == 1]))

def csvFieldErrorExit(fieldName, fieldNames, backupArg=False, checkForCharset=False):
  if backupArg:
    CLArgs.Backup()
    if checkForCharset and CLArgs.Previous() == u'charset':
      CLArgs.Backup()
      CLArgs.Backup()
  usageErrorExit(MESSAGE_HEADER_NOT_FOUND_IN_CSV_HEADERS.format(fieldName, u','.join(fieldNames)))

def csvDataAlreadySavedErrorExit():
  CLArgs.Backup()
  usageErrorExit(MESSAGE_CSV_DATA_ALREADY_SAVED)

# The last thing shown is unknown
def unknownArgumentExit():
  CLArgs.Backup()
  usageErrorExit(ARGUMENT_ERROR_NAMES[ARGUMENT_INVALID][1])

# Argument describes what's expected
def expectedArgumentExit(problem, argument):
  usageErrorExit(u'{0}: {1} <{2}>'.format(problem, PHRASE_EXPECTED, argument))

def blankArgumentExit(argument):
  expectedArgumentExit(ARGUMENT_ERROR_NAMES[ARGUMENT_BLANK][1], u'{0} {1}'.format(PHRASE_NON_BLANK, argument))

def emptyArgumentExit(argument):
  expectedArgumentExit(ARGUMENT_ERROR_NAMES[ARGUMENT_EMPTY][1], u'{0} {1}'.format(PHRASE_NON_EMPTY, argument))

def invalidArgumentExit(argument):
  expectedArgumentExit(ARGUMENT_ERROR_NAMES[ARGUMENT_INVALID][1], argument)

def missingArgumentExit(argument):
  expectedArgumentExit(ARGUMENT_ERROR_NAMES[ARGUMENT_MISSING][1], argument)

# Choices is the valid set of choices that was expected
def formatChoiceList(choices):
  choiceList = choices.keys() if isinstance(choices, dict) else choices
  if len(choiceList) <= 5:
    return u'|'.join(choiceList)
  else:
    return u'|'.join(sorted(choiceList))

def invalidChoiceExit(choices):
  expectedArgumentExit(ARGUMENT_ERROR_NAMES[ARGUMENT_INVALID][1], formatChoiceList(choices))

def missingChoiceExit(choices):
  expectedArgumentExit(ARGUMENT_ERROR_NAMES[ARGUMENT_MISSING][1], formatChoiceList(choices))

# Check if argument present
def checkArgumentPresent(choices, required=False):
  if CLArgs.ArgumentsRemaining():
    choice = CLArgs.Current().strip().lower()
    if choice:
      if choice in choices:
        CLArgs.Advance()
        return choice
    if not required:
      return False
    invalidChoiceExit(choices)
  elif not required:
    return False
  missingChoiceExit(choices)

# Peek to see if argument present, do not advance
def peekArgumentPresent(choices):
  if CLArgs.ArgumentsRemaining():
    choice = CLArgs.Current().strip().lower()
    if choice and choice in choices:
      return True
  return False

# Check that there are no extraneous arguments at the end of the command line
def checkForExtraneousArguments():
  if CLArgs.ArgumentsRemaining():
    usageErrorExit(ARGUMENT_ERROR_NAMES[ARGUMENT_EXTRANEOUS][[1, 0][CLArgs.MultipleArgumentsRemaining()]], extraneous=True)

# Get an argument, downshift, delete underscores
def getArgument():
  if CLArgs.ArgumentsRemaining():
    argument = CLArgs.Current().lower()
    if argument:
      CLArgs.Advance()
      return argument.replace(u'_', u'')
  missingArgumentExit(OB_ARGUMENT)

def getBoolean(defaultValue=None):
  if CLArgs.ArgumentsRemaining():
    boolean = CLArgs.Current().strip().lower()
    if boolean in TRUE_VALUES:
      CLArgs.Advance()
      return True
    if boolean in FALSE_VALUES:
      CLArgs.Advance()
      return False
    if defaultValue is not None:
      return defaultValue
    invalidChoiceExit(TRUE_FALSE)
  if defaultValue is not None:
    return defaultValue
  missingChoiceExit(TRUE_FALSE)

DEFAULT_CHOICE = u'defaultChoice'
CHOICE_ALIASES = u'choiceAliases'
MAP_CHOICE = u'mapChoice'
NO_DEFAULT = u'NoDefault'

def getChoice(choices, **opts):
  if CLArgs.ArgumentsRemaining():
    choice = CLArgs.Current().strip().lower()
    if choice:
      if choice in opts.get(CHOICE_ALIASES, []):
        choice = opts[CHOICE_ALIASES][choice]
      if choice not in choices:
        choice = choice.replace(u'_', u'').replace(u'-', u'')
        if choice in opts.get(CHOICE_ALIASES, []):
          choice = opts[CHOICE_ALIASES][choice]
      if choice in choices:
        CLArgs.Advance()
        return choice if not opts.get(MAP_CHOICE, False) else choices[choice]
    if opts.get(DEFAULT_CHOICE, NO_DEFAULT) != NO_DEFAULT:
      return opts[DEFAULT_CHOICE]
    invalidChoiceExit(choices)
  elif opts.get(DEFAULT_CHOICE, NO_DEFAULT) != NO_DEFAULT:
    return opts[DEFAULT_CHOICE]
  missingChoiceExit(choices)

def getChoiceAndValue(item, choices, delimiter):
  if not CLArgs.ArgumentsRemaining() or CLArgs.Current().find(delimiter) == -1:
    return (None, None)
  choice, value = CLArgs.Current().strip().split(delimiter, 1)
  choice = choice.strip().lower()
  value = value.strip()
  if choice in choices:
    if value:
      CLArgs.Advance()
      return (choice, value)
    missingArgumentExit(item)
  invalidChoiceExit(choices)

COLORHEX_PATTERN = re.compile(r'^#[0-9a-fA-F]{6}$')
COLORHEX_FORMAT_REQUIRED = u'#ffffff'

def getColorHexAttribute():
  if CLArgs.ArgumentsRemaining():
    tg = COLORHEX_PATTERN.match(CLArgs.Current().strip())
    if tg:
      CLArgs.Advance()
      return tg.group(0)
    invalidArgumentExit(COLORHEX_FORMAT_REQUIRED)
  missingArgumentExit(COLORHEX_FORMAT_REQUIRED)

def removeCourseIdScope(courseId):
  if courseId.startswith(u'd:'):
    return courseId[2:]
  return courseId

def addCourseIdScope(courseId):
  if not courseId.isdigit() and courseId[:2] != u'd:':
    return u'd:{0}'.format(courseId)
  return courseId

def getCourseId():
  if CLArgs.ArgumentsRemaining():
    courseId = CLArgs.Current()
    if courseId:
      CLArgs.Advance()
      return addCourseIdScope(courseId)
  missingArgumentExit(OB_COURSE_ID)

def getCourseAlias():
  if CLArgs.ArgumentsRemaining():
    courseAlias = CLArgs.Current()
    if courseAlias:
      CLArgs.Advance()
      if courseAlias[:2] != u'd:':
        return u'd:{0}'.format(courseAlias)
      return courseAlias
  missingArgumentExit(OB_COURSE_ALIAS)

UID_PATTERN = re.compile(r'u?id: ?(.*)')

def validateEmailAddressOrUID(emailAddressOrUID):
  cg = UID_PATTERN.match(emailAddressOrUID)
  if cg:
    return cg.group(1)
  return emailAddressOrUID.find(u'@') != 0 and emailAddressOrUID.count(u'@') <= 1

# Normalize user/group email address/uid
# uid:12345abc -> 12345abc
# foo -> foo@domain
# foo@ -> foo@domain
# foo@bar.com -> foo@bar.com
# @domain -> domain
def normalizeEmailAddressOrUID(emailAddressOrUID, noUid=False, checkForCustomerId=False):
  if checkForCustomerId and (emailAddressOrUID == GC_Values[GC_CUSTOMER_ID]):
    return emailAddressOrUID
  if not noUid:
    cg = UID_PATTERN.match(emailAddressOrUID)
    if cg:
      return cg.group(1)
  atLoc = emailAddressOrUID.find(u'@')
  if atLoc == 0:
    return emailAddressOrUID[1:].lower()
  if (atLoc == -1) or (atLoc == len(emailAddressOrUID)-1) and GC_Values[GC_DOMAIN]:
    if atLoc == -1:
      emailAddressOrUID = u'{0}@{1}'.format(emailAddressOrUID, GC_Values[GC_DOMAIN])
    else:
      emailAddressOrUID = u'{0}{1}'.format(emailAddressOrUID, GC_Values[GC_DOMAIN])
  return emailAddressOrUID.lower()

# Normalize student/guardian email address/uid
# 12345678 -> 12345678
# - -> -
# Otherwise, same results as normalizeEmailAddressOrUID
def normalizeStudentGuardianEmailAddressOrUID(emailAddressOrUID):
  if emailAddressOrUID.isdigit() or emailAddressOrUID == u'-':
    return emailAddressOrUID
  return normalizeEmailAddressOrUID(emailAddressOrUID)

def getEmailAddress(noUid=False, minLen=1, optional=False):
  if CLArgs.ArgumentsRemaining():
    emailAddress = CLArgs.Current().strip().lower()
    if emailAddress:
      cg = UID_PATTERN.match(emailAddress)
      if cg:
        if not noUid:
          if cg.group(1):
            CLArgs.Advance()
            return cg.group(1)
        else:
          invalidArgumentExit(u'name@domain')
      else:
        atLoc = emailAddress.find(u'@')
        if atLoc == -1:
          if GC_Values[GC_DOMAIN]:
            emailAddress = u'{0}@{1}'.format(emailAddress, GC_Values[GC_DOMAIN])
          CLArgs.Advance()
          return emailAddress
        if atLoc != 0:
          if (atLoc == len(emailAddress)-1) and GC_Values[GC_DOMAIN]:
            emailAddress = u'{0}{1}'.format(emailAddress, GC_Values[GC_DOMAIN])
          CLArgs.Advance()
          return emailAddress
        invalidArgumentExit(u'name@domain')
    if optional:
      CLArgs.Advance()
      return None
    elif minLen == 0:
      CLArgs.Advance()
      return u''
  elif optional:
    return None
  missingArgumentExit([OB_EMAIL_ADDRESS_OR_UID, OB_EMAIL_ADDRESS][noUid])

def getPermissionId():
  if CLArgs.ArgumentsRemaining():
    emailAddress = CLArgs.Current().strip().lower()
    if emailAddress:
      if emailAddress[:3] == u'id:':
        CLArgs.Advance()
        return (False, CLArgs.Previous().strip()[3:])
      atLoc = emailAddress.find(u'@')
      if atLoc == -1:
        if emailAddress == u'anyone':
          CLArgs.Advance()
          return (False, emailAddress)
        if emailAddress == u'anyonewithlink':
          CLArgs.Advance()
          return (False, u'anyoneWithLink')
        if GC_Values[GC_DOMAIN]:
          emailAddress = u'{0}@{1}'.format(emailAddress, GC_Values[GC_DOMAIN])
        CLArgs.Advance()
        return (True, emailAddress)
      if atLoc != 0:
        if (atLoc == len(emailAddress)-1) and GC_Values[GC_DOMAIN]:
          emailAddress = u'{0}{1}'.format(emailAddress, GC_Values[GC_DOMAIN])
        CLArgs.Advance()
        return (True, emailAddress)
      invalidArgumentExit(u'name@domain')
  missingArgumentExit(OB_DRIVE_FILE_PERMISSION_ID)

# Products/SKUs
#
SKUS = {
  u'Google-Apps-For-Business': {
    u'product': u'Google-Apps', u'aliases': [u'gafb', u'gafw', u'basic', u'gsuitebasic'], u'displayName': u'G Suite Basic'},
  u'Google-Apps-For-Government': {
    u'product': u'Google-Apps', u'aliases': [u'gafg', u'gsuitegovernment', u'gsuitegov'], u'displayName': u'G Suite Government'},
  u'Google-Apps-For-Postini': {
    u'product': u'Google-Apps', u'aliases': [u'gams', u'postini', u'gsuitegams', u'gsuitepostini', u'gsuitemessagesecurity'], u'displayName': u'G Suite Message Security'},
  u'Google-Apps-Lite': {
    u'product': u'Google-Apps', u'aliases': [u'gal', u'lite', u'gsuitelite'], u'displayName': u'G Suite Lite'},
  u'Google-Apps-Unlimited': {
    u'product': u'Google-Apps', u'aliases': [u'gau', u'unlimited', u'gsuitebusiness'], u'displayName': u'G Suite Business'},
  u'1010020020': {
    u'product': u'Google-Apps', u'aliases': [u'gae', u'enterprise', u'gsuiteenterprise'], u'displayName': u'G Suite Enterprise'},
  u'Google-Drive-storage-20GB': {
    u'product': u'Google-Drive-storage', u'aliases': [u'drive20gb', u'20gb', u'googledrivestorage20gb'], u'displayName': u'Google Drive Storage 20GB'},
  u'Google-Drive-storage-50GB': {
    u'product': u'Google-Drive-storage', u'aliases': [u'drive50gb', u'50gb', u'googledrivestorage50gb'], u'displayName': u'Google Drive Storage 50GB'},
  u'Google-Drive-storage-200GB': {
    u'product': u'Google-Drive-storage', u'aliases': [u'drive200gb', u'200gb', u'googledrivestorage200gb'], u'displayName': u'Google Drive Storage 200GB'},
  u'Google-Drive-storage-400GB': {
    u'product': u'Google-Drive-storage', u'aliases': [u'drive400gb', u'400gb', u'googledrivestorage400gb'], u'displayName': u'Google Drive Storage 400GB'},
  u'Google-Drive-storage-1TB': {
    u'product': u'Google-Drive-storage', u'aliases': [u'drive1tb', u'1tb', u'googledrivestorage1tb'], u'displayName': u'Google Drive Storage 1TB'},
  u'Google-Drive-storage-2TB': {
    u'product': u'Google-Drive-storage', u'aliases': [u'drive2tb', u'2tb', u'googledrivestorage2tb'], u'displayName': u'Google Drive Storage 2TB'},
  u'Google-Drive-storage-4TB': {
    u'product': u'Google-Drive-storage', u'aliases': [u'drive4tb', u'4tb', u'googledrivestorage4tb'], u'displayName': u'Google Drive Storage 4TB'},
  u'Google-Drive-storage-8TB': {
    u'product': u'Google-Drive-storage', u'aliases': [u'drive8tb', u'8tb', u'googledrivestorage8tb'], u'displayName': u'Google Drive Storage 8TB'},
  u'Google-Drive-storage-16TB': {
    u'product': u'Google-Drive-storage', u'aliases': [u'drive16tb', u'16tb', u'googledrivestorage16tb'], u'displayName': u'Google Drive Storage 16TB'},
  u'Google-Vault': {
    u'product': u'Google-Vault', u'aliases': [u'vault', u'googlevault'], u'displayName': u'Google Vault'},
  u'Google-Vault-Former-Employee': {
    u'product': u'Google-Vault', u'aliases': [u'vfe', u'googlevaultformeremployee'], u'displayName': u'Google Vault Former Employee'},
  u'Google-Coordinate': {
    u'product': u'Google-Coordinate', u'aliases': [u'coordinate', u'googlecoordinate'], u'displayName': u'Google Coordinate'},
  u'Google-Chrome-Device-Management': {
    u'product': u'Google-Chrome-Device-Management', u'aliases': [u'chrome', u'cdm', u'googlechromedevicemanagement'], u'displayName': u'Google Chrome Device Management'}
  }

def getProductAndSKU(sku):
  l_sku = sku.lower().replace(u'-', u'').replace(u' ', u'')
  for a_sku, sku_values in SKUS.items():
    if l_sku == a_sku.lower().replace(u'-', u'') or l_sku in sku_values[u'aliases'] or l_sku == sku_values[u'displayName'].lower().replace(u' ', u''):
      return (sku_values[u'product'], a_sku)
  try:
    product = re.search(u'^([A-Z,a-z]*-[A-Z,a-z]*)', sku).group(1)
  except AttributeError:
    product = sku
  return (product, sku)

def _skuIdToDisplayName(skuId):
  return SKUS[skuId][u'displayName'] if skuId in SKUS else skuId

def _formatSKUIdDisplayName(skuId):
  skuIdDisplay = _skuIdToDisplayName(skuId)
  if skuId == skuIdDisplay:
    return skuId
  return u'{0} ({1})'.format(skuId, skuIdDisplay)

def _normalizeProduct(product):
  l_product = product.lower().replace(u'-', u'').replace(u' ', u'')
  for a_sku, sku_values in SKUS.items():
    if l_product == sku_values[u'product'].lower().replace(u'-', u'') or l_product == a_sku.lower().replace(u'-', u'') or l_product in sku_values[u'aliases'] or l_product == sku_values[u'displayName'].lower().replace(u' ', u''):
      return sku_values[u'product']
  return product

def getGoogleProduct():
  if CLArgs.ArgumentsRemaining():
    product = CLArgs.Current().strip()
    if product:
      CLArgs.Advance()
      return _normalizeProduct(product)
  missingArgumentExit(OB_PRODUCT_ID)

def getGoogleProductList():
  if CLArgs.ArgumentsRemaining():
    productsList = []
    for product in shlexSplitList(CLArgs.Current()):
      product = _normalizeProduct(product)
      if product not in productsList:
        productsList.append(product)
    CLArgs.Advance()
    return productsList
  missingArgumentExit(OB_PRODUCT_ID_LIST)

def getGoogleSKU():
  if CLArgs.ArgumentsRemaining():
    sku = CLArgs.Current().strip()
    if sku:
      CLArgs.Advance()
      return getProductAndSKU(sku)
  missingArgumentExit(OB_SKU_ID)

def getGoogleSKUList():
  if CLArgs.ArgumentsRemaining():
    skusList = []
    for sku in shlexSplitList(CLArgs.Current()):
      _, sku = getProductAndSKU(sku)
      if sku not in skusList:
        skusList.append(sku)
    CLArgs.Advance()
    return skusList
  missingArgumentExit(OB_SKU_ID_LIST)

def integerLimits(minVal, maxVal, item=u'integer'):
  if (minVal is not None) and (maxVal is not None):
    return u'{0} {1}<=x<={2}'.format(item, minVal, maxVal)
  if minVal is not None:
    return u'{0} x>={1}'.format(item, minVal)
  if maxVal is not None:
    return u'{0} x<={1}'.format(item, maxVal)
  return u'{0} x'.format(item)

def getInteger(minVal=None, maxVal=None):
  if CLArgs.ArgumentsRemaining():
    try:
      number = int(CLArgs.Current().strip())
      if ((minVal is None) or (number >= minVal)) and ((maxVal is None) or (number <= maxVal)):
        CLArgs.Advance()
        return number
    except ValueError:
      pass
    invalidArgumentExit(integerLimits(minVal, maxVal))
  missingArgumentExit(integerLimits(minVal, maxVal))

# a|b|c|(custom_type <String>)
# if argument == CUSTOM_TYPE_EXPLICIT[PTKW_CL_TYPE_KEYWORD]:
#   getKeywordAttribute(CUSTOM_TYPE_EXPLICIT, attrdict)

#CUSTOM_TYPE_EXPLICIT = {
#    PTKW_CL_TYPE_KEYWORD: u'type',
#    PTKW_CL_CUSTOMTYPE_KEYWORD: u'custom_type',
#    PTKW_ATTR_TYPE_KEYWORD: u'type',
#    PTKW_ATTR_TYPE_CUSTOM_VALUE: u'custom',
#    PTKW_ATTR_CUSTOMTYPE_KEYWORD: u'customType',
#    PTKW_KEYWORD_LIST: [u'custom_type', u'a', u'b', u'c']
#    }

# a|b|c
# if argument == CUSTOM_TYPE_NOCUSTOM[PTKW_CL_TYPE_KEYWORD]:
#   getKeywordAttribute(CUSTOM_TYPE_NOCUSTOM, attrdict)

#CUSTOM_TYPE_NOCUSTOM = {
#    PTKW_CL_TYPE_KEYWORD: u'type',
#    PTKW_CL_CUSTOMTYPE_KEYWORD: u'type',
#    PTKW_ATTR_TYPE_KEYWORD: u'type',
#    PTKW_ATTR_TYPE_CUSTOM_VALUE: None,
#    PTKW_ATTR_CUSTOMTYPE_KEYWORD: None,
#    PTKW_KEYWORD_LIST: [u'a', u'b', u'c']
#    }

# a|b|c|<String>
# if argument == CUSTOM_TYPE_IMPLICIT[PTKW_CL_TYPE_KEYWORD]:
#   getKeywordAttribute(CUSTOM_TYPE_IMPLICIT, attrdict)

#CUSTOM_TYPE_IMPLICIT = {
#    PTKW_CL_TYPE_KEYWORD: u'type',
#    PTKW_CL_CUSTOMTYPE_KEYWORD: None,
#    PTKW_ATTR_TYPE_KEYWORD: u'type',
#    PTKW_ATTR_TYPE_CUSTOM_VALUE: u'custom',
#    PTKW_ATTR_CUSTOMTYPE_KEYWORD: u'customType',
#    PTKW_KEYWORD_LIST: [u'a', u'b', u'c']
#    }

# (a|b|c) | (custom_type <String>)
# if argument == CUSTOM_TYPE_IMPLICIT[PTKW_CL_TYPE_KEYWORD]:
#   getKeywordAttribute(CUSTOM_TYPE_IMPLICIT, attrdict)
# elif argument == CUSTOM_TYPE_IMPLICIT[PTKW_CL_CUSTOMTYPE_KEYWORD]:
#   attrdict[CUSTOM_TYPE_DIFFERENT_KEYWORD[PTKW_ATTR_TYPE_KEYWORD] = CUSTOM_TYPE_DIFFERENT_KEYWORD[PTKW_ATTR_CUSTOMTYPE_KEYWORD]
#   attrdict[CUSTOM_TYPE_DIFFERENT_KEYWORD[PTKW_ATTR_CUSTOMTYPE_KEYWORD]] = getValue()

#CUSTOM_TYPE_DIFFERENT_KEYWORD = {
#    PTKW_CL_TYPE_KEYWORD: u'type',
#    PTKW_CL_CUSTOMTYPE_KEYWORD: u'custom_type',
#    PTKW_ATTR_TYPE_KEYWORD: u'type',
#    PTKW_ATTR_TYPE_CUSTOM_VALUE: u'custom',
#    PTKW_ATTR_CUSTOMTYPE_KEYWORD: u'customType',
#    PTKW_KEYWORD_LIST: [u'a', u'b', u'c']
#    }
def getKeywordAttribute(UProp, keywords, attrdict, **opts):
  if CLArgs.ArgumentsRemaining():
    keyword = CLArgs.Current().strip().lower()
    if keyword in keywords[UProp.PTKW_KEYWORD_LIST]:
      CLArgs.Advance()
      attrdict[keywords[UProp.PTKW_ATTR_TYPE_KEYWORD]] = keyword
      if keyword != keywords[UProp.PTKW_CL_CUSTOMTYPE_KEYWORD]:
        return
      if CLArgs.ArgumentsRemaining():
        customType = CLArgs.Current().strip()
        if customType:
          CLArgs.Advance()
          attrdict[keywords[UProp.PTKW_ATTR_TYPE_KEYWORD]] = keywords[UProp.PTKW_ATTR_TYPE_CUSTOM_VALUE]
          attrdict[keywords[UProp.PTKW_ATTR_CUSTOMTYPE_KEYWORD]] = customType
          return
      missingArgumentExit(u'custom attribute type')
    elif DEFAULT_CHOICE in opts:
      attrdict[keywords[UProp.PTKW_ATTR_TYPE_KEYWORD]] = opts[DEFAULT_CHOICE]
      return
    elif not keywords[UProp.PTKW_CL_CUSTOMTYPE_KEYWORD]:
      attrdict[keywords[UProp.PTKW_ATTR_TYPE_KEYWORD]] = keywords[UProp.PTKW_ATTR_TYPE_CUSTOM_VALUE]
      attrdict[keywords[UProp.PTKW_ATTR_CUSTOMTYPE_KEYWORD]] = CLArgs.Current()
      CLArgs.Advance()
      return
    invalidChoiceExit(keywords[UProp.PTKW_KEYWORD_LIST])
  elif DEFAULT_CHOICE in opts:
    attrdict[keywords[UProp.PTKW_ATTR_TYPE_KEYWORD]] = opts[DEFAULT_CHOICE]
    return
  missingChoiceExit(keywords[UProp.PTKW_KEYWORD_LIST])

def orgUnitPathQuery(path):
  return u"orgUnitPath='{0}'".format(path.replace(u"'", u"\'"))

def makeOrgUnitPathAbsolute(path):
  if path == u'/':
    return path
  if path.startswith(u'/'):
    return path.rstrip(u'/')
  if path.startswith(u'id:'):
    return path
  if path.startswith(u'uid:'):
    return path[1:]
  return u'/'+path.rstrip(u'/')

def makeOrgUnitPathRelative(path):
  if path == u'/':
    return path
  if path.startswith(u'/'):
    return path[1:].rstrip(u'/')
  if path.startswith(u'id:'):
    return path
  if path.startswith(u'uid:'):
    return path[1:]
  return path.rstrip(u'/')

def getOrgUnitItem(pathOnly=False, absolutePath=True):
  if CLArgs.ArgumentsRemaining():
    path = CLArgs.Current().strip()
    if path:
      if pathOnly and (path.startswith(u'id:') or path.startswith(u'uid:')):
        invalidArgumentExit(OB_ORGUNIT_PATH)
      CLArgs.Advance()
      if absolutePath:
        return makeOrgUnitPathAbsolute(path)
      return makeOrgUnitPathRelative(path)
  missingArgumentExit([OB_ORGUNIT_ITEM, OB_ORGUNIT_PATH][pathOnly])

def getREPattern():
  if CLArgs.ArgumentsRemaining():
    patstr = CLArgs.Current()
    if patstr:
      try:
        pattern = re.compile(patstr)
        CLArgs.Advance()
        return pattern
      except re.error as e:
        usageErrorExit(u'{0} {1}: {2}'.format(OB_RE_PATTERN, PHRASE_ERROR, e))
  missingArgumentExit(OB_RE_PATTERN)

SITENAME_PATTERN = re.compile(r'^[a-z0-9\-_]+$')
SITENAME_FORMAT_REQUIRED = u'[a-z,0-9,-_]+'

def validateSplitSiteName(fullSite):
  siteParts = fullSite.lower().split(u'/', 1)
  if (len(siteParts) == 1) or (len(siteParts[1]) == 0):
    domain = GC_Values[GC_DOMAIN]
    site = siteParts[0]
  elif len(siteParts[0]) == 0:
    domain = GC_Values[GC_DOMAIN]
    site = siteParts[1]
  else:
    domain = siteParts[0]
    site = siteParts[1]
  if SITENAME_PATTERN.match(site):
    return (domain, site, u'{0}/{1}'.format(domain, site))
  return (domain, site, None)

def getSiteName():
  if CLArgs.ArgumentsRemaining():
    domain, site, domainSite = validateSplitSiteName(CLArgs.Current())
    if domainSite:
      CLArgs.Advance()
      return (domain, site, domainSite)
    invalidArgumentExit(SITENAME_FORMAT_REQUIRED)
  missingArgumentExit(SITENAME_FORMAT_REQUIRED)

def getString(item, checkBlank=False, optional=False, minLen=1, maxLen=None):
  if CLArgs.ArgumentsRemaining():
    argstr = CLArgs.Current()
    if argstr:
      if checkBlank:
        if argstr.isspace():
          blankArgumentExit(item)
      if (len(argstr) >= minLen) and ((maxLen is None) or (len(argstr) <= maxLen)):
        CLArgs.Advance()
        return argstr
      invalidArgumentExit(u'{0} for {1}'.format(integerLimits(minLen, maxLen, PHRASE_STRING_LENGTH), item))
    if optional or (minLen == 0):
      CLArgs.Advance()
      return u''
    emptyArgumentExit(item)
  elif optional:
    return u''
  missingArgumentExit(item)

def getStringReturnInList(item):
  argstr = getString(item, minLen=0)
  if argstr:
    return [argstr]
  return []

YYYYMMDD_FORMAT = u'%Y-%m-%d'
YYYYMMDD_FORMAT_REQUIRED = u'yyyy-mm-dd'

def getYYYYMMDD(minLen=1, returnTimeStamp=False):
  if CLArgs.ArgumentsRemaining():
    argstr = CLArgs.Current().strip()
    if argstr:
      try:
        timeStamp = time.mktime(datetime.datetime.strptime(argstr, YYYYMMDD_FORMAT).timetuple())*1000
        CLArgs.Advance()
        if not returnTimeStamp:
          return argstr
        return timeStamp
      except ValueError:
        invalidArgumentExit(YYYYMMDD_FORMAT_REQUIRED)
    elif minLen == 0:
      CLArgs.Advance()
      return u''
  missingArgumentExit(YYYYMMDD_FORMAT_REQUIRED)

YYYYMMDD_HHMM_FORMAT = u'%Y-%m-%d %H:%M'
YYYYMMDD_HHMM_FORMAT_REQUIRED = u'yyyy-mm-dd hh:mm'

def getYYYYMMDD_HHMM():
  if CLArgs.ArgumentsRemaining():
    argstr = CLArgs.Current().strip().upper().replace(u'T', u' ')
    if argstr:
      try:
        datetime.datetime.strptime(argstr, YYYYMMDD_HHMM_FORMAT)
        CLArgs.Advance()
        return argstr
      except ValueError:
        invalidArgumentExit(YYYYMMDD_HHMM_FORMAT_REQUIRED)
  missingArgumentExit(YYYYMMDD_HHMM_FORMAT_REQUIRED)

YYYYMMDDTHHMMSS_FORMAT_REQUIRED = u'yyyy-mm-ddThh:mm:ss[.fff](Z|(+|-(hh:mm)))'
TIMEZONE_FORMAT_REQUIRED = u'Z|(+|-(hh:mm))'

def getFullTime(returnDateTime=False):
  if CLArgs.ArgumentsRemaining():
    argstr = CLArgs.Current().strip().upper()
    if argstr:
      try:
        fullDateTime, tz = iso8601.parse_date(argstr)
        CLArgs.Advance()
        if not returnDateTime:
          return argstr.replace(u' ', u'T')
        return (fullDateTime, tz, argstr.replace(u' ', u'T'))
      except iso8601.ParseError:
        pass
      invalidArgumentExit(YYYYMMDDTHHMMSS_FORMAT_REQUIRED)
  missingArgumentExit(YYYYMMDDTHHMMSS_FORMAT_REQUIRED)

EVENTID_PATTERN = re.compile(r'^[a-v0-9]{5,1024}$')
EVENTID_FORMAT_REQUIRED = u'[a-v0-9]{5,1024}'

def getEventID():
  if CLArgs.ArgumentsRemaining():
    tg = EVENTID_PATTERN.match(CLArgs.Current().strip())
    if tg:
      CLArgs.Advance()
      return tg.group(0)
    invalidArgumentExit(EVENTID_FORMAT_REQUIRED)
  missingArgumentExit(EVENTID_FORMAT_REQUIRED)

EVENT_TIME_FORMAT_REQUIRED = u'allday yyyy-mm-dd | '+YYYYMMDDTHHMMSS_FORMAT_REQUIRED

def getEventTime():
  if CLArgs.ArgumentsRemaining():
    if CLArgs.Current().strip().lower() == u'allday':
      CLArgs.Advance()
      return {u'date': getYYYYMMDD()}
    return {u'dateTime': getFullTime()}
  missingArgumentExit(EVENT_TIME_FORMAT_REQUIRED)

AGE_TIME_PATTERN = re.compile(r'^(\d+)([mhd]?)$')
AGE_TIME_FORMAT_REQUIRED = u'<Number>[m|h|d]'

def getAgeTime():
  if CLArgs.ArgumentsRemaining():
    tg = AGE_TIME_PATTERN.match(CLArgs.Current().strip().lower())
    if tg:
      tgg = tg.groups(u'0')
      age = int(tgg[0])
      age_unit = tgg[1]
      now = int(time.time())
      if age_unit == u'm':
        age = now-(age*SECONDS_PER_MINUTE)
      elif age_unit == u'h':
        age = now-(age*SECONDS_PER_HOUR)
      else: # age_unit == u'd':
        age = now-(age*SECONDS_PER_DAY)
      CLArgs.Advance()
      return age*1000
    invalidArgumentExit(AGE_TIME_FORMAT_REQUIRED)
  missingArgumentExit(AGE_TIME_FORMAT_REQUIRED)

CALENDAR_REMINDER_METHODS = [u'email', u'sms', u'popup',]

def getCalendarReminder(allowClearNone=False):
  methods = CALENDAR_REMINDER_METHODS
  if allowClearNone:
    methods += CLEAR_NONE_ARGUMENT
  if CLArgs.ArgumentsRemaining():
    method = CLArgs.Current().strip()
    if not method.isdigit():
      method = getChoice(methods)
      minutes = getInteger(minVal=0, maxVal=40320)
    else:
      minutes = getInteger(minVal=0, maxVal=40320)
      method = getChoice(methods)
    return {u'method': method, u'minutes': minutes}
  missingChoiceExit(methods)

def getCharSet():
  if checkArgumentPresent([u'charset',]):
    return getString(OB_CHAR_SET)
  return GC_Values[GC_CHARSET]

def getDelimiter(checkForArgument=False):
  if checkForArgument and not checkArgumentPresent([u'delimiter',]):
    return None
  if CLArgs.ArgumentsRemaining():
    argstr = CLArgs.Current().decode(u'string_escape')
    if argstr:
      if len(argstr) == 1:
        CLArgs.Advance()
        return argstr
      invalidArgumentExit(u'{0} for {1}'.format(integerLimits(1, 1, PHRASE_STRING_LENGTH), OB_DELIMITER))
    emptyArgumentExit(OB_DELIMITER)
  missingArgumentExit(OB_DELIMITER)

def getMatchFields(fieldNames):
  matchFields = {}
  while checkArgumentPresent([u'matchfield',]):
    matchField = getString(OB_FIELD_NAME).strip(u'~')
    if (not matchField) or (matchField not in fieldNames):
      csvFieldErrorExit(matchField, fieldNames, backupArg=True)
    matchFields[matchField] = getREPattern()
  return matchFields

def checkMatchFields(row, matchFields):
  for matchField, matchPattern in matchFields.items():
    if (matchField not in row) or not matchPattern.search(row[matchField]):
      return False
  return True

def checkSubkeyField():
  if not GM_Globals[GM_CSV_SUBKEY_FIELD]:
    CLArgs.Backup()
    usageErrorExit(MESSAGE_NO_CSV_FILE_SUBKEYS_SAVED)
  chkSubkeyField = getString(OB_FIELD_NAME, checkBlank=True)
  if chkSubkeyField != GM_Globals[GM_CSV_SUBKEY_FIELD]:
    CLArgs.Backup()
    usageErrorExit(MESSAGE_SUBKEY_FIELD_MISMATCH.format(chkSubkeyField, GM_Globals[GM_CSV_SUBKEY_FIELD]))

def checkDataField():
  if not GM_Globals[GM_CSV_DATA_FIELD]:
    CLArgs.Backup()
    usageErrorExit(MESSAGE_NO_CSV_FILE_DATA_SAVED)
  chkDataField = getString(OB_FIELD_NAME, checkBlank=True)
  if chkDataField != GM_Globals[GM_CSV_DATA_FIELD]:
    CLArgs.Backup()
    usageErrorExit(MESSAGE_DATA_FIELD_MISMATCH.format(chkDataField, GM_Globals[GM_CSV_DATA_FIELD]))

MAX_MESSAGE_BYTES_PATTERN = re.compile(r'^(\d+)([mkb]?)$')
MAX_MESSAGE_BYTES_FORMAT_REQUIRED = u'<Number>[m|k|b]'

def getMaxMessageBytes():
  if CLArgs.ArgumentsRemaining():
    tg = MAX_MESSAGE_BYTES_PATTERN.match(CLArgs.Current().strip().lower())
    if tg:
      tgg = tg.groups(u'0')
      mmb = int(tgg[0])
      mmb_unit = tgg[1]
      if mmb_unit == u'm':
        mmb *= ONE_MEGA_BYTES
      elif mmb_unit == u'k':
        mmb *= ONE_KILO_BYTES
      CLArgs.Advance()
      return mmb
    invalidArgumentExit(MAX_MESSAGE_BYTES_FORMAT_REQUIRED)
  missingArgumentExit(MAX_MESSAGE_BYTES_FORMAT_REQUIRED)

# Get domain from email address
def getEmailAddressDomain(emailAddress):
  atLoc = emailAddress.find(u'@')
  if atLoc == -1:
    return GC_Values[GC_DOMAIN].lower()
  return emailAddress[atLoc+1:].lower()

# Get user name from email address
def getEmailAddressUsername(emailAddress):
  atLoc = emailAddress.find(u'@')
  if atLoc == -1:
    return emailAddress.lower()
  return emailAddress[:atLoc].lower()

# Split email address unto user and domain
def splitEmailAddress(emailAddress):
  atLoc = emailAddress.find(u'@')
  if atLoc == -1:
    return (emailAddress.lower(), GC_Values[GC_DOMAIN].lower())
  return (emailAddress[:atLoc].lower(), emailAddress[atLoc+1:].lower())

def formatFileSize(fileSize):
  if fileSize == 0:
    return u'0kb'
  if fileSize < ONE_KILO_BYTES:
    return u'1kb'
  if fileSize < ONE_MEGA_BYTES:
    return u'{0}kb'.format(fileSize / ONE_KILO_BYTES)
  if fileSize < ONE_GIGA_BYTES:
    return u'{0}mb'.format(fileSize / ONE_MEGA_BYTES)
  return u'{0}gb'.format(fileSize / ONE_GIGA_BYTES)

def formatLocalTime(dateTimeStr):
  if dateTimeStr == NEVER_TIME:
    return NEVER
  if not GC_Values[GC_TIMEZONE] or not dateTimeStr.endswith(u'Z'):
    return dateTimeStr
  try:
    timestamp, _ = iso8601.parse_date(dateTimeStr)
    return timestamp.astimezone(GC_Values[GC_TIMEZONE]).isoformat()
  except iso8601.ParseError:
    return dateTimeStr

def formatLocalTimestamp(timestamp):
  return datetime.datetime.fromtimestamp(int(timestamp)/1000, GC_Values[GC_TIMEZONE]).isoformat()

def formatLocalDatestamp(timestamp):
  return datetime.datetime.fromtimestamp(int(timestamp)/1000, GC_Values[GC_TIMEZONE]).strftime(u'%Y-%m-%d')

def formatMaxMessageBytes(maxMessageBytes):
  if maxMessageBytes < ONE_KILO_BYTES:
    return maxMessageBytes
  if maxMessageBytes < ONE_MEGA_BYTES:
    return u'{0}K'.format(maxMessageBytes / ONE_KILO_BYTES)
  return u'{0}M'.format(maxMessageBytes / ONE_MEGA_BYTES)

def formatMilliSeconds(millis):
  seconds, millis = divmod(millis, 1000)
  minutes, seconds = divmod(seconds, 60)
  hours, minutes = divmod(minutes, 60)
  return u'%02d:%02d:%02d' % (hours, minutes, seconds)

def currentCount(i, count):
  return u' ({0}/{1})'.format(i, count) if (count > GC_Values[GC_SHOW_COUNTS_MIN]) else u''

def currentCountNL(i, count):
  return u' ({0}/{1})\n'.format(i, count) if (count > GC_Values[GC_SHOW_COUNTS_MIN]) else u'\n'

def getPhraseDNEorSNA(email):
  return [PHRASE_SERVICE_NOT_APPLICABLE, PHRASE_DOES_NOT_EXIST][getEmailAddressDomain(email) == GC_Values[GC_DOMAIN]]

def formatHTTPError(http_status, reason, message):
  return u'{0}: {1} - {2}'.format(http_status, reason, message)

def getHTTPError(responses, http_status, reason, message):
  if reason in responses:
    return responses[reason]
  return formatHTTPError(http_status, reason, message)

# Warnings
def printWarningMessage(sysRC, errMessage):
  setSysExitRC(sysRC)
  writeStderr(formatKeyValueList(Indent.Spaces(), [WARNING, errMessage], u'\n'))

def badRequestWarning(entityType, itemType, itemValue):
  printWarningMessage(BAD_REQUEST_RC, u'{0} 0 {1}: {2} {3} - {4}'.format(PHRASE_GOT, Entity.Plural(entityType),
                                                                         PHRASE_INVALID, Entity.Singular(itemType),
                                                                         itemValue))

def invalidQuery(query):
  return u'{0} ({1}) {2}'.format(Entity.Singular(Entity.QUERY), query, PHRASE_INVALID)

def entityTypeName(entityType, entityName):
  return u'{0}: {1}'.format(Entity.Singular(entityType), entityName)

def entityTypeNameMessage(entityType, entityName, message):
  return u'{0}: {1} {2}'.format(Entity.Singular(entityType), entityName, message)

def entityServiceNotApplicableWarning(entityType, entityName, i=0, count=0):
  setSysExitRC(SERVICE_NOT_APPLICABLE_RC)
  writeStderr(formatKeyValueList(Indent.Spaces(),
                                 [Entity.Singular(entityType), entityName, PHRASE_SERVICE_NOT_APPLICABLE],
                                 currentCountNL(i, count)))

def entityDoesNotExistWarning(entityType, entityName, i=0, count=0):
  setSysExitRC(ENTITY_DOES_NOT_EXIST_RC)
  writeStderr(formatKeyValueList(Indent.Spaces(),
                                 [Entity.Singular(entityType), entityName, PHRASE_DOES_NOT_EXIST],
                                 currentCountNL(i, count)))

def entityUnknownWarning(entityType, entityName, i=0, count=0):
  domain = getEmailAddressDomain(entityName)
  if (domain == GC_Values[GC_DOMAIN]) or (domain.endswith(u'google.com')):
    entityDoesNotExistWarning(entityType, entityName, i, count)
  else:
    entityServiceNotApplicableWarning(entityType, entityName, i, count)

def entityOrEntityUnknownWarning(entity1Type, entity1Name, entity2Type, entity2Name, i=0, count=0):
  setSysExitRC(ENTITY_DOES_NOT_EXIST_RC)
  writeStderr(formatKeyValueList(Indent.Spaces(),
                                 [u'{0} {1}'.format(PHRASE_EITHER, Entity.Singular(entity1Type)), entity1Name, getPhraseDNEorSNA(entity1Name), None,
                                  u'{0} {1}'.format(PHRASE_OR, Entity.Singular(entity2Type)), entity2Name, getPhraseDNEorSNA(entity2Name)],
                                 currentCountNL(i, count)))

def entityDuplicateWarning(entityType, entityName, i=0, count=0):
  setSysExitRC(ENTITY_DUPLICATE_RC)
  writeStderr(formatKeyValueList(Indent.Spaces(),
                                 [Entity.Singular(entityType), entityName, Action.Failed(), PHRASE_DUPLICATE],
                                 currentCountNL(i, count)))

def entityDoesNotHaveItemWarning(entityValueList, i=0, count=0):
  setSysExitRC(ENTITY_DOES_NOT_EXIST_RC)
  writeStderr(formatKeyValueList(Indent.Spaces(),
                                 formatEntityValueList(entityValueList)+[PHRASE_DOES_NOT_EXIST],
                                 currentCountNL(i, count)))

def entityActionFailedWarning(entityValueList, errMessage, i=0, count=0):
  setSysExitRC(AC_FAILED_RC)
  writeStderr(formatKeyValueList(Indent.Spaces(),
                                 formatEntityValueList(entityValueList)+[Action.Failed(), errMessage],
                                 currentCountNL(i, count)))

def entityModifierNewValueActionFailedWarning(entityValueList, modifier, newValue, errMessage, i=0, count=0):
  setSysExitRC(AC_FAILED_RC)
  writeStderr(formatKeyValueList(Indent.Spaces(),
                                 formatEntityValueList(entityValueList)+[u'{0} {1}'.format(Action.ToPerform(), modifier), newValue, Action.Failed(), errMessage],
                                 currentCountNL(i, count)))

def entityActionNotPerformedWarning(entityValueList, errMessage, i=0, count=0):
  setSysExitRC(AC_NOT_PERFORMED_RC)
  writeStderr(formatKeyValueList(Indent.Spaces(),
                                 formatEntityValueList(entityValueList)+[Action.NotPerformed(), errMessage],
                                 currentCountNL(i, count)))

def entityNumEntitiesActionNotPerformedWarning(entityType, entityName, itemType, itemCount, errMessage, i=0, count=0):
  setSysExitRC(AC_NOT_PERFORMED_RC)
  writeStderr(formatKeyValueList(Indent.Spaces(),
                                 [Entity.Singular(entityType), entityName,
                                  Entity.Choose(itemType, itemCount), itemCount,
                                  Action.NotPerformed(), errMessage],
                                 currentCountNL(i, count)))

def entityBadRequestWarning(entityValueList, errMessage, i=0, count=0):
  setSysExitRC(BAD_REQUEST_RC)
  writeStderr(formatKeyValueList(Indent.Spaces(),
                                 formatEntityValueList(entityValueList)+[ERROR, errMessage],
                                 currentCountNL(i, count)))

# Getting ... utilities
def mayTakeTime(entityType):
  if entityType:
    return u', {0} {1}...'.format(PHRASE_MAY_TAKE_SOME_TIME_ON_A_LARGE, Entity.Singular(entityType))
  return u''

def queryQualifier(query):
  if query:
    return u' {0} ({1})'.format(PHRASE_THAT_MATCH_QUERY, query)
  return u''

def printGettingAccountEntitiesInfo(entityType, qualifier=u''):
  if GC_Values[GC_SHOW_GETTINGS]:
    Entity.SetGetting(entityType)
    writeStderr(u'{0} {1}{2}{3}\n'.format(PHRASE_GETTING_ALL, Entity.PluralGetting(), qualifier, mayTakeTime(Entity.ACCOUNT)))

def printGettingAccountEntitiesDoneInfo(count, qualifier=u''):
  if GC_Values[GC_SHOW_GETTINGS]:
    writeStderr(u'{0} {1} {2}{3}\n'.format(PHRASE_GOT, count, Entity.ChooseGetting(count), qualifier))

def printGettingEntityItemsInfo(entityType, entityItem):
  if GC_Values[GC_SHOW_GETTINGS]:
    Entity.SetGetting(entityItem)
    writeStderr(u'{0} {1}{2}\n'.format(PHRASE_GETTING_ALL, Entity.PluralGetting(), mayTakeTime(entityType)))

def printGettingEntityItemsDoneInfo(count, qualifier=u''):
  if GC_Values[GC_SHOW_GETTINGS]:
    writeStderr(u'{0} {1} {2}{3}\n'.format(PHRASE_GOT, count, Entity.ChooseGetting(count), qualifier))

def printGettingEntityItemForWhom(entityItem, forWhom, i=0, count=0):
  if GC_Values[GC_SHOW_GETTINGS]:
    Entity.SetGetting(entityItem)
    Entity.SetGettingForWhom(forWhom)
    writeStderr(u'{0} {1} {2} {3}{4}'.format(PHRASE_GETTING, Entity.PluralGetting(), PHRASE_FOR, forWhom, currentCountNL(i, count)))

def printGettingAllEntityItemsForWhom(entityItem, forWhom, i=0, count=0, qualifier=u'', entityType=None):
  if GC_Values[GC_SHOW_GETTINGS]:
    Entity.SetGetting(entityItem)
    Entity.SetGettingForWhom(forWhom)
    writeStderr(u'{0} {1}{2} {3} {4}{5}{6}'.format(PHRASE_GETTING_ALL, Entity.PluralGetting(), qualifier, PHRASE_FOR, forWhom, mayTakeTime(entityType), currentCountNL(i, count)))

def printGettingEntityItemsForWhomDoneInfo(count, qualifier=u''):
  if GC_Values[GC_SHOW_GETTINGS]:
    writeStderr(u'{0} {1} {2}{3} {4} {5}...\n'.format(PHRASE_GOT, count, Entity.ChooseGetting(count), qualifier, PHRASE_FOR, Entity.GettingForWhom()))

def printGettingEntityItem(entityType, entityItem, i=0, count=0):
  if GC_Values[GC_SHOW_GETTINGS]:
    writeStderr(u'{0} {1} {2}{3}'.format(PHRASE_GETTING, Entity.Singular(entityType), entityItem, currentCountNL(i, count)))

FIRST_ITEM_MARKER = u'%%first_item%%'
LAST_ITEM_MARKER = u'%%last_item%%'
NUM_ITEMS_MARKER = u'%%num_items%%'
TOTAL_ITEMS_MARKER = u'%%total_items%%'

def getPageMessage(showTotal=True, showFirstLastItems=False, noNL=False):
  if not GC_Values[GC_SHOW_GETTINGS]:
    return None
  Entity.SetGettingShowTotal(showTotal)
  pageMessage = u'{0} {1} {{0}}'.format(PHRASE_GOT, [NUM_ITEMS_MARKER, TOTAL_ITEMS_MARKER][showTotal])
  if showFirstLastItems:
    pageMessage += u': {0} - {1}'.format(FIRST_ITEM_MARKER, LAST_ITEM_MARKER)
  else:
    pageMessage += u'...'
  if not noNL:
    pageMessage += u'\n'
  return pageMessage

def getPageMessageForWhom(forWhom=None, showTotal=True, showFirstLastItems=False, noNL=False):
  if not GC_Values[GC_SHOW_GETTINGS]:
    return None
  Entity.SetGettingShowTotal(showTotal)
  if forWhom:
    Entity.SetGettingForWhom(forWhom)
  pageMessage = u'{0} {1} {{0}} {2} {3}'.format(PHRASE_GOT, [NUM_ITEMS_MARKER, TOTAL_ITEMS_MARKER][showTotal], PHRASE_FOR, Entity.GettingForWhom())
  if showFirstLastItems:
    pageMessage += u': {0} - {1}'.format(FIRST_ITEM_MARKER, LAST_ITEM_MARKER)
  else:
    pageMessage += u'...'
  if not noNL:
    pageMessage += u'\n'
  return pageMessage

def printLine(message):
  writeStdout(convertUTF8(message+u'\n'))

def printBlankLine():
  writeStdout(u'\n')

def printKeyValueList(kvList):
  writeStdout(formatKeyValueList(Indent.Spaces(), kvList, u'\n'))

def printKeyValueListWithCount(kvList, i, count):
  writeStdout(formatKeyValueList(Indent.Spaces(), kvList, currentCountNL(i, count)))

def printKeyValueDict(kvDict):
  for key, value in kvDict.iteritems():
    writeStdout(formatKeyValueList(Indent.Spaces(), [key, value], u'\n'))

def printJSONKey(key):
  writeStdout(formatKeyValueList(Indent.Spaces(), [key, None], u''))

def printJSONValue(value):
  writeStdout(formatKeyValueList(u' ', [value], u'\n'))

def printEntity(entityValueList, i=0, count=0):
  writeStdout(formatKeyValueList(Indent.Spaces(),
                                 formatEntityValueList(entityValueList),
                                 currentCountNL(i, count)))

def printEntitiesCount(entityType, entityList):
  writeStdout(formatKeyValueList(Indent.Spaces(),
                                 [Entity.Plural(entityType), None if entityList is None else u'({0})'.format(len(entityList))],
                                 u'\n'))

def printEntityKVList(entityValueList, infoKVList, i=0, count=0):
  writeStdout(formatKeyValueList(Indent.Spaces(),
                                 formatEntityValueList(entityValueList)+infoKVList,
                                 currentCountNL(i, count)))

def performActionNumItems(itemCount, itemType, i=0, count=0):
  writeStdout(formatKeyValueList(Indent.Spaces(),
                                 [u'{0} {1} {2}'.format(Action.ToPerform(), itemCount, Entity.Choose(itemType, itemCount))],
                                 currentCountNL(i, count)))

def entityPerformActionNumItems(entityValueList, itemCount, itemType, i=0, count=0):
  writeStdout(formatKeyValueList(Indent.Spaces(),
                                 formatEntityValueList(entityValueList)+[u'{0} {1} {2}'.format(Action.ToPerform(), itemCount, Entity.Choose(itemType, itemCount))],
                                 currentCountNL(i, count)))

def entityPerformActionModifierNumItems(entityValueList, modifier, itemCount, itemType, i=0, count=0):
  writeStdout(formatKeyValueList(Indent.Spaces(),
                                 formatEntityValueList(entityValueList)+[u'{0} {1} {2} {3}'.format(Action.ToPerform(), modifier, itemCount, Entity.Choose(itemType, itemCount))],
                                 currentCountNL(i, count)))

def entityPerformActionNumItemsModifier(entityValueList, itemCount, itemType, modifier, i=0, count=0):
  writeStdout(formatKeyValueList(Indent.Spaces(),
                                 formatEntityValueList(entityValueList)+[u'{0} {1} {2} {3}'.format(Action.ToPerform(), itemCount, Entity.Choose(itemType, itemCount), modifier)],
                                 currentCountNL(i, count)))

def entityPerformActionSubItemModifierNumItems(entityValueList, subitemType, modifier, itemCount, itemType, i=0, count=0):
  writeStdout(formatKeyValueList(Indent.Spaces(),
                                 formatEntityValueList(entityValueList)+[u'{0} {1} {2} {3} {4}'.format(Action.ToPerform(), Entity.Plural(subitemType), modifier, itemCount, Entity.Choose(itemType, itemCount))],
                                 currentCountNL(i, count)))

def entityPerformActionSubItemModifierNumItemsModifierNewValue(entityValueList, subitemType, modifier1, itemCount, itemType, modifier2, newValue, i=0, count=0):
  writeStdout(formatKeyValueList(Indent.Spaces(),
                                 formatEntityValueList(entityValueList)+[u'{0} {1} {2} {3} {4} {5}'.format(Action.ToPerform(), Entity.Plural(subitemType), modifier1, itemCount, Entity.Choose(itemType, itemCount), modifier2), newValue],
                                 currentCountNL(i, count)))

def entityPerformActionModifierNumItemsModifier(entityValueList, modifier1, itemCount, itemType, modifier2, i=0, count=0):
  writeStdout(formatKeyValueList(Indent.Spaces(),
                                 formatEntityValueList(entityValueList)+[u'{0} {1} {2} {3} {4}'.format(Action.ToPerform(), modifier1, itemCount, Entity.Choose(itemType, itemCount), modifier2)],
                                 currentCountNL(i, count)))

def entityPerformActionModifierNewValue(entityValueList, modifier, newValue, i=0, count=0):
  writeStdout(formatKeyValueList(Indent.Spaces(),
                                 formatEntityValueList(entityValueList)+[u'{0} {1}'.format(Action.ToPerform(), modifier), newValue],
                                 currentCountNL(i, count)))

def entityPerformActionItemValue(entityValueList, itemType, itemValue, i=0, count=0):
  writeStdout(formatKeyValueList(Indent.Spaces(),
                                 formatEntityValueList(entityValueList)+[Action.ToPerform(), None, Entity.Singular(itemType), itemValue],
                                 currentCountNL(i, count)))

def entityPerformActionInfo(entityValueList, infoValue, i=0, count=0):
  writeStdout(formatKeyValueList(Indent.Spaces(),
                                 formatEntityValueList(entityValueList)+[Action.ToPerform(), infoValue],
                                 currentCountNL(i, count)))

def entityActionPerformed(entityValueList, i=0, count=0):
  writeStdout(formatKeyValueList(Indent.Spaces(),
                                 formatEntityValueList(entityValueList)+[Action.Performed()],
                                 currentCountNL(i, count)))

def entityActionPerformedMessage(entityValueList, message, i=0, count=0):
  writeStdout(formatKeyValueList(Indent.Spaces(),
                                 formatEntityValueList(entityValueList)+[Action.Performed(), message],
                                 currentCountNL(i, count)))

def entityModifierNewValueActionPerformed(entityValueList, modifier, newValue, i=0, count=0):
  writeStdout(formatKeyValueList(Indent.Spaces(),
                                 formatEntityValueList(entityValueList)+[u'{0} {1}'.format(Action.Performed(), modifier), newValue],
                                 currentCountNL(i, count)))

def entityModifierNewValueItemValueActionPerformed(entityValueList, modifier, newValue, infoType, infoValue, i=0, count=0):
  writeStdout(formatKeyValueList(Indent.Spaces(),
                                 formatEntityValueList(entityValueList)+[u'{0} {1}'.format(Action.Performed(), modifier), newValue, Entity.Singular(infoType), infoValue],
                                 currentCountNL(i, count)))

def entityModifierNewValueKeyValueActionPerformed(entityValueList, modifier, newValue, infoKey, infoValue, i=0, count=0):
  writeStdout(formatKeyValueList(Indent.Spaces(),
                                 formatEntityValueList(entityValueList)+[u'{0} {1}'.format(Action.Performed(), modifier), newValue, infoKey, infoValue],
                                 currentCountNL(i, count)))

#SAFE_FILENAME_CHARS = u'-_.() {0}{1}'.format(string.ascii_letters, string.digits)
#def cleanFilename(filename):
#  return u''.join(c for c in filename if c in SAFE_FILENAME_CHARS)
#
UNSAFE_FILENAME_CHARS = u'\\/:'

def cleanFilename(filename, cleanDiacriticals=False):
  if cleanDiacriticals:
    import unicodedata
    nkfd_form = unicodedata.normalize(u'NFKD', filename)
    filename = u''.join([c for c in nkfd_form if not unicodedata.combining(c)])
  for ch in UNSAFE_FILENAME_CHARS:
    filename = filename.replace(ch, u'_')
  return filename

# Open a file
def openFile(filename, mode=u'rU'):
  try:
    if filename != u'-':
      return open(os.path.expanduser(filename), mode)
    if mode.startswith(u'r'):
      return StringIO.StringIO(unicode(sys.stdin.read()))
    return sys.stdout
  except IOError as e:
    systemErrorExit(FILE_ERROR_RC, e)

# Close a file
def closeFile(f):
  try:
    f.close()
    return True
  except IOError as e:
    stderrErrorMsg(e)
    setSysExitRC(FILE_ERROR_RC)
    return False

# Read a file
def readFile(filename, mode=u'rU', continueOnError=False, displayError=True, encoding=None):
  try:
    if filename != u'-':
      if not encoding:
        with open(os.path.expanduser(filename), mode) as f:
          return f.read()
      with codecs.open(os.path.expanduser(filename), mode, encoding) as f:
        content = f.read()
# codecs does not strip UTF-8 BOM (ef:bb:bf) so we must
        if not content.startswith(codecs.BOM_UTF8):
          return content
        return content[3:]
    return unicode(sys.stdin.read())
  except IOError as e:
    if continueOnError:
      if displayError:
        stderrWarningMsg(e)
        setSysExitRC(FILE_ERROR_RC)
      return None
    systemErrorExit(FILE_ERROR_RC, e)
  except (LookupError, UnicodeDecodeError, UnicodeError) as e:
    CLArgs.Backup()
    usageErrorExit(e)

# Write a file
def writeFile(filename, data, mode=u'wb', continueOnError=False, displayError=True):
  try:
    with open(os.path.expanduser(filename), mode) as f:
      f.write(data)
    return True
  except IOError as e:
    if continueOnError:
      if displayError:
        stderrErrorMsg(e)
      setSysExitRC(FILE_ERROR_RC)
      return False
    systemErrorExit(FILE_ERROR_RC, e)

# Write a file, return error
def writeFileReturnError(filename, data, mode=u'wb'):
  try:
    with open(os.path.expanduser(filename), mode) as f:
      f.write(data)
    return (True, None)
  except IOError as e:
    return (False, e)

# Delete a file
def deleteFile(filename, continueOnError=False, displayError=True):
  if os.path.isfile(filename):
    try:
      os.remove(filename)
    except OSError as e:
      if continueOnError:
        if displayError:
          stderrWarningMsg(e)
        return
      systemErrorExit(FILE_ERROR_RC, e)
#
class UTF8Recoder(object):
  """
  Iterator that reads an encoded stream and reencodes the input to UTF-8
  """
  def __init__(self, f, encoding):
    self.reader = codecs.getreader(encoding)(f)

  def __iter__(self):
    return self

  def next(self):
    return self.reader.next().encode(u'utf-8')

class UnicodeDictReader(object):
  """
  A CSV reader which will iterate over lines in the CSV file "f",
  which is encoded in the given encoding.
  """

  def __init__(self, f, dialect=csv.excel, encoding=u'utf-8', fieldnames=None, **kwds):
    self.encoding = encoding
    try:
      self.reader = csv.reader(UTF8Recoder(f, encoding) if self.encoding != u'utf-8' else f, dialect=dialect, **kwds)
      if not fieldnames:
        self.fieldnames = self.reader.next()
        if len(self.fieldnames) > 0 and self.fieldnames[0].startswith(codecs.BOM_UTF8):
          self.fieldnames[0] = self.fieldnames[0].replace(codecs.BOM_UTF8, u'', 1)
      else:
        self.fieldnames = fieldnames
    except (csv.Error, StopIteration):
      self.fieldnames = []
    except LookupError as e:
      CLArgs.Backup()
      usageErrorExit(e)
    self.numfields = len(self.fieldnames)

  def __iter__(self):
    return self

  def next(self):
    row = self.reader.next()
    l = len(row)
    if l < self.numfields:
      row += ['']*(self.numfields-l) # Must be '', not u''
    return dict((self.fieldnames[x], unicode(row[x], u'utf-8')) for x in range(self.numfields))
#
class UnicodeWriter(object):
  """
  A CSV writer which will write rows to CSV file "f",
  which is encoded in the given encoding.
  """

  def __init__(self, f, dialect=csv.excel, encoding=u'utf-8', **kwds):
    # Redirect output to a queue
    import cStringIO
    self.queue = cStringIO.StringIO()
    self.writer = csv.writer(self.queue, dialect=dialect, **kwds)
    self.stream = f
    self.encoding = encoding
    self.encoder = codecs.getincrementalencoder(self.encoding)()

  def writerow(self, row):
    self.writer.writerow([unicode(s).encode(u'utf-8') for s in row])
    if self.encoding != u'utf-8':
      # Fetch UTF-8 output from the queue, reencode it into the target encoding and write to the target stream
      self.stream.write(self.encoder.encode(self.queue.getvalue().decode(u'utf-8')))
    else:
      # Fetch UTF-8 output from the queue and write to the target stream
      self.stream.write(self.queue.getvalue())
    # empty queue
    self.queue.truncate(0)

  def writerows(self, rows):
    for row in rows:
      self.writerow(row)
#
class UnicodeDictWriter(csv.DictWriter, object):
  def __init__(self, f, fieldnames, dialect=u'nixstdout', encoding=u'utf-8', *args, **kwds):
    super(UnicodeDictWriter, self).__init__(f, fieldnames, dialect=dialect, *args, **kwds)
    self.writer = UnicodeWriter(f, dialect, encoding, **kwds)

# Open a CSV file, get optional arguments [charset <String>] [columndelimiter <String>] [fields <FieldNameList>]
def openCSVFileReader(filename):
  encoding = getCharSet()
  if checkArgumentPresent(COLUMN_DELIMITER_ARGUMENT):
    delimiter = getDelimiter()
  else:
    delimiter = GC_Values[GC_CSV_INPUT_COLUMN_DELIMITER]
  if checkArgumentPresent([u'fields',]):
    fieldnames = shlexSplitList(getString(OB_FIELD_NAME_LIST))
  else:
    fieldnames = None
  f = openFile(filename, mode=u'rb')
  csvFile = UnicodeDictReader(f, encoding=encoding, fieldnames=fieldnames, delimiter=str(delimiter))
  return (f, csvFile)

# Set global variables from config file
# Check for GAM updates based on status of no_update_check in config file
# Return True if there are additional commands on the command line
def SetGlobalVariables():

  def _stringInQuotes(value):
    return (value.startswith('"') and value.endswith('"')) or (value.startswith("'") and value.endswith("'"))

  def _stripStringQuotes(value):
    if _stringInQuotes(value):
      return value[1:-1]
    return value

  def _quoteStringIfLeadingTrailingBlanks(value):
    if not value:
      return u"''"
    if _stringInQuotes(value):
      return value
    if (value[0] != u' ') and (value[-1] != u' '):
      return value
    return u"'{0}'".format(value)

  def _getDefault(itemName, itemEntry, oldGamPath):
    if GC_VAR_SIGFILE in itemEntry:
      GC_Defaults[itemName] = itemEntry[GC_VAR_SFFT][os.path.isfile(os.path.join(oldGamPath, itemEntry[GC_VAR_SIGFILE]))]
    else:
      value = os.environ.get(itemEntry[GC_VAR_ENVVAR], GC_Defaults[itemName])
      if itemEntry[GC_VAR_TYPE] == GC_TYPE_INTEGER:
        try:
          number = int(value)
          minVal, maxVal = itemEntry[GC_VAR_LIMITS]
          if (minVal is not None) and (number < minVal):
            number = minVal
          elif (maxVal is not None) and (number > maxVal):
            number = maxVal
        except ValueError:
          number = GC_Defaults[itemName]
        value = str(number)
      elif itemEntry[GC_VAR_TYPE] == GC_TYPE_STRING:
        value = _quoteStringIfLeadingTrailingBlanks(value)
      GC_Defaults[itemName] = value

  def _selectSection():
    value = getString(OB_SECTION_NAME, minLen=0)
    if (not value) or (value.upper() == ConfigParser.DEFAULTSECT):
      return ConfigParser.DEFAULTSECT
    if GM_Globals[GM_PARSER].has_section(value):
      return value
    CLArgs.Backup()
    usageErrorExit(formatKeyValueList(u'', [Entity.Singular(Entity.SECTION), value, PHRASE_NOT_FOUND], u''))

  def _checkMakeDir(itemName):
    if not os.path.isdir(GC_Defaults[itemName]):
      try:
        os.makedirs(GC_Defaults[itemName])
        printKeyValueList([Action.PerformedName(Action.CREATE), GC_Defaults[itemName]])
      except OSError as e:
        if not os.path.isdir(GC_Defaults[itemName]):
          systemErrorExit(FILE_ERROR_RC, e)

  def _copyCfgFile(srcFile, targetDir, oldGamPath):
    if (not srcFile) or os.path.isabs(srcFile):
      return
    dstFile = os.path.join(GC_Defaults[targetDir], srcFile)
    if os.path.isfile(dstFile):
      return
    srcFile = os.path.join(oldGamPath, srcFile)
    if not os.path.isfile(srcFile):
      return
    data = readFile(srcFile, continueOnError=True, displayError=False)
    if (data is not None) and writeFile(dstFile, data, continueOnError=True):
      printKeyValueList([Action.PerformedName(Action.COPY), srcFile, PHRASE_TO, dstFile])

  def _printValueError(sectionName, itemName, value, errMessage):
    printErrorMessage(CONFIG_ERROR_RC,
                      formatKeyValueList(u'',
                                         [Entity.Singular(Entity.CONFIG_FILE), GM_Globals[GM_GAM_CFG_FILE],
                                          Entity.Singular(Entity.SECTION), sectionName,
                                          Entity.Singular(Entity.ITEM), itemName,
                                          Entity.Singular(Entity.VALUE), value,
                                          errMessage],
                                         u''))

  def _getCfgBoolean(sectionName, itemName):
    value = GM_Globals[GM_PARSER].get(sectionName, itemName, raw=True).lower()
    if value in TRUE_VALUES:
      return True
    if value in FALSE_VALUES:
      return False
    _printValueError(sectionName, itemName, value, u'{0}: {1}'.format(PHRASE_EXPECTED, formatChoiceList(TRUE_FALSE)))
    status[u'errors'] = True
    return False

  def _getCfgInteger(sectionName, itemName):
    value = GM_Globals[GM_PARSER].get(sectionName, itemName, raw=True)
    minVal, maxVal = GC_VAR_INFO[itemName][GC_VAR_LIMITS]
    try:
      number = int(value)
      if ((minVal is None) or (number >= minVal)) and ((maxVal is None) or (number <= maxVal)):
        return number
    except ValueError:
      pass
    _printValueError(sectionName, itemName, value, u'{0}: {1}'.format(PHRASE_EXPECTED, integerLimits(minVal, maxVal)))
    status[u'errors'] = True
    return 0

  def _getCfgSection(sectionName, itemName):
    value = _stripStringQuotes(GM_Globals[GM_PARSER].get(sectionName, itemName, raw=True))
    if (not value) or (value.upper() == ConfigParser.DEFAULTSECT):
      return ConfigParser.DEFAULTSECT
    if GM_Globals[GM_PARSER].has_section(value):
      return value
    _printValueError(sectionName, itemName, value, PHRASE_NOT_FOUND)
    status[u'errors'] = True
    return ConfigParser.DEFAULTSECT

  def _getCfgString(sectionName, itemName):
    value = _stripStringQuotes(GM_Globals[GM_PARSER].get(sectionName, itemName, raw=True))
    minLen, maxLen = GC_VAR_INFO[itemName].get(GC_VAR_LIMITS, (None, None))
    if ((minLen is None) or (len(value) >= minLen)) and ((maxLen is None) or (len(value) <= maxLen)):
      return value
    _printValueError(sectionName, itemName, u'"{0}"'.format(value), u'{0}: {1}'.format(PHRASE_EXPECTED, integerLimits(minLen, maxLen, PHRASE_STRING_LENGTH)))
    status[u'errors'] = True
    return u''

  def _getCfgTimezone(sectionName, itemName):
    value = _stripStringQuotes(GM_Globals[GM_PARSER].get(sectionName, itemName, raw=True).lower())
    if value == u'utc':
      return None
    if value == u'local':
      return iso8601.Local
    try:
      return iso8601.parse_timezone_str(value)
    except iso8601.ParseError:
      pass
    _printValueError(sectionName, itemName, value, u'{0}: {1}'.format(PHRASE_EXPECTED, TIMEZONE_FORMAT_REQUIRED))
    status[u'errors'] = True
    return u''

  def _getCfgDirectory(sectionName, itemName):
    dirPath = os.path.expanduser(_stripStringQuotes(GM_Globals[GM_PARSER].get(sectionName, itemName, raw=True)))
    if (not dirPath) or (not os.path.isabs(dirPath)):
      if (sectionName != ConfigParser.DEFAULTSECT) and (GM_Globals[GM_PARSER].has_option(sectionName, itemName)):
        dirPath = os.path.join(os.path.expanduser(_stripStringQuotes(GM_Globals[GM_PARSER].get(ConfigParser.DEFAULTSECT, itemName, raw=True))), dirPath)
      if not os.path.isabs(dirPath):
        dirPath = os.path.join(GM_Globals[GM_GAM_CFG_PATH], dirPath)
    return dirPath

  def _getCfgFile(sectionName, itemName):
    value = os.path.expanduser(_stripStringQuotes(GM_Globals[GM_PARSER].get(sectionName, itemName, raw=True)))
    if value and not os.path.isabs(value):
      value = os.path.expanduser(os.path.join(_getCfgDirectory(sectionName, GC_CONFIG_DIR), value))
    return value

  def _readGamCfgFile(config, fileName):
    try:
      with open(fileName, u'rU') as f:
        config.readfp(f)
    except (ConfigParser.MissingSectionHeaderError, ConfigParser.ParsingError) as e:
      systemErrorExit(CONFIG_ERROR_RC, formatKeyValueList(u'',
                                                          [Entity.Singular(Entity.CONFIG_FILE), fileName,
                                                           PHRASE_INVALID, e.message],
                                                          u''))
    except IOError as e:
      systemErrorExit(FILE_ERROR_RC, e)

  def _writeGamCfgFile(config, fileName, action):
    try:
      with open(fileName, u'wb') as f:
        config.write(f)
      printKeyValueList([Entity.Singular(Entity.CONFIG_FILE), fileName, Action.PerformedName(action)])
    except IOError as e:
      stderrErrorMsg(e)

  def _verifyValues(sectionName):
    printKeyValueList([Entity.Singular(Entity.SECTION), sectionName]) # Do not use printEntity
    Indent.Increment()
    for itemName in sorted(GC_VAR_INFO):
      cfgValue = GM_Globals[GM_PARSER].get(sectionName, itemName, raw=True)
      if GC_VAR_INFO[itemName][GC_VAR_TYPE] not in [GC_TYPE_BOOLEAN, GC_TYPE_INTEGER]:
        cfgValue = _quoteStringIfLeadingTrailingBlanks(cfgValue)
      if GC_VAR_INFO[itemName][GC_VAR_TYPE] == GC_TYPE_FILE:
        expdValue = _getCfgFile(sectionName, itemName)
        if cfgValue != u"''" and cfgValue != expdValue:
          cfgValue = u'{0} ; {1}'.format(cfgValue, expdValue)
      elif GC_VAR_INFO[itemName][GC_VAR_TYPE] == GC_TYPE_DIRECTORY:
        expdValue = _getCfgDirectory(sectionName, itemName)
        if cfgValue != u"''" and cfgValue != expdValue:
          cfgValue = u'{0} ; {1}'.format(cfgValue, expdValue)
      elif (itemName == GC_SECTION) and (sectionName != ConfigParser.DEFAULTSECT):
        continue
      printLine(u'{0}{1} = {2}'.format(Indent.Spaces(), itemName, cfgValue))
    Indent.Decrement()

  def _chkCfgDirectories(sectionName):
    for itemName in GC_VAR_INFO:
      if GC_VAR_INFO[itemName][GC_VAR_TYPE] == GC_TYPE_DIRECTORY:
        dirPath = GC_Values[itemName]
        if not os.path.isdir(dirPath):
          writeStderr(formatKeyValueList(WARNING_PREFIX,
                                         [Entity.Singular(Entity.CONFIG_FILE), GM_Globals[GM_GAM_CFG_FILE],
                                          Entity.Singular(Entity.SECTION), sectionName,
                                          Entity.Singular(Entity.ITEM), itemName,
                                          Entity.Singular(Entity.VALUE), dirPath,
                                          PHRASE_INVALID_PATH],
                                         u'\n'))

  def _chkCfgFiles(sectionName):
    for itemName in GC_VAR_INFO:
      if GC_VAR_INFO[itemName][GC_VAR_TYPE] == GC_TYPE_FILE:
        fileName = GC_Values[itemName]
        if (not fileName) and (itemName == GC_EXTRA_ARGS):
          continue
        if not os.path.isfile(fileName):
          writeStderr(formatKeyValueList(WARNING_PREFIX,
                                         [Entity.Singular(Entity.CONFIG_FILE), GM_Globals[GM_GAM_CFG_FILE],
                                          Entity.Singular(Entity.SECTION), sectionName,
                                          Entity.Singular(Entity.ITEM), itemName,
                                          Entity.Singular(Entity.VALUE), fileName,
                                          PHRASE_NOT_FOUND],
                                         u'\n'))

  def _setCSVFile(filename, mode, encoding, writeHeader, multi):
    if filename != u'-':
      if filename.startswith(u'./') or filename.startswith(u'.\\'):
        filename = os.path.join(os.getcwd(), filename[2:])
      else:
        filename = os.path.expanduser(filename)
      if not os.path.isabs(filename):
        filename = os.path.join(GC_Values[GC_DRIVE_DIR], filename)
    GM_Globals[GM_CSVFILE][GM_REDIRECT_NAME] = filename
    GM_Globals[GM_CSVFILE][GM_REDIRECT_MODE] = mode
    GM_Globals[GM_CSVFILE][GM_REDIRECT_ENCODING] = encoding
    GM_Globals[GM_CSVFILE][GM_REDIRECT_COLUMN_DELIMITER] = GC_Values[GC_CSV_OUTPUT_COLUMN_DELIMITER]
    GM_Globals[GM_CSVFILE][GM_REDIRECT_WRITE_HEADER] = writeHeader
    GM_Globals[GM_CSVFILE][GM_REDIRECT_MULTIPROCESS] = multi
    GM_Globals[GM_CSVFILE][GM_REDIRECT_QUEUE] = None

  def _setSTDFile(stdtype, filename, mode, multi):
    if stdtype == GM_STDOUT:
      GM_Globals[GM_SAVED_STDOUT] = None
    if filename == u'null':
      GM_Globals[stdtype][GM_REDIRECT_FD] = open(os.devnull, mode)
    elif filename == u'-':
      GM_Globals[stdtype][GM_REDIRECT_FD] = [sys.stderr, sys.stdout][stdtype == GM_STDOUT]
    else:
      if filename.startswith(u'./') or filename.startswith(u'.\\'):
        filename = os.path.join(os.getcwd(), filename[2:])
      else:
        filename = os.path.expanduser(filename)
      if not os.path.isabs(filename):
        filename = os.path.join(GC_Values[GC_DRIVE_DIR], filename)
      if multi and mode == u'wb':
        deleteFile(filename)
        mode = u'ab'
      GM_Globals[stdtype][GM_REDIRECT_FD] = openFile(filename, mode)
    GM_Globals[stdtype][GM_REDIRECT_MULTI_FD] = GM_Globals[stdtype][GM_REDIRECT_FD] if not multi else StringIO.StringIO()
    if (stdtype == GM_STDOUT) and (GC_Values[GC_DEBUG_LEVEL] > 0):
      GM_Globals[GM_SAVED_STDOUT] = sys.stdout
      sys.stdout = GM_Globals[stdtype][GM_REDIRECT_MULTI_FD]
    GM_Globals[stdtype][GM_REDIRECT_NAME] = filename
    GM_Globals[stdtype][GM_REDIRECT_MODE] = mode
    GM_Globals[stdtype][GM_REDIRECT_MULTIPROCESS] = multi
    GM_Globals[stdtype][GM_REDIRECT_QUEUE] = [u'stderr', u'stdout'][stdtype == GM_STDOUT]

  if not GM_Globals[GM_PARSER]:
    homePath = os.path.expanduser(u'~')
    GM_Globals[GM_GAM_CFG_PATH] = os.environ.get(u'GAMCFGDIR', None)
    if GM_Globals[GM_GAM_CFG_PATH]:
      GM_Globals[GM_GAM_CFG_PATH] = os.path.expanduser(GM_Globals[GM_GAM_CFG_PATH])
    else:
      GM_Globals[GM_GAM_CFG_PATH] = os.path.join(homePath, u'.gam')
    GC_Defaults[GC_CONFIG_DIR] = GM_Globals[GM_GAM_CFG_PATH]
    GC_Defaults[GC_CACHE_DIR] = os.path.join(GM_Globals[GM_GAM_CFG_PATH], u'gamcache')
    GC_Defaults[GC_DRIVE_DIR] = os.path.join(homePath, u'Downloads')
    GM_Globals[GM_GAM_CFG_FILE] = os.path.join(GM_Globals[GM_GAM_CFG_PATH], FN_GAM_CFG)
    if not os.path.isfile(GM_Globals[GM_GAM_CFG_FILE]):
      for itemName, itemEntry in GC_VAR_INFO.items():
        if itemEntry[GC_VAR_TYPE] == GC_TYPE_DIRECTORY:
          _getDefault(itemName, itemEntry, None)
      oldGamPath = os.environ.get(u'OLDGAMPATH', GC_Defaults[GC_CONFIG_DIR])
      for itemName, itemEntry in GC_VAR_INFO.items():
        if itemEntry[GC_VAR_TYPE] != GC_TYPE_DIRECTORY:
          _getDefault(itemName, itemEntry, oldGamPath)
      GM_Globals[GM_PARSER] = ConfigParser.SafeConfigParser(defaults=collections.OrderedDict(sorted(GC_Defaults.items(), key=lambda t: t[0])))
      _checkMakeDir(GC_CONFIG_DIR)
      _checkMakeDir(GC_CACHE_DIR)
      _checkMakeDir(GC_DRIVE_DIR)
      for itemName in GC_VAR_INFO:
        if GC_VAR_INFO[itemName][GC_VAR_TYPE] == GC_TYPE_FILE:
          srcFile = os.path.expanduser(_stripStringQuotes(GM_Globals[GM_PARSER].get(ConfigParser.DEFAULTSECT, itemName, raw=True)))
          _copyCfgFile(srcFile, GC_CONFIG_DIR, oldGamPath)
      _writeGamCfgFile(GM_Globals[GM_PARSER], GM_Globals[GM_GAM_CFG_FILE], Action.INITIALIZE)
    else:
      GM_Globals[GM_PARSER] = ConfigParser.SafeConfigParser(defaults=collections.OrderedDict(sorted(GC_Defaults.items(), key=lambda t: t[0])))
      _readGamCfgFile(GM_Globals[GM_PARSER], GM_Globals[GM_GAM_CFG_FILE])
    GM_Globals[GM_LAST_UPDATE_CHECK_TXT] = os.path.join(_getCfgDirectory(ConfigParser.DEFAULTSECT, GC_CONFIG_DIR), FN_LAST_UPDATE_CHECK_TXT)
  status = {u'errors': False}
  sectionName = _getCfgSection(ConfigParser.DEFAULTSECT, GC_SECTION)
# select <SectionName> [save] [verify]
  if checkArgumentPresent([SELECT_CMD,]):
    sectionName = _selectSection()
    while CLArgs.ArgumentsRemaining():
      if checkArgumentPresent([u'save',]):
        GM_Globals[GM_PARSER].set(ConfigParser.DEFAULTSECT, GC_SECTION, sectionName)
        _writeGamCfgFile(GM_Globals[GM_PARSER], GM_Globals[GM_GAM_CFG_FILE], Action.SAVE)
      elif checkArgumentPresent([u'verify',]):
        _verifyValues(sectionName)
      else:
        break
# config (<VariableName> [=] <Value>)* [save] [verify]
  if checkArgumentPresent([CONFIG_CMD,]):
    while CLArgs.ArgumentsRemaining():
      if checkArgumentPresent([u'save',]):
        _writeGamCfgFile(GM_Globals[GM_PARSER], GM_Globals[GM_GAM_CFG_FILE], Action.SAVE)
      elif checkArgumentPresent([u'verify',]):
        _verifyValues(sectionName)
      else:
        itemName = getChoice(GC_VAR_INFO, defaultChoice=None)
        if itemName is None:
          break
        checkArgumentPresent([u'=',])
        if GC_VAR_INFO[itemName][GC_VAR_TYPE] == GC_TYPE_BOOLEAN:
          value = [FALSE, TRUE][getBoolean()]
        elif GC_VAR_INFO[itemName][GC_VAR_TYPE] == GC_TYPE_INTEGER:
          minVal, maxVal = GC_VAR_INFO[itemName][GC_VAR_LIMITS]
          value = str(getInteger(minVal=minVal, maxVal=maxVal))
        elif GC_VAR_INFO[itemName][GC_VAR_TYPE] == GC_TYPE_TIMEZONE:
          value = getString(OB_STRING, checkBlank=True)
        else:
          minLen, maxLen = GC_VAR_INFO[itemName].get(GC_VAR_LIMITS, (None, None))
          value = _quoteStringIfLeadingTrailingBlanks(getString(OB_STRING, minLen=minLen, maxLen=maxLen))
        GM_Globals[GM_PARSER].set(sectionName, itemName, value)
  prevExtraArgsTxt = GC_Values.get(GC_EXTRA_ARGS, None)
  prevOauth2serviceJson = GC_Values.get(GC_OAUTH2SERVICE_JSON, None)
# Assign global variables, directories first as other variables depend on them
  for itemName in GC_VAR_INFO:
    if GC_VAR_INFO[itemName][GC_VAR_TYPE] == GC_TYPE_DIRECTORY:
      GC_Values[itemName] = _getCfgDirectory(sectionName, itemName)
# Everything else
  for itemName in GC_VAR_INFO:
    varType = GC_VAR_INFO[itemName][GC_VAR_TYPE]
    if varType == GC_TYPE_BOOLEAN:
      GC_Values[itemName] = _getCfgBoolean(sectionName, itemName)
    elif varType == GC_TYPE_INTEGER:
      GC_Values[itemName] = _getCfgInteger(sectionName, itemName)
    elif varType == GC_TYPE_STRING:
      GC_Values[itemName] = _getCfgString(sectionName, itemName)
    elif varType == GC_TYPE_TIMEZONE:
      GC_Values[itemName] = _getCfgTimezone(sectionName, itemName)
    elif varType == GC_TYPE_FILE:
      GC_Values[itemName] = _getCfgFile(sectionName, itemName)
  if status[u'errors']:
    sys.exit(CONFIG_ERROR_RC)
  GC_Values[GC_DOMAIN] = GC_Values[GC_DOMAIN].lower()
# Create/set mode for oauth2.txt.lock
  if not GM_Globals[GM_OAUTH2_TXT_LOCK]:
    fileName = u'{0}.lock'.format(GC_Values[GC_OAUTH2_TXT])
    if not os.path.isfile(fileName):
      closeFile(openFile(fileName, mode=u'a'))
      os.chmod(fileName, 0666)
    GM_Globals[GM_OAUTH2_TXT_LOCK] = fileName
# Reset global variables if required
  httplib2.debuglevel = GC_Values[GC_DEBUG_LEVEL]
  if prevExtraArgsTxt != GC_Values[GC_EXTRA_ARGS]:
    GM_Globals[GM_EXTRA_ARGS_LIST] = []
    if GC_Values[GC_EXTRA_ARGS]:
      ea_config = ConfigParser.ConfigParser()
      ea_config.optionxform = str
      ea_config.read(GC_Values[GC_EXTRA_ARGS])
      GM_Globals[GM_EXTRA_ARGS_LIST].extend(ea_config.items(u'extra-args'))
  if prevOauth2serviceJson != GC_Values[GC_OAUTH2SERVICE_JSON]:
    GM_Globals[GM_OAUTH2SERVICE_JSON_DATA] = None
    GM_Globals[GM_OAUTH2_CLIENT_ID] = None
# redirect csv <FileName> [multiprocess] [append] [noheader] [charset <CharSet>] [columndelimiter <Character>]] [stdout <FileName> [append]] [stderr <FileName> [append]
# redirect stdout <FileName> [multiprocess] [append]
# redirect stdout null
# redirect stderr <FileName> [multiprocess] [append]
# redirect stderr stdout
# redirect stderr null
  while checkArgumentPresent([REDIRECT_CMD,]):
    myarg = getChoice([u'csv', u'stdout', u'stderr'])
    filename = re.sub(r'{{Section}}', sectionName, getString(OB_FILE_NAME, checkBlank=True))
    if myarg == u'csv':
      multi = True if checkArgumentPresent([u'multiprocess',]) else False
      mode = u'ab' if checkArgumentPresent([u'append',]) else u'wb'
      writeHeader = False if checkArgumentPresent([u'noheader',]) else True
      encoding = getCharSet()
      if checkArgumentPresent(COLUMN_DELIMITER_ARGUMENT):
        GC_Values[GC_CSV_OUTPUT_COLUMN_DELIMITER] = getDelimiter()
      _setCSVFile(filename, mode, encoding, writeHeader, multi)
    elif myarg == u'stdout':
      if filename.lower() == u'null':
        multi = True if checkArgumentPresent([u'multiprocess',]) else False
        _setSTDFile(GM_STDOUT, u'null', u'wb', multi)
      else:
        multi = True if checkArgumentPresent([u'multiprocess',]) else False
        mode = u'ab' if checkArgumentPresent([u'append',]) else u'wb'
        _setSTDFile(GM_STDOUT, filename, mode, multi)
        if GM_Globals[GM_CSVFILE].get(GM_REDIRECT_NAME) == u'-':
          GM_Globals[GM_CSVFILE] = {}
    else: # myarg == u'stderr'
      if filename.lower() == u'null':
        multi = True if checkArgumentPresent([u'multiprocess',]) else False
        _setSTDFile(GM_STDERR, u'null', u'wb', multi)
      elif filename.lower() != u'stdout':
        multi = True if checkArgumentPresent([u'multiprocess',]) else False
        mode = u'ab' if checkArgumentPresent([u'append',]) else u'wb'
        _setSTDFile(GM_STDERR, filename, mode, multi)
      else:
        multi = True if checkArgumentPresent([u'multiprocess',]) else False
        if  not GM_Globals[GM_STDOUT]:
          _setSTDFile(GM_STDOUT, u'-', u'wb', multi)
        GM_Globals[GM_STDERR] = GM_Globals[GM_STDOUT].copy()
        GM_Globals[GM_STDERR][GM_REDIRECT_NAME] = u'stdout'
  if not GM_Globals[GM_STDOUT]:
    _setSTDFile(GM_STDOUT, u'-', u'wb', False)
  if not GM_Globals[GM_STDERR]:
    _setSTDFile(GM_STDERR, u'-', u'wb', False)
  if not GM_Globals[GM_CSVFILE]:
    _setCSVFile(u'-', GM_Globals[GM_STDOUT].get(GM_REDIRECT_MODE, u'wb'), GC_Values[GC_CHARSET], True, False)
  if not GC_Values[GC_NO_UPDATE_CHECK]:
    doGAMCheckForUpdates()
# If no select/options commands were executed or some were and there are more arguments on the command line,
# warn if the json files are missing and return True
  if (CLArgs.Location() == 1) or (CLArgs.ArgumentsRemaining()):
    _chkCfgDirectories(sectionName)
    _chkCfgFiles(sectionName)
    if GC_Values[GC_NO_CACHE]:
      GM_Globals[GM_CACHE_DIR] = None
      GM_Globals[GM_CACHE_DISCOVERY_ONLY] = False
    else:
      GM_Globals[GM_CACHE_DIR] = GC_Values[GC_CACHE_DIR]
      GM_Globals[GM_CACHE_DISCOVERY_ONLY] = GC_Values[GC_CACHE_DISCOVERY_ONLY]
    return True
# We're done, nothing else to do
  return False

def doGAMCheckForUpdates(forceCheck=False):
  import calendar

  current_version = __version__
  now_time = calendar.timegm(time.gmtime())
  if forceCheck:
    check_url = GAM_ALL_RELEASES # includes pre-releases
  else:
    last_check_time_str = readFile(GM_Globals[GM_LAST_UPDATE_CHECK_TXT], continueOnError=True, displayError=False)
    last_check_time = int(last_check_time_str) if last_check_time_str and last_check_time_str.isdigit() else 0
    if last_check_time > now_time-604800:
      return
    check_url = GAM_LATEST_RELEASE # latest full release
  try:
    _, c = httplib2.Http(disable_ssl_certificate_validation=GC_Values[GC_NO_VERIFY_SSL]).request(check_url, u'GET', headers={u'Accept': u'application/vnd.github.v3.text+json'})
    try:
      release_data = json.loads(c)
    except ValueError:
      return
    if isinstance(release_data, list):
      release_data = release_data[0] # only care about latest release
    latest_version = release_data[u'tag_name']
    if latest_version[0].lower() == u'v':
      latest_version = latest_version[1:]
    if forceCheck or (latest_version > current_version):
      printKeyValueList([u'Version Check', None])
      Indent.Increment()
      printKeyValueList([u'Current', current_version])
      printKeyValueList([u' Latest', latest_version])
      Indent.Decrement()
    if latest_version <= current_version:
      writeFile(GM_Globals[GM_LAST_UPDATE_CHECK_TXT], str(now_time), continueOnError=True, displayError=forceCheck)
      return
    announcement = release_data.get(u'body_text', u'No details about this release')
    writeStderr(u'\nGAM %s release notes:\n\n' % latest_version)
    writeStderr(announcement)
    try:
      printLine(MESSAGE_HIT_CONTROL_C_TO_UPDATE)
      time.sleep(15)
    except KeyboardInterrupt:
      import webbrowser
      webbrowser.open(release_data[u'html_url'])
      printLine(MESSAGE_GAM_EXITING_FOR_UPDATE)
      sys.exit(0)
    writeFile(GM_Globals[GM_LAST_UPDATE_CHECK_TXT], str(now_time), continueOnError=True, displayError=forceCheck)
    return
  except (httplib2.HttpLib2Error, httplib2.ServerNotFoundError, httplib2.CertificateValidationUnsupported):
    return

def handleOAuthTokenError(e, soft_errors):
  if e.message in OAUTH2_TOKEN_ERRORS:
    if soft_errors:
      return None
    if not GM_Globals[GM_CURRENT_API_USER]:
      APIAccessDeniedExit()
    systemErrorExit(SERVICE_NOT_APPLICABLE_RC, MESSAGE_SERVICE_NOT_APPLICABLE.format(GM_Globals[GM_CURRENT_API_USER]))
  stderrErrorMsg(u'Authentication Token Error - {0}'.format(e))
  APIAccessDeniedExit()

def getCredentialsForScope(cred_family, storageOnly=False):
  try:
    storage = MultiprocessFileStorage(GC_Values[GC_OAUTH2_TXT], cred_family)
    if storageOnly:
      return storage
    return storage.get()
  except (KeyError, ValueError):
    return None
  except IOError as e:
    systemErrorExit(FILE_ERROR_RC, e)

def getClientCredentials(cred_family):
  credentials = getCredentialsForScope(cred_family)
  if not credentials or credentials.invalid:
    invalidOauth2TxtExit()
  credentials.user_agent = GAM_INFO
  return credentials

def getSvcAcctCredentials(scopes, act_as):
  try:
    if not GM_Globals[GM_OAUTH2SERVICE_JSON_DATA]:
      json_string = readFile(GC_Values[GC_OAUTH2SERVICE_JSON], continueOnError=True, displayError=True)
      if not json_string:
        invalidOauth2serviceJsonExit()
      GM_Globals[GM_OAUTH2SERVICE_JSON_DATA] = json.loads(json_string)
    credentials = oauth2client.service_account.ServiceAccountCredentials.from_json_keyfile_dict(GM_Globals[GM_OAUTH2SERVICE_JSON_DATA], scopes)
    credentials = credentials.create_delegated(act_as)
    credentials.user_agent = GAM_INFO
    serialization_data = credentials.serialization_data
    GM_Globals[GM_ADMIN] = serialization_data[u'client_email']
    GM_Globals[GM_OAUTH2_CLIENT_ID] = serialization_data[u'client_id']
    return credentials
  except (ValueError, IndexError, KeyError):
    invalidOauth2serviceJsonExit()

def getGDataOAuthToken(gdataObj, credentials=None):
  if not credentials:
    credentials = getClientCredentials(OAUTH2_FAM2_SCOPES)
  try:
    credentials.refresh(httplib2.Http(disable_ssl_certificate_validation=GC_Values[GC_NO_VERIFY_SSL]))
  except httplib2.ServerNotFoundError as e:
    systemErrorExit(NETWORK_ERROR_RC, e.message)
  except oauth2client.client.AccessTokenRefreshError as e:
    return handleOAuthTokenError(e, False)
  gdataObj.additional_headers[u'Authorization'] = u'Bearer {0}'.format(credentials.access_token)
  if not GC_Values[GC_DOMAIN]:
    GC_Values[GC_DOMAIN] = credentials.id_token.get(u'hd', u'UNKNOWN').lower()
  if not GC_Values[GC_CUSTOMER_ID]:
    GC_Values[GC_CUSTOMER_ID] = MY_CUSTOMER
  GM_Globals[GM_ADMIN] = credentials.id_token.get(u'email', u'UNKNOWN').lower()
  GM_Globals[GM_OAUTH2_CLIENT_ID] = credentials.client_id
  gdataObj.domain = GC_Values[GC_DOMAIN]
  gdataObj.source = GAM_INFO
  return True

def checkGDataError(e, service):
  # First check for errors that need special handling
  if e[0].get(u'reason', u'') in [u'Token invalid - Invalid token: Stateless token expired', u'Token invalid - Invalid token: Token not found']:
    keep_domain = service.domain
    getGDataOAuthToken(service)
    service.domain = keep_domain
    return (GDATA_TOKEN_EXPIRED, e[0][u'reason'])
  if e.error_code == 600:
    if e[0][u'body'].startswith(u'Quota exceeded for the current request'):
      return (GDATA_QUOTA_EXCEEDED, e[0][u'body'])
    if e[0][u'body'].startswith(u'Request rate higher than configured'):
      return (GDATA_QUOTA_EXCEEDED, e[0][u'body'])
    if e[0][u'reason'] == u'Bad Gateway':
      return (GDATA_BAD_GATEWAY, e[0][u'reason'])
    if e[0][u'reason'] == u'Service Unavailable':
      return (GDATA_SERVICE_UNAVAILABLE, e[0][u'reason'])
    if e[0][u'reason'] == u'Internal Server Error':
      return (GDATA_INTERNAL_SERVER_ERROR, e[0][u'reason'])
    if e[0][u'reason'] == u'Token invalid - Invalid token: Token disabled, revoked, or expired.':
      return (GDATA_TOKEN_INVALID, u'Token disabled, revoked, or expired. Please delete and re-create oauth.txt')
    if e[0][u'reason'] == u'Token invalid - AuthSub token has wrong scope':
      return (GDATA_INSUFFICIENT_PERMISSIONS, e[0][u'reason'])
    if e[0][u'reason'].startswith(u'Only administrators can request entries belonging to'):
      return (GDATA_INSUFFICIENT_PERMISSIONS, e[0][u'reason'])
    if e[0][u'reason'] == u'You are not authorized to access this API':
      return (GDATA_INSUFFICIENT_PERMISSIONS, e[0][u'reason'])
    if e[0][u'reason'] == u'Invalid domain.':
      return (GDATA_INVALID_DOMAIN, e[0][u'reason'])
    if e[0][u'reason'].startswith(u'You are not authorized to perform operations on the domain'):
      return (GDATA_INVALID_DOMAIN, e[0][u'reason'])
    if e[0][u'reason'] == u'Bad Request':
      if u'already exists' in e[0][u'body']:
        return (GDATA_ENTITY_EXISTS, PHRASE_DUPLICATE)
      return (GDATA_BAD_REQUEST, e[0][u'body'])
    if e[0][u'reason'] == u'Forbidden':
      return (GDATA_FORBIDDEN, e[0][u'body'])
    if e[0][u'reason'] == u'Not Found':
      return (GDATA_NOT_FOUND, PHRASE_DOES_NOT_EXIST)
    if e[0][u'reason'] == u'Not Implemented':
      return (GDATA_NOT_IMPLEMENTED, e[0][u'body'])
    if e[0][u'reason'] == u'Precondition Failed':
      return (GDATA_PRECONDITION_FAILED, e[0][u'reason'])
  elif e.error_code == 602:
    if e[0][u'reason'] == u'Bad Request':
      return (GDATA_BAD_REQUEST, e[0][u'body'])

  # We got a "normal" error, define the mapping below
  error_code_map = {
    1000: e[0][u'reason'],
    1001: e[0][u'reason'],
    1002: u'Unauthorized and forbidden',
    1100: u'User deleted recently',
    1200: u'Domain user limit exceeded',
    1201: u'Domain alias limit exceeded',
    1202: u'Domain suspended',
    1203: u'Domain feature unavailable',
    1300: u'Entity %s exists' % getattr(e, u'invalidInput', u'<unknown>'),
    1301: u'Entity %s Does Not Exist' % getattr(e, u'invalidInput', u'<unknown>'),
    1302: u'Entity Name Is Reserved',
    1303: u'Entity %s name not valid' % getattr(e, u'invalidInput', u'<unknown>'),
    1306: u'%s has members. Cannot delete.' % getattr(e, u'invalidInput', u'<unknown>'),
    1400: u'Invalid Given Name',
    1401: u'Invalid Family Name',
    1402: u'Invalid Password',
    1403: u'Invalid Username',
    1404: u'Invalid Hash Function Name',
    1405: u'Invalid Hash Digest Length',
    1406: u'Invalid Email Address',
    1407: u'Invalid Query Parameter Value',
    1408: u'Invalid SSO Signing Key',
    1409: u'Invalid Encryption Public Key',
    1410: u'Feature Unavailable For User',
    1500: u'Too Many Recipients On Email List',
    1501: u'Too Many Aliases For User',
    1502: u'Too Many Delegates For User',
    1601: u'Duplicate Destinations',
    1602: u'Too Many Destinations',
    1603: u'Invalid Route Address',
    1700: u'Group Cannot Contain Cycle',
    1800: u'Group Cannot Contain Cycle',
    1801: u'Invalid value %s' % getattr(e, u'invalidInput', u'<unknown>'),
  }
  return (e.error_code, error_code_map.get(e.error_code, u'Unknown Error: {0}'.format(str(e))))

def waitOnFailure(n, retries, error_code, error_message):
  wait_on_fail = min(2 ** n, 60)+float(random.randint(1, 1000)) / 1000
  if n > 3:
    writeStderr(u'Temporary error: {0} - {1}. Backing off {2} seconds...'.format(error_code, error_message, int(wait_on_fail)))
  time.sleep(wait_on_fail)
  if n > 3:
    writeStderr(u'attempt {0}/{1}\n'.format(n+1, retries))

class GData_badRequest(Exception):
  pass
class GData_doesNotExist(Exception):
  pass
class GData_entityExists(Exception):
  pass
class GData_forbidden(Exception):
  pass
class GData_insufficientPermissions(Exception):
  pass
class GData_internalServerError(Exception):
  pass
class GData_invalidDomain(Exception):
  pass
class GData_invalidValue(Exception):
  pass
class GData_nameNotValid(Exception):
  pass
class GData_notFound(Exception):
  pass
class GData_notImplemented(Exception):
  pass
class GData_preconditionFailed(Exception):
  pass
class GData_serviceNotApplicable(Exception):
  pass

GDATA_ERROR_CODE_EXCEPTION_MAP = {
  GDATA_BAD_REQUEST: GData_badRequest,
  GDATA_DOES_NOT_EXIST: GData_doesNotExist,
  GDATA_ENTITY_EXISTS: GData_entityExists,
  GDATA_FORBIDDEN: GData_forbidden,
  GDATA_INSUFFICIENT_PERMISSIONS: GData_insufficientPermissions,
  GDATA_INTERNAL_SERVER_ERROR: GData_internalServerError,
  GDATA_INVALID_DOMAIN: GData_invalidDomain,
  GDATA_INVALID_VALUE: GData_invalidValue,
  GDATA_NAME_NOT_VALID: GData_nameNotValid,
  GDATA_NOT_FOUND: GData_notFound,
  GDATA_NOT_IMPLEMENTED: GData_notImplemented,
  GDATA_PRECONDITION_FAILED: GData_preconditionFailed,
  GDATA_SERVICE_NOT_APPLICABLE: GData_serviceNotApplicable,
  }

def callGData(service, function,
              soft_errors=False, throw_errors=None, retry_errors=None,
              **kwargs):
  import gdata.apps.service
  if throw_errors is None:
    throw_errors = []
  if retry_errors is None:
    retry_errors = []
  method = getattr(service, function)
  retries = 10
  for n in range(1, retries+1):
    try:
      return method(**kwargs)
    except gdata.apps.service.AppsForYourDomainException as e:
      error_code, error_message = checkGDataError(e, service)
      if error_code in throw_errors:
        if error_code in GDATA_ERROR_CODE_EXCEPTION_MAP:
          raise GDATA_ERROR_CODE_EXCEPTION_MAP[error_code](error_message)
        raise
      if (n != retries) and (error_code in GDATA_NON_TERMINATING_ERRORS+retry_errors):
        waitOnFailure(n, retries, error_code, error_message)
        continue
      if soft_errors:
        stderrErrorMsg(u'{0} - {1}{2}'.format(error_code, error_message, [u'', u': Giving up.'][n > 1]))
        return None
      if error_code == GDATA_INSUFFICIENT_PERMISSIONS:
        APIAccessDeniedExit()
      systemErrorExit(GOOGLE_API_ERROR_RC, u'{0} - {1}'.format(error_code, error_message))
    except oauth2client.client.AccessTokenRefreshError as e:
      handleOAuthTokenError(e, GDATA_SERVICE_NOT_APPLICABLE in throw_errors)
      raise GDATA_ERROR_CODE_EXCEPTION_MAP[GDATA_SERVICE_NOT_APPLICABLE](e.message)
    except (httplib.ResponseNotReady, httplib2.SSLHandshakeError, socket.error) as e:
      if n != retries:
        waitOnFailure(n, retries, e.errno, e.strerror)
        continue
      if soft_errors:
        stderrErrorMsg(formatExceptionMessage(e, u': Giving up.'))
        return None
      systemErrorExit(SOCKET_ERROR_RC, e.strerror)

def callGDataPages(service, function,
                   page_message=None,
                   soft_errors=False, throw_errors=None, retry_errors=None,
                   uri=None,
                   **kwargs):
  if throw_errors is None:
    throw_errors = []
  if retry_errors is None:
    retry_errors = []
  nextLink = None
  allResults = []
  totalItems = 0
  while True:
    this_page = callGData(service, function,
                          soft_errors=soft_errors, throw_errors=throw_errors, retry_errors=retry_errors,
                          uri=uri,
                          **kwargs)
    if this_page:
      nextLink = this_page.GetNextLink()
      pageItems = len(this_page.entry)
      if pageItems == 0:
        nextLink = None
      totalItems += pageItems
      allResults.extend(this_page.entry)
    else:
      nextLink = None
      pageItems = 0
    if page_message:
      if Entity.GettingShowTotal():
        show_message = page_message.replace(TOTAL_ITEMS_MARKER, str(totalItems))
        count = totalItems
      else:
        show_message = page_message.replace(NUM_ITEMS_MARKER, str(pageItems))
        count = pageItems if nextLink else totalItems
      writeStderr(u'\r')
      flushStderr()
      writeStderr(show_message.format(Entity.ChooseGetting(count)))
    if nextLink is None:
      if page_message and (page_message[-1] != u'\n'):
        writeStderr(u'\r\n')
        flushStderr()
      return allResults
    uri = nextLink.href

GAPI_REASON_MESSAGE_MAP = {
  GAPI_ABORTED: [
    (u'Label name exists or conflicts', GAPI_DUPLICATE),
    ],
  GAPI_CONDITION_NOT_MET: [
    (u'Cyclic memberships not allowed', GAPI_CYCLIC_MEMBERSHIPS_NOT_ALLOWED),
    (u'undelete', GAPI_DELETED_USER_NOT_FOUND),
    ],
  GAPI_FAILED_PRECONDITION: [
    (u'Bad Request', GAPI_BAD_REQUEST),
    (u'Mail service not enabled', GAPI_SERVICE_NOT_AVAILABLE),
    ],
  GAPI_INVALID: [
    (u'userId', GAPI_USER_NOT_FOUND),
    (u'memberKey', GAPI_INVALID_MEMBER),
    (u'A system error has occurred', GAPI_SYSTEM_ERROR),
    (u'Invalid Customer Id', GAPI_INVALID_CUSTOMER_ID),
    (u'Invalid Input: INVALID_OU_ID', GAPI_INVALID_ORGUNIT),
    (u'Invalid Input: custom_schema', GAPI_INVALID_SCHEMA_VALUE),
    (u'Invalid Input: resource', GAPI_INVALID_RESOURCE),
    (u'Invalid Input:', GAPI_INVALID_INPUT),
    (u'Invalid Org Unit', GAPI_INVALID_ORGUNIT),
    (u'Invalid Ou Id', GAPI_INVALID_ORGUNIT),
    (u'Invalid Parent Orgunit Id', GAPI_INVALID_PARENT_ORGUNIT),
    (u'Invalid query', GAPI_INVALID_QUERY),
    (u'Invalid scope value', GAPI_INVALID_SCOPE_VALUE),
    (u'New domain name is not a verified secondary domain', GAPI_DOMAIN_NOT_VERIFIED_SECONDARY),
    ],
  GAPI_INVALID_ARGUMENT: [
    (u'Cannot delete primary send-as', GAPI_CANNOT_DELETE_PRIMARY_SENDAS),
    (u'Invalid id value', GAPI_INVALID_MESSAGE_ID),
    (u'Invalid ids value', GAPI_INVALID_MESSAGE_ID),
    ],
  GAPI_NOT_FOUND: [
    (u'userKey', GAPI_USER_NOT_FOUND),
    (u'groupKey', GAPI_GROUP_NOT_FOUND),
    (u'memberKey', GAPI_MEMBER_NOT_FOUND),
    (u'photo', GAPI_PHOTO_NOT_FOUND),
    (u'resource_id', GAPI_RESOURCE_ID_NOT_FOUND),
    (u'resourceId', GAPI_RESOURCE_ID_NOT_FOUND),
    (u'Customer doesn\'t exist', GAPI_CUSTOMER_NOT_FOUND),
    (u'Domain alias does not exist', GAPI_DOMAIN_ALIAS_NOT_FOUND),
    (u'Domain not found', GAPI_DOMAIN_NOT_FOUND),
    (u'domain', GAPI_DOMAIN_NOT_FOUND),
    (u'File not found', GAPI_FILE_NOT_FOUND),
    (u'Org unit not found', GAPI_ORGUNIT_NOT_FOUND),
    (u'Permission not found', GAPI_PERMISSION_NOT_FOUND),
    (u'Resource Not Found', GAPI_RESOURCE_NOT_FOUND),
    (u'Not Found', GAPI_NOT_FOUND),
    ],
  GAPI_REQUIRED: [
    (u'Login Required', GAPI_LOGIN_REQUIRED),
    (u'memberKey', GAPI_MEMBER_NOT_FOUND),
    ],
  GAPI_RESOURCE_NOT_FOUND: [
    (u'resourceId', GAPI_RESOURCE_ID_NOT_FOUND),
    ],
  }

def checkGAPIError(e, soft_errors=False, silent_errors=False, retryOnHttpError=False, service=None):
  try:
    error = json.loads(e.content)
  except ValueError:
    if (e.resp[u'status'] == u'503') and (e.content.startswith(u'Quota exceeded for the current request')):
      return (e.resp[u'status'], GAPI_QUOTA_EXCEEDED, e.content)
    if (e.resp[u'status'] == u'403') and (e.content.startswith(u'Request rate higher than configured')):
      return (e.resp[u'status'], GAPI_QUOTA_EXCEEDED, e.content)
    if (e.resp[u'status'] == u'502') and (u'Bad Gateway' in e.content):
      return (e.resp[u'status'], GAPI_BAD_GATEWAY, e.content)
    if (e.resp[u'status'] == u'403') and (u'Invalid domain.' in e.content):
      error = {u'error': {u'code': 403, u'errors': [{u'reason': GAPI_NOT_FOUND, u'message': u'Domain not found'}]}}
    elif (e.resp[u'status'] == u'400') and (u'InvalidSsoSigningKey' in e.content):
      error = {u'error': {u'code': 400, u'errors': [{u'reason': GAPI_INVALID, u'message': u'InvalidSsoSigningKey'}]}}
    elif (e.resp[u'status'] == u'400') and (u'UnknownError' in e.content):
      error = {u'error': {u'code': 400, u'errors': [{u'reason': GAPI_INVALID, u'message': u'UnknownError'}]}}
    elif (e.resp[u'status'] == u'400') and (u'FeatureUnavailableForUser' in e.content):
      error = {u'error': {u'code': 400, u'errors': [{u'reason': GAPI_SERVICE_NOT_AVAILABLE, u'message': u'Feature Unavailable For User'}]}}
    elif (e.resp[u'status'] == u'400') and (u'EntityDoesNotExist' in e.content):
      error = {u'error': {u'code': 400, u'errors': [{u'reason': GAPI_NOT_FOUND, u'message': u'Entity Does Not Exist'}]}}
    elif (e.resp[u'status'] == u'400') and (u'EntityNameNotValid' in e.content):
      error = {u'error': {u'code': 400, u'errors': [{u'reason': GAPI_INVALID_INPUT, u'message': u'Entity Name Not Valid'}]}}
    elif retryOnHttpError:
      service._http.request.credentials.refresh(httplib2.Http(disable_ssl_certificate_validation=GC_Values[GC_NO_VERIFY_SSL]))
      return (-1, None, None)
    elif soft_errors:
      if not silent_errors:
        stderrErrorMsg(e.content)
      return (0, None, None)
    else:
      systemErrorExit(HTTP_ERROR_RC, e.content)
  if u'error' in error:
    http_status = error[u'error'][u'code']
    try:
      message = error[u'error'][u'errors'][0][u'message']
    except KeyError:
      message = error[u'error'][u'message']
    if http_status == 500:
      if not message:
        message = PHRASE_UNKNOWN
        error = {u'error': {u'errors': [{u'reason': GAPI_UNKNOWN_ERROR, u'message': message}]}}
      elif u'Backend Error' in message:
        error = {u'error': {u'errors': [{u'reason': GAPI_BACKEND_ERROR, u'message': message}]}}
      elif u'Role assignment exists: RoleAssignment' in message:
        error = {u'error': {u'errors': [{u'reason': GAPI_DUPLICATE, u'message': message}]}}
  else:
    if u'error_description' in error:
      if error[u'error_description'] == u'Invalid Value':
        message = error[u'error_description']
        http_status = 400
        error = {u'error': {u'errors': [{u'reason': GAPI_INVALID, u'message': message}]}}
      else:
        systemErrorExit(GOOGLE_API_ERROR_RC, str(error))
    else:
      systemErrorExit(GOOGLE_API_ERROR_RC, str(error))
  try:
    reason = error[u'error'][u'errors'][0][u'reason']
    for messageItem in GAPI_REASON_MESSAGE_MAP.get(reason, []):
      if messageItem[0] in message:
        if reason in [GAPI_NOT_FOUND, GAPI_RESOURCE_NOT_FOUND]:
          message = PHRASE_DOES_NOT_EXIST
        reason = messageItem[1]
        break
    if reason == GAPI_INVALID_SHARING_REQUEST:
      loc = message.find(u'User message: ')
      if loc != 1:
        message = message[loc+15:]
  except KeyError:
    reason = u'{0}'.format(http_status)
  return (http_status, reason, message)

class GAPI_aborted(Exception):
  pass
class GAPI_alreadyExists(Exception):
  pass
class GAPI_authError(Exception):
  pass
class GAPI_backendError(Exception):
  pass
class GAPI_badRequest(Exception):
  pass
class GAPI_cannotChangeOwnAcl(Exception):
  pass
class GAPI_cannotChangeOwnerAcl(Exception):
  pass
class GAPI_cannotDeletePrimaryCalendar(Exception):
  pass
class GAPI_cannotDeletePrimarySendAs(Exception):
  pass
class GAPI_conditionNotMet(Exception):
  pass
class GAPI_customerNotFound(Exception):
  pass
class GAPI_cyclicMembershipsNotAllowed(Exception):
  pass
class GAPI_deleted(Exception):
  pass
class GAPI_deletedUserNotFound(Exception):
  pass
class GAPI_domainAliasNotFound(Exception):
  pass
class GAPI_domainNotFound(Exception):
  pass
class GAPI_domainNotVerifiedSecondary(Exception):
  pass
class GAPI_duplicate(Exception):
  pass
class GAPI_failedPrecondition(Exception):
  pass
class GAPI_fileNotFound(Exception):
  pass
class GAPI_forbidden(Exception):
  pass
class GAPI_groupNotFound(Exception):
  pass
class GAPI_illegalAccessRoleForDefault(Exception):
  pass
class GAPI_insufficientPermissions(Exception):
  pass
class GAPI_internalError(Exception):
  pass
class GAPI_invalid(Exception):
  pass
class GAPI_invalidArgument(Exception):
  pass
class GAPI_invalidCustomerId(Exception):
  pass
class GAPI_invalidInput(Exception):
  pass
class GAPI_invalidMember(Exception):
  pass
class GAPI_invalidMessageId(Exception):
  pass
class GAPI_invalidOrgunit(Exception):
  pass
class GAPI_invalidOwnershipTransfer(Exception):
  pass
class GAPI_invalidParameter(Exception):
  pass
class GAPI_invalidParentOrgunit(Exception):
  pass
class GAPI_invalidQuery(Exception):
  pass
class GAPI_invalidResource(Exception):
  pass
class GAPI_invalidSchemaValue(Exception):
  pass
class GAPI_invalidScopeValue(Exception):
  pass
class GAPI_invalidSharingRequest(Exception):
  pass
class GAPI_loginRequired(Exception):
  pass
class GAPI_memberNotFound(Exception):
  pass
class GAPI_notACalendarUser(Exception):
  pass
class GAPI_notFound(Exception):
  pass
class GAPI_notImplemented(Exception):
  pass
class GAPI_orgunitNotFound(Exception):
  pass
class GAPI_permissionDenied(Exception):
  pass
class GAPI_permissionNotFound(Exception):
  pass
class GAPI_photoNotFound(Exception):
  pass
class GAPI_required(Exception):
  pass
class GAPI_resourceIdNotFound(Exception):
  pass
class GAPI_resourceNotFound(Exception):
  pass
class GAPI_serviceLimit(Exception):
  pass
class GAPI_serviceNotAvailable(Exception):
  pass
class GAPI_systemError(Exception):
  pass
class GAPI_timeRangeEmpty(Exception):
  pass
class GAPI_unknownError(Exception):
  pass
class GAPI_userNotFound(Exception):
  pass

GAPI_REASON_EXCEPTION_MAP = {
  GAPI_ABORTED: GAPI_aborted,
  GAPI_ALREADY_EXISTS: GAPI_alreadyExists,
  GAPI_AUTH_ERROR: GAPI_authError,
  GAPI_BACKEND_ERROR: GAPI_backendError,
  GAPI_BAD_REQUEST: GAPI_badRequest,
  GAPI_CANNOT_CHANGE_OWN_ACL: GAPI_cannotChangeOwnAcl,
  GAPI_CANNOT_CHANGE_OWNER_ACL: GAPI_cannotChangeOwnerAcl,
  GAPI_CANNOT_DELETE_PRIMARY_CALENDAR: GAPI_cannotDeletePrimaryCalendar,
  GAPI_CANNOT_DELETE_PRIMARY_SENDAS: GAPI_cannotDeletePrimarySendAs,
  GAPI_CONDITION_NOT_MET: GAPI_conditionNotMet,
  GAPI_CUSTOMER_NOT_FOUND: GAPI_customerNotFound,
  GAPI_CYCLIC_MEMBERSHIPS_NOT_ALLOWED: GAPI_cyclicMembershipsNotAllowed,
  GAPI_DELETED: GAPI_deleted,
  GAPI_DELETED_USER_NOT_FOUND: GAPI_deletedUserNotFound,
  GAPI_DOMAIN_ALIAS_NOT_FOUND: GAPI_domainAliasNotFound,
  GAPI_DOMAIN_NOT_FOUND: GAPI_domainNotFound,
  GAPI_DOMAIN_NOT_VERIFIED_SECONDARY: GAPI_domainNotVerifiedSecondary,
  GAPI_DUPLICATE: GAPI_duplicate,
  GAPI_FAILED_PRECONDITION: GAPI_failedPrecondition,
  GAPI_FILE_NOT_FOUND: GAPI_fileNotFound,
  GAPI_FORBIDDEN: GAPI_forbidden,
  GAPI_GROUP_NOT_FOUND: GAPI_groupNotFound,
  GAPI_ILLEGAL_ACCESS_ROLE_FOR_DEFAULT: GAPI_illegalAccessRoleForDefault,
  GAPI_INSUFFICIENT_PERMISSIONS: GAPI_insufficientPermissions,
  GAPI_INTERNAL_ERROR: GAPI_internalError,
  GAPI_INVALID: GAPI_invalid,
  GAPI_INVALID_ARGUMENT: GAPI_invalidArgument,
  GAPI_INVALID_CUSTOMER_ID: GAPI_invalidCustomerId,
  GAPI_INVALID_INPUT: GAPI_invalidInput,
  GAPI_INVALID_MEMBER: GAPI_invalidMember,
  GAPI_INVALID_MESSAGE_ID: GAPI_invalidMessageId,
  GAPI_INVALID_ORGUNIT: GAPI_invalidOrgunit,
  GAPI_INVALID_OWNERSHIP_TRANSFER: GAPI_invalidOwnershipTransfer,
  GAPI_INVALID_PARAMETER: GAPI_invalidParameter,
  GAPI_INVALID_PARENT_ORGUNIT: GAPI_invalidParentOrgunit,
  GAPI_INVALID_QUERY: GAPI_invalidQuery,
  GAPI_INVALID_RESOURCE: GAPI_invalidResource,
  GAPI_INVALID_SCHEMA_VALUE: GAPI_invalidSchemaValue,
  GAPI_INVALID_SCOPE_VALUE: GAPI_invalidScopeValue,
  GAPI_INVALID_SHARING_REQUEST: GAPI_invalidSharingRequest,
  GAPI_LOGIN_REQUIRED: GAPI_loginRequired,
  GAPI_MEMBER_NOT_FOUND: GAPI_memberNotFound,
  GAPI_NOT_A_CALENDAR_USER: GAPI_notACalendarUser,
  GAPI_NOT_FOUND: GAPI_notFound,
  GAPI_NOT_IMPLEMENTED: GAPI_notImplemented,
  GAPI_ORGUNIT_NOT_FOUND: GAPI_orgunitNotFound,
  GAPI_PERMISSION_DENIED: GAPI_permissionDenied,
  GAPI_PERMISSION_NOT_FOUND: GAPI_permissionNotFound,
  GAPI_PHOTO_NOT_FOUND: GAPI_photoNotFound,
  GAPI_REQUIRED: GAPI_required,
  GAPI_RESOURCE_ID_NOT_FOUND: GAPI_resourceIdNotFound,
  GAPI_RESOURCE_NOT_FOUND: GAPI_resourceNotFound,
  GAPI_SERVICE_LIMIT: GAPI_serviceLimit,
  GAPI_SERVICE_NOT_AVAILABLE: GAPI_serviceNotAvailable,
  GAPI_SYSTEM_ERROR: GAPI_systemError,
  GAPI_TIME_RANGE_EMPTY: GAPI_timeRangeEmpty,
  GAPI_UNKNOWN_ERROR: GAPI_unknownError,
  GAPI_USER_NOT_FOUND: GAPI_userNotFound,
  }

def callGAPI(service, function,
             silent_errors=False, soft_errors=False, throw_reasons=None, retry_reasons=None,
             **kwargs):
  if throw_reasons is None:
    throw_reasons = []
  if retry_reasons is None:
    retry_reasons = []
  method = getattr(service, function)
  retries = 10
  svcparms = dict(kwargs.items()+GM_Globals[GM_EXTRA_ARGS_LIST])
  for n in range(1, retries+1):
    try:
      return method(**svcparms).execute()
    except googleapiclient.errors.HttpError as e:
      http_status, reason, message = checkGAPIError(e, soft_errors=soft_errors, silent_errors=silent_errors, retryOnHttpError=n < 3, service=service)
      if http_status == -1:
        continue
      if http_status == 0:
        return None
      if reason in throw_reasons:
        if reason in GAPI_REASON_EXCEPTION_MAP:
          raise GAPI_REASON_EXCEPTION_MAP[reason](message)
        raise e
      if (n != retries) and (reason in GAPI_DEFAULT_RETRY_REASONS+retry_reasons):
        waitOnFailure(n, retries, reason, message)
        continue
      if soft_errors:
        stderrErrorMsg(u'{0}: {1} - {2}{3}'.format(http_status, reason, message, [u'', u': Giving up.'][n > 1]))
        return None
      if reason == GAPI_INSUFFICIENT_PERMISSIONS:
        APIAccessDeniedExit()
      systemErrorExit(HTTP_ERROR_RC, formatHTTPError(http_status, reason, message))
    except oauth2client.client.AccessTokenRefreshError as e:
      handleOAuthTokenError(e, GAPI_SERVICE_NOT_AVAILABLE in throw_reasons)
      raise GAPI_REASON_EXCEPTION_MAP[GAPI_SERVICE_NOT_AVAILABLE](e.message)
    except httplib2.CertificateValidationUnsupported:
      noPythonSSLExit()
    except (httplib.ResponseNotReady, httplib2.SSLHandshakeError, socket.error) as e:
      if n != retries:
        waitOnFailure(n, retries, e.errno, e.strerror)
        continue
      if soft_errors:
        stderrErrorMsg(formatExceptionMessage(e, u': Giving up.'))
        return None
      systemErrorExit(SOCKET_ERROR_RC, e.strerror)
    except TypeError as e:
      systemErrorExit(GOOGLE_API_ERROR_RC, e)

def _processGAPIpagesResult(results, items, allResults, totalItems, page_message, message_attribute, entityType):
  if results:
    pageToken = results.get(u'nextPageToken')
    if items in results:
      pageItems = len(results[items])
      totalItems += pageItems
      allResults.extend(results[items])
    else:
      results = {items: []}
      pageItems = 0
  else:
    pageToken = None
    results = {items: []}
    pageItems = 0
  if page_message:
    if Entity.GettingShowTotal():
      show_message = page_message.replace(TOTAL_ITEMS_MARKER, str(totalItems))
      count = totalItems
    else:
      show_message = page_message.replace(NUM_ITEMS_MARKER, str(pageItems))
      count = pageItems if pageToken else totalItems
    if message_attribute:
      try:
        show_message = show_message.replace(FIRST_ITEM_MARKER, str(results[items][0][message_attribute]))
        show_message = show_message.replace(LAST_ITEM_MARKER, str(results[items][-1][message_attribute]))
      except (IndexError, KeyError):
        show_message = show_message.replace(FIRST_ITEM_MARKER, u'')
        show_message = show_message.replace(LAST_ITEM_MARKER, u'')
    writeStderr(u'\r')
    flushStderr()
    writeStderr(show_message.format(Entity.Choose(entityType, count)))
  return (pageToken, totalItems)

def callGAPIpages(service, function, items,
                  page_message=None, message_attribute=None, maxItems=0,
                  throw_reasons=None, retry_reasons=None,
                  **kwargs):
  if throw_reasons is None:
    throw_reasons = []
  if retry_reasons is None:
    retry_reasons = []
  pageToken = None
  allResults = collections.deque()
  totalItems = 0
  maxResults = kwargs.get(u'maxResults', 0)
  tweakMaxResults = maxItems and maxResults
  entityType = Entity.Getting() if page_message else None
  while True:
    if tweakMaxResults and maxItems-totalItems < maxResults:
      kwargs[u'maxResults'] = maxItems-totalItems
    results = callGAPI(service, function,
                       throw_reasons=throw_reasons, retry_reasons=retry_reasons,
                       pageToken=pageToken,
                       **kwargs)
    pageToken, totalItems = _processGAPIpagesResult(results, items, allResults, totalItems, page_message, message_attribute, entityType)
    if not pageToken or maxItems and totalItems >= maxItems:
      if page_message and (page_message[-1] != u'\n'):
        writeStderr(u'\r\n')
        flushStderr()
      return allResults

def callGAPIitems(service, function, items,
                  throw_reasons=None, retry_reasons=None,
                  **kwargs):
  if throw_reasons is None:
    throw_reasons = []
  if retry_reasons is None:
    retry_reasons = []
  results = callGAPI(service, function,
                     throw_reasons=throw_reasons, retry_reasons=retry_reasons,
                     **kwargs)
  if results:
    return results.get(items, [])
  return []

class GCP_cantModifyFinishedJob(Exception):
  pass
class GCP_failedToShareThePrinter(Exception):
  pass
class GCP_noPrintJobs(Exception):
  pass
class GCP_unknownJobId(Exception):
  pass
class GCP_unknownPrinter(Exception):
  pass
class GCP_userIsNotAuthorized(Exception):
  pass

GCP_MESSAGE_EXCEPTION_MAP = {
  GCP_CANT_MODIFY_FINISHED_JOB: GCP_cantModifyFinishedJob,
  GCP_FAILED_TO_SHARE_THE_PRINTER: GCP_failedToShareThePrinter,
  GCP_NO_PRINT_JOBS: GCP_noPrintJobs,
  GCP_UNKNOWN_JOB_ID: GCP_unknownJobId,
  GCP_UNKNOWN_PRINTER: GCP_unknownPrinter,
  GCP_USER_IS_NOT_AUTHORIZED: GCP_userIsNotAuthorized,
  }

def checkCloudPrintResult(result, throw_messages=None):
  if throw_messages is None:
    throw_messages = []
  if isinstance(result, str):
    try:
      result = json.loads(result)
    except ValueError:
      systemErrorExit(JSON_LOADS_ERROR_RC, result)
  if not result[u'success']:
    message = result[u'message']
    if message in throw_messages:
      if message in GCP_MESSAGE_EXCEPTION_MAP:
        raise GCP_MESSAGE_EXCEPTION_MAP[message](message)
    systemErrorExit(AC_FAILED_RC, u'{0}: {1}'.format(result[u'errorCode'], result[u'message']))
  return result

def callGCP(service, function,
            throw_messages=None,
            **kwargs):
  result = callGAPI(service, function,
                    **kwargs)
  return checkCloudPrintResult(result, throw_messages=throw_messages)

API_INFO = {
  ADMIN_SETTINGS_API: {u'version': u'v2', u'credfam': OAUTH2_FAM2_SCOPES, u'localjson': True},
  APPSACTIVITY_API: {u'version': u'v1', u'credfam': OAUTH2_FAM1_SCOPES, u'svcacctscopes': [u'https://www.googleapis.com/auth/activity', u'https://www.googleapis.com/auth/drive']},
  CALENDAR_API: {u'version': u'v3', u'credfam': OAUTH2_FAM1_SCOPES, u'svcacctscopes': [u'https://www.googleapis.com/auth/calendar',]},
  CLASSROOM_API: {u'version': u'v1', u'credfam': OAUTH2_FAM2_SCOPES},
  CLOUDPRINT_API: {u'version': u'v2', u'credfam': OAUTH2_FAM2_SCOPES, u'localjson': True},
  CONTACTS_API: {u'version': u'v3', u'credfam': OAUTH2_FAM2_SCOPES, u'svcacctscopes': [u'https://www.google.com/m8/feeds',], u'localjson': True},
  DATATRANSFER_API: {u'version': u'datatransfer_v1', u'credfam': OAUTH2_FAM1_SCOPES},
  DIRECTORY_API: {u'version': u'directory_v1', u'credfam': OAUTH2_FAM1_SCOPES},
  DRIVE_API: {u'version': DRIVE_API_VERSION, u'credfam': OAUTH2_FAM1_SCOPES, u'svcacctscopes': [u'https://www.googleapis.com/auth/drive',]},
  EMAIL_AUDIT_API: {u'version': u'v1', u'credfam': OAUTH2_FAM2_SCOPES, u'localjson': True},
  EMAIL_SETTINGS_API: {u'version': u'v2', u'credfam': OAUTH2_FAM1_SCOPES, u'localjson': True},
  GMAIL_API: {u'version': u'v1', u'credfam': OAUTH2_FAM1_SCOPES, u'svcacctscopes': [u'https://mail.google.com/', u'https://www.googleapis.com/auth/gmail.settings.basic', u'https://www.googleapis.com/auth/gmail.settings.sharing',]},
  GPLUS_API: {u'version': u'v1', u'credfam': OAUTH2_FAM1_SCOPES, u'svcacctscopes': [u'https://www.googleapis.com/auth/plus.me', u'https://www.googleapis.com/auth/plus.login', u'https://www.googleapis.com/auth/userinfo.email', u'https://www.googleapis.com/auth/userinfo.profile']},
  GROUPSMIGRATION_API: {u'version': u'v1', u'credfam': OAUTH2_FAM2_SCOPES},
  GROUPSSETTINGS_API: {u'version': u'v1', u'credfam': OAUTH2_FAM2_SCOPES},
  LICENSING_API: {u'version': u'v1', u'credfam': OAUTH2_FAM1_SCOPES},
  REPORTS_API: {u'version': u'reports_v1', u'credfam': OAUTH2_FAM2_SCOPES},
  RESELLER_API: {u'version': u'v1', u'credfam': OAUTH2_FAM2_SCOPES},
  SITES_API: {u'version': u'v1', u'credfam': OAUTH2_FAM2_SCOPES, u'svcacctscopes': [u'https://sites.google.com/feeds',], u'localjson': True},
  SITEVERIFICATION_API: {u'version': u'v1', u'credfam': OAUTH2_FAM2_SCOPES},
  }

def getAPIVersion(api):
  version = API_INFO[api][u'version']
  cred_family = API_INFO[api][u'credfam']
  if api in [DIRECTORY_API, REPORTS_API, DATATRANSFER_API]:
    api = u'admin'
  return (api, version, u'{0}-{1}'.format(api, version), cred_family)

def readDiscoveryFile(api_version):
  disc_filename = u'%s.json' % (api_version)
  disc_file = os.path.join(GM_Globals[GM_GAM_PATH], disc_filename)
  if hasattr(sys, u'_MEIPASS'):
    pyinstaller_disc_file = os.path.join(sys._MEIPASS, disc_filename)
  else:
    pyinstaller_disc_file = None
  if os.path.isfile(disc_file):
    json_string = readFile(disc_file, continueOnError=True, displayError=True)
  elif pyinstaller_disc_file:
    json_string = readFile(pyinstaller_disc_file, continueOnError=True, displayError=True)
  else:
    json_string = None
  if not json_string:
    invalidDiscoveryJsonExit(disc_file)
  try:
    discovery = json.loads(json_string)
    return (disc_file, discovery)
  except ValueError:
    invalidDiscoveryJsonExit(disc_file)

def getAPIversionHttpService(api):
  localjson = API_INFO[api].get(u'localjson', False)
  api, version, api_version, cred_family = getAPIVersion(api)
  http = httplib2.Http(disable_ssl_certificate_validation=GC_Values[GC_NO_VERIFY_SSL],
                       cache=GM_Globals[GM_CACHE_DIR])
  if not localjson:
    retries = 5
    for n in range(1, retries+1):
      try:
        service = googleapiclient.discovery.build(api, version, http=http, cache_discovery=False)
        if GM_Globals[GM_CACHE_DISCOVERY_ONLY]:
          http.cache = None
        return (api_version, http, service, cred_family)
      except httplib2.ServerNotFoundError as e:
        systemErrorExit(NETWORK_ERROR_RC, e.message)
      except googleapiclient.errors.UnknownApiNameOrVersion as e:
        systemErrorExit(GOOGLE_API_ERROR_RC, MESSAGE_UNKNOWN_API_OR_VERSION.format(e.message))
      except googleapiclient.errors.InvalidJsonError:
        if n != retries:
          waitOnFailure(n, retries, INVALID_JSON_RC, MESSAGE_INVALID_JSON_INFORMATION)
          continue
        systemErrorExit(INVALID_JSON_RC, MESSAGE_INVALID_JSON_INFORMATION)
      except (httplib.ResponseNotReady, httplib2.SSLHandshakeError, socket.error) as e:
        if n != retries:
          waitOnFailure(n, retries, e.errno, e.strerror)
          continue
        systemErrorExit(SOCKET_ERROR_RC, e.strerror)
  disc_file, discovery = readDiscoveryFile(api_version)
  try:
    service = googleapiclient.discovery.build_from_document(discovery, http=http)
    if GM_Globals[GM_CACHE_DISCOVERY_ONLY]:
      http.cache = None
    return (api_version, http, service, cred_family)
  except (ValueError, KeyError):
    invalidDiscoveryJsonExit(disc_file)

def buildGAPIObject(api):
  GM_Globals[GM_CURRENT_API_USER] = None
  _, http, service, cred_family = getAPIversionHttpService(api)
  credentials = getClientCredentials(cred_family)
  GM_Globals[GM_CURRENT_API_SCOPES] = list(set(service._rootDesc[u'auth'][u'oauth2'][u'scopes'].keys()).intersection(credentials.scopes))
  if not GM_Globals[GM_CURRENT_API_SCOPES]:
    systemErrorExit(NO_SCOPES_FOR_API_RC, MESSAGE_NO_SCOPES_FOR_API.format(service._rootDesc[u'title']))
  try:
    service._http = credentials.authorize(http)
  except httplib2.ServerNotFoundError as e:
    systemErrorExit(NETWORK_ERROR_RC, e.message)
  except oauth2client.client.AccessTokenRefreshError as e:
    return handleOAuthTokenError(e, False)
  if not GC_Values[GC_DOMAIN]:
    GC_Values[GC_DOMAIN] = credentials.id_token.get(u'hd', u'UNKNOWN').lower()
  if not GC_Values[GC_CUSTOMER_ID]:
    GC_Values[GC_CUSTOMER_ID] = MY_CUSTOMER
  GM_Globals[GM_ADMIN] = credentials.id_token.get(u'email', u'UNKNOWN').lower()
  GM_Globals[GM_OAUTH2_CLIENT_ID] = credentials.client_id
  return service

def buildGAPIServiceObject(api, user):
  userEmail = convertUserUIDtoEmailAddress(user)
  _, http, service, _ = getAPIversionHttpService(api)
  GM_Globals[GM_CURRENT_API_USER] = userEmail
  GM_Globals[GM_CURRENT_API_SCOPES] = API_INFO[api][u'svcacctscopes']
  credentials = getSvcAcctCredentials(GM_Globals[GM_CURRENT_API_SCOPES], userEmail)
  try:
    service._http = credentials.authorize(http)
  except httplib2.ServerNotFoundError as e:
    systemErrorExit(NETWORK_ERROR_RC, e.message)
  except oauth2client.client.AccessTokenRefreshError as e:
    return (userEmail, handleOAuthTokenError(e, True))
  return (userEmail, service)

def initGDataObject(gdataObj, api):
  _, _, api_version, cred_family = getAPIVersion(api)
  disc_file, discovery = readDiscoveryFile(api_version)
  GM_Globals[GM_CURRENT_API_USER] = None
  credentials = getClientCredentials(cred_family)
  try:
    GM_Globals[GM_CURRENT_API_SCOPES] = list(set(discovery[u'auth'][u'oauth2'][u'scopes'].keys()).intersection(credentials.scopes))
  except KeyError:
    invalidDiscoveryJsonExit(disc_file)
  if not GM_Globals[GM_CURRENT_API_SCOPES]:
    systemErrorExit(NO_SCOPES_FOR_API_RC, MESSAGE_NO_SCOPES_FOR_API.format(discovery.get(u'title', api_version)))
  getGDataOAuthToken(gdataObj, credentials)
  if GC_Values[GC_DEBUG_LEVEL] > 0:
    gdataObj.debug = True
  return gdataObj

def getGDataUserCredentials(api, user, i, count):
  userEmail = convertUserUIDtoEmailAddress(user)
  _, _, api_version, cred_family = getAPIVersion(api)
  disc_file, discovery = readDiscoveryFile(api_version)
  GM_Globals[GM_CURRENT_API_USER] = userEmail
  credentials = getClientCredentials(cred_family)
  try:
    GM_Globals[GM_CURRENT_API_SCOPES] = list(set(discovery[u'auth'][u'oauth2'][u'scopes'].keys()).intersection(credentials.scopes))
  except KeyError:
    invalidDiscoveryJsonExit(disc_file)
  if not GM_Globals[GM_CURRENT_API_SCOPES]:
    systemErrorExit(NO_SCOPES_FOR_API_RC, MESSAGE_NO_SCOPES_FOR_API.format(discovery.get(u'title', api_version)))
  credentials = getSvcAcctCredentials(GM_Globals[GM_CURRENT_API_SCOPES], userEmail)
  try:
    credentials.refresh(httplib2.Http(disable_ssl_certificate_validation=GC_Values[GC_NO_VERIFY_SSL]))
    return (userEmail, credentials)
  except httplib2.ServerNotFoundError as e:
    systemErrorExit(NETWORK_ERROR_RC, e.message)
  except oauth2client.client.AccessTokenRefreshError as e:
    handleOAuthTokenError(e, True)
    entityUnknownWarning(Entity.USER, userEmail, i, count)
    return (userEmail, None)

def getAdminSettingsObject():
  import gdata.apps.adminsettings.service
  return initGDataObject(gdata.apps.adminsettings.service.AdminSettingsService(), ADMIN_SETTINGS_API)

def getAuditObject():
  import gdata.apps.audit.service
  return initGDataObject(gdata.apps.audit.service.AuditService(), EMAIL_AUDIT_API)

def getContactsObject(entityType=Entity.DOMAIN, entityName=None, i=0, count=0, contactFeed=True):
  import gdata.apps.contacts.service
  if entityType == Entity.DOMAIN:
    contactsObject = initGDataObject(gdata.apps.contacts.service.ContactsService(contactFeed=contactFeed),
                                     CONTACTS_API)
    return (entityName or GC_Values[GC_DOMAIN], contactsObject)
  userEmail, credentials = getGDataUserCredentials(CONTACTS_API, entityName, i, count)
  if not credentials:
    return (userEmail, None)
  contactsObject = gdata.apps.contacts.service.ContactsService(source=GAM_INFO, contactFeed=contactFeed,
                                                               additional_headers={u'Authorization': u'Bearer {0}'.format(credentials.access_token)})
  if GC_Values[GC_DEBUG_LEVEL] > 0:
    contactsObject.debug = True
  return (userEmail, contactsObject)

def getContactsQuery(**kwargs):
  import gdata.apps.contacts.service
  return gdata.apps.contacts.service.ContactsQuery(**kwargs)

def getEmailSettingsObject():
  import gdata.apps.emailsettings.service
  return initGDataObject(gdata.apps.emailsettings.service.EmailSettingsService(), EMAIL_SETTINGS_API)

def getSitesObject(entityType=Entity.DOMAIN, entityName=None, i=0, count=0):
  import gdata.apps.sites.service
  if entityType == Entity.DOMAIN:
    sitesObject = initGDataObject(gdata.apps.sites.service.SitesService(), SITES_API)
    return (entityName or GC_Values[GC_DOMAIN], sitesObject)
  userEmail, credentials = getGDataUserCredentials(SITES_API, entityName, i, count)
  if not credentials:
    return (userEmail, None)
  sitesObject = gdata.apps.sites.service.SitesService(source=GAM_INFO,
                                                      additional_headers={u'Authorization': u'Bearer {0}'.format(credentials.access_token)})
  if GC_Values[GC_DEBUG_LEVEL] > 0:
    sitesObject.debug = True
  return (userEmail, sitesObject)

def getSitesQuery(**kwargs):
  import gdata.apps.sites.service
  return gdata.apps.sites.service.SitesQuery(**kwargs)

# Convert User UID to email address
def convertUserUIDtoEmailAddress(emailAddressOrUID, checkForCustomerId=False):
  if checkForCustomerId and (emailAddressOrUID == GC_Values[GC_CUSTOMER_ID]):
    return emailAddressOrUID
  normalizedEmailAddressOrUID = normalizeEmailAddressOrUID(emailAddressOrUID)
  if normalizedEmailAddressOrUID.find(u'@') > 0:
    return normalizedEmailAddressOrUID
  try:
    cd = buildGAPIObject(DIRECTORY_API)
    result = callGAPI(cd.users(), u'get',
                      throw_reasons=GAPI_USER_GET_THROW_REASONS,
                      userKey=normalizedEmailAddressOrUID, fields=u'primaryEmail')
    if u'primaryEmail' in result:
      return result[u'primaryEmail'].lower()
  except (GAPI_userNotFound, GAPI_domainNotFound, GAPI_forbidden, GAPI_badRequest, GAPI_backendError, GAPI_systemError):
    pass
  return normalizedEmailAddressOrUID

# Convert Group UID to email address
def convertGroupUIDtoEmailAddress(emailAddressOrUID):
  normalizedEmailAddressOrUID = normalizeEmailAddressOrUID(emailAddressOrUID)
  if normalizedEmailAddressOrUID.find(u'@') > 0:
    return normalizedEmailAddressOrUID
  try:
    cd = buildGAPIObject(DIRECTORY_API)
    result = callGAPI(cd.groups(), u'get',
                      throw_reasons=[GAPI_GROUP_NOT_FOUND],
                      groupKey=normalizedEmailAddressOrUID, fields=u'email')
    if u'email' in result:
      return result[u'email'].lower()
  except GAPI_groupNotFound:
    pass
  return normalizedEmailAddressOrUID

# Validate User UID/Convert email address to User UID; called immediately after getting email address from command line
def convertEmailToUserID(user):
  cd = buildGAPIObject(DIRECTORY_API)
  try:
    return callGAPI(cd.users(), u'get',
                    throw_reasons=GAPI_USER_GET_THROW_REASONS,
                    userKey=user, fields=u'id')[u'id']
  except (GAPI_userNotFound, GAPI_domainNotFound, GAPI_forbidden, GAPI_badRequest, GAPI_backendError, GAPI_systemError):
    CLArgs.Backup()
    usageErrorExit(formatKeyValueList(Indent.Spaces(),
                                      [Entity.Singular(Entity.USER), user,
                                       getPhraseDNEorSNA(user)],
                                      u'\n'))

# Convert User UID from API call to email address
def convertUserIDtoEmail(uid):
  cd = buildGAPIObject(DIRECTORY_API)
  try:
    return callGAPI(cd.users(), u'get',
                    throw_reasons=GAPI_USER_GET_THROW_REASONS,
                    userKey=uid, fields=u'primaryEmail')[u'primaryEmail']
  except (GAPI_userNotFound, GAPI_domainNotFound, GAPI_forbidden, GAPI_badRequest, GAPI_backendError, GAPI_systemError):
    return u'uid:{0}'.format(uid)

# Convert UID to split email address
# Return (foo@bar.com, foo, bar.com)
def splitEmailAddressOrUID(emailAddressOrUID):
  normalizedEmailAddressOrUID = normalizeEmailAddressOrUID(emailAddressOrUID)
  atLoc = normalizedEmailAddressOrUID.find(u'@')
  if atLoc > 0:
    return (normalizedEmailAddressOrUID, normalizedEmailAddressOrUID[:atLoc], normalizedEmailAddressOrUID[atLoc+1:])
  try:
    cd = buildGAPIObject(DIRECTORY_API)
    result = callGAPI(cd.users(), u'get',
                      throw_reasons=GAPI_USER_GET_THROW_REASONS,
                      userKey=normalizedEmailAddressOrUID, fields=u'primaryEmail')
    if u'primaryEmail' in result:
      normalizedEmailAddressOrUID = result[u'primaryEmail'].lower()
      atLoc = normalizedEmailAddressOrUID.find(u'@')
      return (normalizedEmailAddressOrUID, normalizedEmailAddressOrUID[:atLoc], normalizedEmailAddressOrUID[atLoc+1:])
  except (GAPI_userNotFound, GAPI_domainNotFound, GAPI_forbidden, GAPI_badRequest, GAPI_backendError, GAPI_systemError):
    pass
  return (normalizedEmailAddressOrUID, normalizedEmailAddressOrUID, GC_Values[GC_DOMAIN])

# Add domain to foo or convert uid:xxx to foo
# Return foo@bar.com
def addDomainToEmailAddressOrUID(emailAddressOrUID, addDomain):
  cg = UID_PATTERN.match(emailAddressOrUID)
  if cg:
    try:
      cd = buildGAPIObject(DIRECTORY_API)
      result = callGAPI(cd.users(), u'get',
                        throw_reasons=GAPI_USER_GET_THROW_REASONS,
                        userKey=cg.group(1), fields=u'primaryEmail')
      if u'primaryEmail' in result:
        return result[u'primaryEmail'].lower()
    except (GAPI_userNotFound, GAPI_domainNotFound, GAPI_forbidden, GAPI_badRequest, GAPI_backendError, GAPI_systemError):
      pass
    return None
  atLoc = emailAddressOrUID.find(u'@')
  if atLoc == -1:
    return u'{0}@{1}'.format(emailAddressOrUID, addDomain)
  if atLoc == len(emailAddressOrUID)-1:
    return u'{0}{1}'.format(emailAddressOrUID, addDomain)
  return emailAddressOrUID

def shlexSplitList(entity, dataDelimiter=' ,'):
  import shlex
  lexer = shlex.shlex(entity, posix=True)
  lexer.whitespace = dataDelimiter
  lexer.whitespace_split = True
  return list(lexer)

def convertEntityToList(entity, shlexSplit=False, nonListEntityType=False):
  if not entity:
    return []
  if isinstance(entity, list):
    return entity
  if isinstance(entity, set):
    return list(entity)
  if isinstance(entity, dict):
    return entity.keys()
  if nonListEntityType:
    return [entity,]
  if not shlexSplit:
    return entity.replace(u',', u' ').split()
  return shlexSplitList(entity)

GROUP_ROLES_MAP = {
  u'owner': Entity.ROLE_OWNER,
  u'owners': Entity.ROLE_OWNER,
  u'manager': Entity.ROLE_MANAGER,
  u'managers': Entity.ROLE_MANAGER,
  u'member': Entity.ROLE_MEMBER,
  u'members': Entity.ROLE_MEMBER,
  }

# Turn the entity into a list of Users/CrOS devices
def getUsersToModify(entityType, entity, memberRole=None, checkNotSuspended=False, groupUserMembersOnly=True):
  def _addGroupMembersToUsers(group, domains, recursive):
    doNotExist = 0
    try:
      printGettingAllEntityItemsForWhom(memberRole if memberRole else Entity.ROLE_MANAGER_MEMBER_OWNER, group, entityType=Entity.GROUP)
      page_message = getPageMessageForWhom(noNL=True)
      result = callGAPIpages(cd.members(), u'list', u'members',
                             page_message=page_message,
                             throw_reasons=GAPI_MEMBERS_THROW_REASONS,
                             groupKey=group, roles=memberRole, fields=u'nextPageToken,members(email,type)', maxResults=GC_Values[GC_MEMBER_MAX_RESULTS])
      for member in result:
        if member[u'type'] == u'USER':
          email = member[u'email']
          if domains:
            _, domain = splitEmailAddress(email)
            if domain not in domains:
              continue
          if email not in entitySet:
            entitySet.add(email)
            entityList.append(email)
        elif recursive and member[u'type'] == u'GROUP':
          doNotExist += _addGroupMembersToUsers(member[u'email'], domains, recursive)
    except (GAPI_groupNotFound, GAPI_domainNotFound, GAPI_invalid, GAPI_forbidden):
      entityUnknownWarning(Entity.GROUP, group)
      doNotExist += 1
    return doNotExist

  def _showInvalidEntity(entityType, entityName):
    printErrorMessage(USAGE_ERROR_RC, formatKeyValueList(u'', [Entity.Singular(entityType), entityName, PHRASE_INVALID], u''))

  doNotExist = invalid = 0
  entityList = []
  entitySet = set()
  if entityType in [CL_ENTITY_USER, CL_ENTITY_USERS]:
    buildGAPIObject(DIRECTORY_API)
    result = convertEntityToList(entity, nonListEntityType=entityType == CL_ENTITY_USER)
    for user in result:
      if validateEmailAddressOrUID(user):
        if user not in entitySet:
          entitySet.add(user)
          entityList.append(user)
      else:
        _showInvalidEntity(Entity.USER, user)
        invalid += 1
  elif entityType == CL_ENTITY_ALL_USERS:
    cd = buildGAPIObject(DIRECTORY_API)
    try:
      printGettingAccountEntitiesInfo(Entity.USER)
      page_message = getPageMessage(noNL=True)
      result = callGAPIpages(cd.users(), u'list', u'users',
                             page_message=page_message,
                             throw_reasons=[GAPI_BAD_REQUEST, GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN],
                             customer=GC_Values[GC_CUSTOMER_ID],
                             fields=u'nextPageToken,users(primaryEmail,suspended)',
                             maxResults=GC_Values[GC_USER_MAX_RESULTS])
      for user in result:
        if not user[u'suspended']:
          entityList.append(user[u'primaryEmail'])
      printGettingAccountEntitiesDoneInfo(len(entityList))
    except (GAPI_badRequest, GAPI_resourceNotFound, GAPI_forbidden):
      accessErrorExit(cd)
  elif entityType in [CL_ENTITY_GROUP, CL_ENTITY_GROUPS]:
    cd = buildGAPIObject(DIRECTORY_API)
    groups = convertEntityToList(entity, nonListEntityType=entityType == CL_ENTITY_GROUP)
    for group in groups:
      if validateEmailAddressOrUID(group):
        try:
          group = normalizeEmailAddressOrUID(group)
          printGettingAllEntityItemsForWhom(memberRole if memberRole else Entity.ROLE_MANAGER_MEMBER_OWNER, group, entityType=Entity.GROUP)
          page_message = getPageMessageForWhom(noNL=True)
          result = callGAPIpages(cd.members(), u'list', u'members',
                                 page_message=page_message,
                                 throw_reasons=GAPI_MEMBERS_THROW_REASONS,
                                 groupKey=group, roles=memberRole, fields=u'nextPageToken,members(email,id,type)', maxResults=GC_Values[GC_MEMBER_MAX_RESULTS])
          for member in result:
            email = member.get(u'email', member[u'id'])
            if ((not groupUserMembersOnly) or (member[u'type'] == u'USER')) and email not in entitySet:
              entitySet.add(email)
              entityList.append(email)
        except (GAPI_groupNotFound, GAPI_domainNotFound, GAPI_invalid, GAPI_forbidden):
          entityUnknownWarning(Entity.GROUP, group)
          doNotExist += 1
      else:
        _showInvalidEntity(Entity.GROUP, group)
        invalid += 1
  elif entityType == CL_ENTITY_GROUP_USERS:
    cd = buildGAPIObject(DIRECTORY_API)
    groups = convertEntityToList(entity)
    recursive = False
    domains = []
    roles = []
    while CLArgs.ArgumentsRemaining():
      myarg = getArgument()
      if myarg in GROUP_ROLES_MAP:
        roles.append(GROUP_ROLES_MAP[myarg])
      elif myarg == u'primarydomain':
        domains.append(GC_Values[GC_DOMAIN])
      elif myarg == u'domains':
        domains.extend(getEntityList(OB_DOMAIN_NAME_ENTITY))
      elif myarg == u'recursive':
        recursive = True
      elif myarg == u'end':
        break
      else:
        CLArgs.Backup()
        missingArgumentExit(u'end')
    if roles:
      memberRole = ','.join(roles)
    for group in groups:
      if validateEmailAddressOrUID(group):
        doNotExist += _addGroupMembersToUsers(normalizeEmailAddressOrUID(group), domains, recursive)
      else:
        _showInvalidEntity(Entity.GROUP, group)
        invalid += 1
  elif entityType in [CL_ENTITY_OU, CL_ENTITY_OUS, CL_ENTITY_OU_AND_CHILDREN, CL_ENTITY_OUS_AND_CHILDREN]:
    cd = buildGAPIObject(DIRECTORY_API)
    ous = convertEntityToList(entity, shlexSplit=True, nonListEntityType=entityType in [CL_ENTITY_OU, CL_ENTITY_OU_AND_CHILDREN])
    directlyInOU = entityType in [CL_ENTITY_OU, CL_ENTITY_OUS]
    qualifier = [u'', PHRASE_DIRECTLY_IN_THE.format(Entity.Singular(Entity.ORGANIZATIONAL_UNIT))][directlyInOU]
    prevLen = 0
    for ou in ous:
      try:
        ou = makeOrgUnitPathAbsolute(ou)
        if ou.startswith(u'id:'):
          result = callGAPI(cd.orgunits(), u'get',
                            throw_reasons=[GAPI_BAD_REQUEST, GAPI_INVALID_ORGUNIT, GAPI_ORGUNIT_NOT_FOUND, GAPI_BACKEND_ERROR, GAPI_INVALID_CUSTOMER_ID, GAPI_LOGIN_REQUIRED],
                            customerId=GC_Values[GC_CUSTOMER_ID], orgUnitPath=ou)
          ou = result[u'orgUnitPath']
        printGettingAllEntityItemsForWhom(Entity.USER, ou, entityType=Entity.ORGANIZATIONAL_UNIT)
        page_message = getPageMessageForWhom(noNL=True)
        result = callGAPIpages(cd.users(), u'list', u'users',
                               page_message=page_message,
                               throw_reasons=[GAPI_INVALID_ORGUNIT, GAPI_ORGUNIT_NOT_FOUND, GAPI_BACKEND_ERROR, GAPI_BAD_REQUEST, GAPI_INVALID_INPUT, GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN],
                               customer=GC_Values[GC_CUSTOMER_ID], query=orgUnitPathQuery(ou),
                               fields=u'nextPageToken,users(primaryEmail,suspended,orgUnitPath)',
                               maxResults=GC_Values[GC_USER_MAX_RESULTS])
        if directlyInOU:
          ou = ou.lower()
          for user in result:
            email = user[u'primaryEmail']
            if (ou == user[u'orgUnitPath'].lower()) and (not (checkNotSuspended and user[u'suspended'])):
              entityList.append(email)
        else:
          for user in result:
            email = user[u'primaryEmail']
            if not (checkNotSuspended and user[u'suspended']):
              entityList.append(email)
        totalLen = len(entityList)
        printGettingEntityItemsDoneInfo(totalLen-prevLen, qualifier=qualifier)
        prevLen = totalLen
      except (GAPI_badRequest, GAPI_invalidInput, GAPI_invalidOrgunit, GAPI_orgunitNotFound, GAPI_backendError, GAPI_invalidCustomerId, GAPI_loginRequired, GAPI_resourceNotFound, GAPI_forbidden):
        checkEntityDNEorAccessErrorExit(cd, Entity.ORGANIZATIONAL_UNIT, ou, 0, 0)
        doNotExist += 1
  elif entityType == CL_ENTITY_QUERY:
    cd = buildGAPIObject(DIRECTORY_API)
    try:
      printGettingAccountEntitiesInfo(Entity.USER, queryQualifier(entity))
      page_message = getPageMessage(noNL=True)
      result = callGAPIpages(cd.users(), u'list', u'users',
                             page_message=page_message,
                             throw_reasons=[GAPI_INVALID_INPUT, GAPI_BAD_REQUEST, GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN],
                             customer=GC_Values[GC_CUSTOMER_ID], query=entity,
                             fields=u'nextPageToken,users(primaryEmail,suspended)',
                             maxResults=GC_Values[GC_USER_MAX_RESULTS])
      for user in result:
        if not (checkNotSuspended and user[u'suspended']):
          entityList.append(user[u'primaryEmail'])
      printGettingAccountEntitiesDoneInfo(len(entityList), u' {0}'.format(PHRASE_THAT_MATCHED_QUERY))
    except GAPI_invalidInput:
      CLArgs.Backup()
      usageErrorExit(PHRASE_INVALID_QUERY)
    except (GAPI_badRequest, GAPI_resourceNotFound, GAPI_forbidden):
      accessErrorExit(cd)
  elif entityType == CL_ENTITY_LICENSES:
    entityList = doPrintLicenses(return_list=True, skus=shlexSplitList(entity)).keys()
  elif entityType in [CL_ENTITY_COURSEPARTICIPANTS, CL_ENTITY_TEACHERS, CL_ENTITY_STUDENTS]:
    croom = buildGAPIObject(CLASSROOM_API)
    courses = convertEntityToList(entity)
    for course in courses:
      courseId = addCourseIdScope(course)
      try:
        if entityType in [CL_ENTITY_COURSEPARTICIPANTS, CL_ENTITY_TEACHERS]:
          printGettingAllEntityItemsForWhom(Entity.TEACHER, removeCourseIdScope(courseId), entityType=Entity.COURSE)
          page_message = getPageMessageForWhom(noNL=True)
          result = callGAPIpages(croom.courses().teachers(), u'list', u'teachers',
                                 page_message=page_message,
                                 throw_reasons=[GAPI_NOT_FOUND, GAPI_FORBIDDEN, GAPI_BAD_REQUEST],
                                 courseId=courseId, fields=u'nextPageToken,teachers/profile/emailAddress', pageSize=GC_Values[GC_CLASSROOM_MAX_RESULTS])
          for teacher in result:
            email = teacher[u'profile'].get(u'emailAddress', None)
            if email and (email not in entitySet):
              entitySet.add(email)
              entityList.append(email)
        if entityType in [CL_ENTITY_COURSEPARTICIPANTS, CL_ENTITY_STUDENTS]:
          printGettingAllEntityItemsForWhom(Entity.STUDENT, removeCourseIdScope(courseId), entityType=Entity.COURSE)
          page_message = getPageMessageForWhom(noNL=True)
          result = callGAPIpages(croom.courses().students(), u'list', u'students',
                                 page_message=page_message,
                                 throw_reasons=[GAPI_NOT_FOUND, GAPI_FORBIDDEN, GAPI_BAD_REQUEST],
                                 courseId=courseId, fields=u'nextPageToken,students/profile/emailAddress', pageSize=GC_Values[GC_CLASSROOM_MAX_RESULTS])
          for student in result:
            email = student[u'profile'].get(u'emailAddress', None)
            if email and (email not in entitySet):
              entitySet.add(email)
              entityList.append(email)
      except GAPI_notFound:
        entityDoesNotExistWarning(Entity.COURSE, removeCourseIdScope(courseId))
        doNotExist += 1
      except (GAPI_forbidden, GAPI_badRequest):
        APIAccessDeniedExit()
  elif entityType == CL_ENTITY_CROS:
    buildGAPIObject(DIRECTORY_API)
    result = convertEntityToList(entity)
    for deviceId in result:
      if deviceId not in entitySet:
        entitySet.add(deviceId)
        entityList.append(deviceId)
  elif entityType == CL_ENTITY_ALL_CROS:
    cd = buildGAPIObject(DIRECTORY_API)
    try:
      printGettingAccountEntitiesInfo(Entity.CROS_DEVICE)
      page_message = getPageMessage(noNL=True)
      result = callGAPIpages(cd.chromeosdevices(), u'list', u'chromeosdevices',
                             page_message=page_message,
                             throw_reasons=[GAPI_BAD_REQUEST, GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN],
                             customerId=GC_Values[GC_CUSTOMER_ID],
                             fields=u'nextPageToken,chromeosdevices(deviceId)',
                             maxResults=GC_Values[GC_DEVICE_MAX_RESULTS])
      for device in result:
        entityList.append(device[u'deviceId'])
    except (GAPI_badRequest, GAPI_resourceNotFound, GAPI_forbidden):
      accessErrorExit(cd)
  elif entityType == CL_ENTITY_CROS_QUERY:
    cd = buildGAPIObject(DIRECTORY_API)
    try:
      printGettingAccountEntitiesInfo(Entity.CROS_DEVICE, queryQualifier(entity))
      page_message = getPageMessage(noNL=True)
      result = callGAPIpages(cd.chromeosdevices(), u'list', u'chromeosdevices',
                             page_message=page_message,
                             throw_reasons=[GAPI_INVALID_INPUT, GAPI_BAD_REQUEST, GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN],
                             customerId=GC_Values[GC_CUSTOMER_ID], query=entity,
                             fields=u'nextPageToken,chromeosdevices(deviceId)',
                             maxResults=GC_Values[GC_DEVICE_MAX_RESULTS])
      for device in result:
        entityList.append(device[u'deviceId'])
      printGettingAccountEntitiesDoneInfo(len(entityList), u' {0}'.format(PHRASE_THAT_MATCHED_QUERY))
    except GAPI_invalidInput:
      CLArgs.Backup()
      usageErrorExit(PHRASE_INVALID_QUERY)
    except (GAPI_badRequest, GAPI_resourceNotFound, GAPI_forbidden):
      accessErrorExit(cd)
  elif entityType in [CL_ENTITY_CROS_OU, CL_ENTITY_CROS_OU_AND_CHILDREN, CL_ENTITY_CROS_OUS, CL_ENTITY_CROS_OUS_AND_CHILDREN]:
    cd = buildGAPIObject(DIRECTORY_API)
    ous = convertEntityToList(entity, shlexSplit=True, nonListEntityType=entityType in [CL_ENTITY_CROS_OU, CL_ENTITY_CROS_OU_AND_CHILDREN])
    directlyInOU = entityType in [CL_ENTITY_CROS_OU, CL_ENTITY_CROS_OUS]
    qualifier = [u'', PHRASE_DIRECTLY_IN_THE.format(Entity.Choose(Entity.ORGANIZATIONAL_UNIT, len(ous)))][directlyInOU]
    ouDict = {}
    for ou in ous:
      try:
        ou = makeOrgUnitPathAbsolute(ou)
        if ou.startswith(u'id:'):
          result = callGAPI(cd.orgunits(), u'get',
                            throw_reasons=[GAPI_BAD_REQUEST, GAPI_INVALID_ORGUNIT, GAPI_ORGUNIT_NOT_FOUND, GAPI_BACKEND_ERROR, GAPI_INVALID_CUSTOMER_ID, GAPI_LOGIN_REQUIRED],
                            customerId=GC_Values[GC_CUSTOMER_ID], orgUnitPath=ou)
          ou = result[u'orgUnitPath']
        ouDict[ou.lower()] = True
      except (GAPI_badRequest, GAPI_invalidOrgunit, GAPI_orgunitNotFound, GAPI_backendError, GAPI_invalidCustomerId, GAPI_loginRequired, GAPI_resourceNotFound, GAPI_forbidden):
        checkEntityDNEorAccessErrorExit(cd, Entity.ORGANIZATIONAL_UNIT, ou, 0, 0)
        doNotExist += 1
    try:
      printGettingAccountEntitiesInfo(Entity.CROS_DEVICE)
      page_message = getPageMessage(noNL=True)
      result = callGAPIpages(cd.chromeosdevices(), u'list', u'chromeosdevices',
                             page_message=page_message,
                             throw_reasons=[GAPI_BAD_REQUEST, GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN],
                             customerId=GC_Values[GC_CUSTOMER_ID],
                             fields=u'nextPageToken,chromeosdevices(deviceId,orgUnitPath)',
                             maxResults=GC_Values[GC_DEVICE_MAX_RESULTS])
      if directlyInOU:
        for device in result:
          if device[u'orgUnitPath'].lower() in ouDict:
            entityList.append(device[u'deviceId'])
      else:
        for device in result:
          deviceOu = device[u'orgUnitPath'].lower()
          for ou in ouDict:
            if deviceOu.startswith(ou):
              entityList.append(device[u'deviceId'])
              break
      printGettingEntityItemsDoneInfo(len(entityList), qualifier=qualifier)
    except (GAPI_badRequest, GAPI_resourceNotFound, GAPI_forbidden):
      accessErrorExit(cd)
  else:
    systemErrorExit(UNKNOWN_ERROR_RC, u'getUsersToModify coding error')
  if doNotExist == 0 and invalid == 0:
    return entityList
  if doNotExist > 0:
    badEntitiesExit(Entity.ENTITY, doNotExist, [PHRASE_DO_NOT_EXIST, PHRASE_DOES_NOT_EXIST], backupArg=True)
  if invalid > 0:
    badEntitiesExit(Entity.ENTITY, invalid, [PHRASE_INVALID, PHRASE_INVALID], backupArg=True)

def splitEntityList(entity, dataDelimiter, shlexSplit):
  if not entity:
    return []
  if not dataDelimiter:
    return [entity,]
  if not shlexSplit:
    return entity.split(dataDelimiter)
  return shlexSplitList(entity, dataDelimiter)

# <FileName> [charset <String>] [delimiter <String>]
def getEntitiesFromFile(shlexSplit):
  filename = getString(OB_FILE_NAME)
  encoding = getCharSet()
  dataDelimiter = getDelimiter(True)
  entitySet = set()
  entityList = []
  f = openFile(filename)
  uf = UTF8Recoder(f, encoding) if encoding != u'utf-8' else f
  for row in uf:
    for item in splitEntityList(row.strip(), dataDelimiter, shlexSplit):
      item = item.strip()
      if item and (item not in entitySet):
        entitySet.add(item)
        entityList.append(item)
  closeFile(f)
  return entityList

# <FileName>(:<FieldName>)+ [charset <String>] [columndelimiter <String>] [fields <FieldNameList>] (matchfield <FieldName> <RegularExpression>)* [delimiter <String>]
def getEntitiesFromCSVFile(shlexSplit):
  try:
    fileFieldNameList = getString(OB_FILE_NAME_FIELD_NAME).split(u':')
  except ValueError:
    fileFieldNameList = []
  if len(fileFieldNameList) < 2:
    CLArgs.Backup()
    invalidArgumentExit(OB_FILE_NAME_FIELD_NAME)
  f, csvFile = openCSVFileReader(fileFieldNameList[0])
  for fieldName in fileFieldNameList[1:]:
    if fieldName not in csvFile.fieldnames:
      csvFieldErrorExit(fieldName, csvFile.fieldnames, backupArg=True, checkForCharset=True)
  matchFields = getMatchFields(csvFile.fieldnames)
  dataDelimiter = getDelimiter(True)
  entitySet = set()
  entityList = []
  for row in csvFile:
    if not matchFields or checkMatchFields(row, matchFields):
      for fieldName in fileFieldNameList[1:]:
        for item in splitEntityList(row[fieldName].strip(), dataDelimiter, shlexSplit):
          item = item.strip()
          if item and (item not in entitySet):
            entitySet.add(item)
            entityList.append(item)
  closeFile(f)
  return entityList

# <FileName> [charset <String>] [columndelimiter <String>] [fields <FieldNameList>]
#	keyfield <FieldName> [keypattern <RegularExpression>] [keyvalue <String>] [delimiter <String>]
#	subkeyfield <FieldName> [keypattern <RegularExpression>] [keyvalue <String>] [delimiter <String>]
#	(matchfield <FieldName> <RegularExpression>)*
#	[datafield <FieldName>(:<FieldName>)* [delimiter <String>]]
def getEntitiesFromCSVbyField():

  def getKeyFieldInfo(keyword, required, globalKeyField):
    if not checkArgumentPresent([keyword], required=required):
      GM_Globals[globalKeyField] = None
      return (None, None, None, None)
    keyField = GM_Globals[globalKeyField] = getString(OB_FIELD_NAME)
    if keyField not in csvFile.fieldnames:
      csvFieldErrorExit(keyField, csvFile.fieldnames, backupArg=True)
    if checkArgumentPresent([u'keypattern',]):
      keyPattern = getREPattern()
    else:
      keyPattern = None
    if checkArgumentPresent([u'keyvalue',]):
      keyValue = getString(OB_STRING)
    else:
      keyValue = keyField
    keyDelimiter = getDelimiter(True)
    return (keyField, keyPattern, keyValue, keyDelimiter)

  def getKeyList(row, keyField, keyPattern, keyValue, keyDelimiter, matchFields):
    item = row[keyField].strip()
    if not item:
      return []
    if matchFields and not checkMatchFields(row, matchFields):
      return []
    if keyPattern:
      keyList = [keyPattern.sub(keyValue, keyItem.strip()) for keyItem in splitEntityList(item, keyDelimiter, False)]
    else:
      keyList = [re.sub(keyField, keyItem.strip(), keyValue) for keyItem in splitEntityList(item, keyDelimiter, False)]
    return [key for key in keyList if key]

  filename = getString(OB_FILE_NAME)
  f, csvFile = openCSVFileReader(filename)
  mainKeyField, mainKeyPattern, mainKeyValue, mainKeyDelimiter = getKeyFieldInfo(u'keyfield', True, GM_CSV_KEY_FIELD)
  subKeyField, subKeyPattern, subKeyValue, subKeyDelimiter = getKeyFieldInfo(u'subkeyfield', False, GM_CSV_SUBKEY_FIELD)
  matchFields = getMatchFields(csvFile.fieldnames)
  if checkArgumentPresent([u'datafield',]):
    if GM_Globals[GM_CSV_DATA_DICT]:
      csvDataAlreadySavedErrorExit()
    GM_Globals[GM_CSV_DATA_FIELD] = getString(OB_FIELD_NAME, checkBlank=True)
    dataFields = GM_Globals[GM_CSV_DATA_FIELD].split(u':')
    for dataField in dataFields:
      if dataField not in csvFile.fieldnames:
        csvFieldErrorExit(dataField, csvFile.fieldnames, backupArg=True)
    dataDelimiter = getDelimiter(True)
  else:
    GM_Globals[GM_CSV_DATA_FIELD] = None
    dataFields = []
    dataDelimiter = None
  entitySet = set()
  entityList = []
  csvDataKeys = {}
  GM_Globals[GM_CSV_DATA_DICT] = {}
  if not subKeyField:
    for row in csvFile:
      mainKeyList = getKeyList(row, mainKeyField, mainKeyPattern, mainKeyValue, mainKeyDelimiter, matchFields)
      if not mainKeyList:
        continue
      for mainKey in mainKeyList:
        if mainKey not in entitySet:
          entitySet.add(mainKey)
          entityList.append(mainKey)
          if GM_Globals[GM_CSV_DATA_FIELD]:
            csvDataKeys[mainKey] = set()
            GM_Globals[GM_CSV_DATA_DICT][mainKey] = []
      for dataField in dataFields:
        if dataField in row:
          dataList = splitEntityList(row[dataField].strip(), dataDelimiter, False)
          for dataValue in dataList:
            dataValue = dataValue.strip()
            if not dataValue:
              continue
            for mainKey in mainKeyList:
              if dataValue not in csvDataKeys[mainKey]:
                csvDataKeys[mainKey].add(dataValue)
                GM_Globals[GM_CSV_DATA_DICT][mainKey].append(dataValue)
  else:
    csvSubKeys = {}
    for row in csvFile:
      mainKeyList = getKeyList(row, mainKeyField, mainKeyPattern, mainKeyValue, mainKeyDelimiter, matchFields)
      if not mainKeyList:
        continue
      for mainKey in mainKeyList:
        if mainKey not in entitySet:
          entitySet.add(mainKey)
          entityList.append(mainKey)
          csvSubKeys[mainKey] = set()
          csvDataKeys[mainKey] = {}
          GM_Globals[GM_CSV_DATA_DICT][mainKey] = {}
      subKeyList = getKeyList(row, subKeyField, subKeyPattern, subKeyValue, subKeyDelimiter, {})
      if not subKeyList:
        continue
      for mainKey in mainKeyList:
        for subKey in subKeyList:
          if subKey not in csvSubKeys[mainKey]:
            csvSubKeys[mainKey].add(subKey)
            if GM_Globals[GM_CSV_DATA_FIELD]:
              csvDataKeys[mainKey][subKey] = set()
              GM_Globals[GM_CSV_DATA_DICT][mainKey][subKey] = []
      for dataField in dataFields:
        if dataField in row:
          dataList = splitEntityList(row[dataField].strip(), dataDelimiter, False)
          for dataValue in dataList:
            dataValue = dataValue.strip()
            if not dataValue:
              continue
            for mainKey in mainKeyList:
              for subKey in subKeyList:
                if dataValue not in csvDataKeys[mainKey][subKey]:
                  csvDataKeys[mainKey][subKey].add(dataValue)
                  GM_Globals[GM_CSV_DATA_DICT][mainKey][subKey].append(dataValue)
  closeFile(f)
  return entityList

# Typically used to map courseparticipants to students or teachers
def mapEntityType(entityType, typeMap):
  if (typeMap is not None) and (entityType in typeMap):
    return typeMap[entityType]
  return entityType

def getEntityArgument(entityList):
  if entityList is None:
    return (0, 0, entityList)
  if isinstance(entityList, dict):
    clLoc = CLArgs.Location()
    CLArgs.SetLocation(GM_Globals[GM_ENTITY_CL_DELAY_START])
    entityList = getUsersToModify(**entityList)
    CLArgs.SetLocation(clLoc)
  return (0, len(entityList), entityList)

def getEntityToModify(defaultEntityType=None, returnOnError=False, crosAllowed=False, userAllowed=True, typeMap=None, checkNotSuspended=False, groupUserMembersOnly=True, delayGet=False):
  selectorChoices = CL_ENTITY_SELECTORS[:]
  if userAllowed:
    selectorChoices += CL_CSVDATA_ENTITY_SELECTORS
  if crosAllowed:
    selectorChoices += CL_CROS_ENTITY_SELECTORS+CL_CSVCROS_ENTITY_SELECTORS
  entitySelector = getChoice(selectorChoices, defaultChoice=None)
  if entitySelector:
    choices = []
    if entitySelector == CL_ENTITY_SELECTOR_ALL:
      if userAllowed:
        choices += CL_USER_ENTITY_SELECTOR_ALL_SUBTYPES
      if crosAllowed:
        choices += CL_CROS_ENTITY_SELECTOR_ALL_SUBTYPES
      entityType = CL_ENTITY_SELECTOR_ALL_SUBTYPES_MAP[getChoice(choices)]
      if not delayGet:
        return ([CL_ENTITY_CROS, CL_ENTITY_USERS][entityType == CL_ENTITY_ALL_USERS],
                getUsersToModify(entityType, None))
      else:
        GM_Globals[GM_ENTITY_CL_DELAY_START] = CLArgs.Location()
        buildGAPIObject(DIRECTORY_API)
        return ([CL_ENTITY_CROS, CL_ENTITY_USERS][entityType == CL_ENTITY_ALL_USERS],
                {u'entityType': entityType, u'entity': None})
    if userAllowed:
      if entitySelector == CL_ENTITY_SELECTOR_FILE:
        return (CL_ENTITY_USERS,
                getUsersToModify(CL_ENTITY_USERS, getEntitiesFromFile(False)))
      if entitySelector in [CL_ENTITY_SELECTOR_CSV, CL_ENTITY_SELECTOR_CSVFILE]:
        return (CL_ENTITY_USERS,
                getUsersToModify(CL_ENTITY_USERS, getEntitiesFromCSVFile(False)))
    if crosAllowed:
      if entitySelector == CL_ENTITY_SELECTOR_CROSFILE:
        return (CL_ENTITY_CROS,
                getUsersToModify(CL_ENTITY_CROS, getEntitiesFromFile(False)))
      if entitySelector in [CL_ENTITY_SELECTOR_CROSCSV, CL_ENTITY_SELECTOR_CROSCSVFILE]:
        return (CL_ENTITY_CROS,
                getUsersToModify(CL_ENTITY_CROS, getEntitiesFromCSVFile(False)))
    if entitySelector == CL_ENTITY_SELECTOR_DATAFILE:
      if userAllowed:
        choices += CL_USER_ENTITY_SELECTOR_DATAFILE_CSVKMD_SUBTYPES
      if crosAllowed:
        choices += CL_CROS_ENTITY_SELECTOR_DATAFILE_CSVKMD_SUBTYPES
      entityType = mapEntityType(getChoice(choices), typeMap)
      return ([CL_ENTITY_CROS, CL_ENTITY_USERS][entityType not in [CL_ENTITY_CROS, CL_ENTITY_CROS_OUS, CL_ENTITY_CROS_OUS_AND_CHILDREN]],
              getUsersToModify(entityType, getEntitiesFromFile(shlexSplit=entityType in [CL_ENTITY_OUS, CL_ENTITY_OUS_AND_CHILDREN, CL_ENTITY_CROS_OUS, CL_ENTITY_CROS_OUS_AND_CHILDREN])))
    if entitySelector == CL_ENTITY_SELECTOR_CSVKMD:
      if userAllowed:
        choices += CL_USER_ENTITY_SELECTOR_DATAFILE_CSVKMD_SUBTYPES
      if crosAllowed:
        choices += CL_CROS_ENTITY_SELECTOR_DATAFILE_CSVKMD_SUBTYPES
      entityType = mapEntityType(getChoice(choices, choiceAliases=CL_ENTITY_ALIAS_MAP), typeMap)
      return ([CL_ENTITY_CROS, CL_ENTITY_USERS][entityType != CL_ENTITY_CROS],
              getUsersToModify(entityType, getEntitiesFromCSVbyField()))
    if entitySelector in [CL_ENTITY_SELECTOR_CSVDATA, CL_ENTITY_SELECTOR_CSVCROS]:
      checkDataField()
      return ([CL_ENTITY_CROS, CL_ENTITY_USERS][entitySelector == CL_ENTITY_SELECTOR_CSVDATA],
              GM_Globals[GM_CSV_DATA_DICT])
  entityChoices = []
  if userAllowed:
    entityChoices += CL_USER_ENTITIES
  if crosAllowed:
    entityChoices += CL_CROS_ENTITIES
  entityType = mapEntityType(getChoice(entityChoices, choiceAliases=CL_ENTITY_ALIAS_MAP, defaultChoice=defaultEntityType), typeMap)
  if entityType:
    if entityType not in CL_CROS_ENTITIES:
      entityClass = CL_ENTITY_USERS
      entityItem = getString(OB_USER_ENTITY, minLen=0)
    else:
      entityClass = CL_ENTITY_CROS
      entityItem = getString(OB_CROS_ENTITY, minLen=0)
    if not delayGet:
      if entityClass == CL_ENTITY_USERS:
        return (entityClass,
                getUsersToModify(entityType, entityItem, checkNotSuspended=checkNotSuspended, groupUserMembersOnly=groupUserMembersOnly))
      else:
        return (entityClass,
                getUsersToModify(entityType, entityItem))
    else:
      GM_Globals[GM_ENTITY_CL_DELAY_START] = CLArgs.Location()
      buildGAPIObject(DIRECTORY_API)
      if entityClass == CL_ENTITY_USERS:
        if entityType == CL_ENTITY_GROUP_USERS:
          # Skip over sub-arguments
          while CLArgs.ArgumentsRemaining():
            myarg = getArgument()
            if myarg in GROUP_ROLES_MAP or myarg in [u'primarydomain', u'domains', u'recursive']:
              pass
            elif myarg == u'end':
              break
            else:
              CLArgs.Backup()
              missingArgumentExit(u'end')
        return (entityClass,
                {u'entityType': entityType, u'entity': entityItem, u'checkNotSuspended': checkNotSuspended, u'groupUserMembersOnly': groupUserMembersOnly})
      else:
        return (entityClass,
                {u'entityType': entityType, u'entity': entityItem})
  if returnOnError:
    return (None, None)
  invalidChoiceExit(selectorChoices+entityChoices)

def getEntitySelector():
  selectorChoices = CL_ENTITY_SELECTORS[:]
  selectorChoices.remove(CL_ENTITY_SELECTOR_ALL)
  selectorChoices.remove(CL_ENTITY_SELECTOR_DATAFILE)
  selectorChoices += CL_CSVDATA_ENTITY_SELECTORS
  return getChoice(selectorChoices, defaultChoice=None)

def getEntitySelection(entitySelector, shlexSplit):
  if entitySelector in [CL_ENTITY_SELECTOR_FILE]:
    return getEntitiesFromFile(shlexSplit)
  if entitySelector in [CL_ENTITY_SELECTOR_CSV, CL_ENTITY_SELECTOR_CSVFILE]:
    return getEntitiesFromCSVFile(shlexSplit)
  if entitySelector == CL_ENTITY_SELECTOR_CSVKMD:
    return getEntitiesFromCSVbyField()
  if entitySelector in [CL_ENTITY_SELECTOR_CSVSUBKEY]:
    checkSubkeyField()
    return GM_Globals[GM_CSV_DATA_DICT]
  if entitySelector in [CL_ENTITY_SELECTOR_CSVDATA]:
    checkDataField()
    return GM_Globals[GM_CSV_DATA_DICT]
  return []

def getEntityList(item, shlexSplit=False):
  entitySelector = getEntitySelector()
  if entitySelector:
    return getEntitySelection(entitySelector, shlexSplit)
  return convertEntityToList(getString(item, minLen=0), shlexSplit=shlexSplit)

def getUserObjectEntity(clObject, itemType):
  entity = {u'item': itemType, u'list': getEntityList(clObject), u'dict': None}
  if isinstance(entity[u'list'], dict):
    entity[u'dict'] = entity[u'list']
  return entity

def _validateUserGetObjectList(user, i, count, entity):
  if entity[u'dict']:
    entityList = entity[u'dict'][user]
  else:
    entityList = entity[u'list']
  user, gmail = buildGAPIServiceObject(GMAIL_API, user)
  if not gmail:
    return (user, None, [], 0)
  jcount = len(entityList)
  entityPerformActionNumItems([Entity.USER, user], jcount, entity[u'item'], i, count)
  if jcount == 0:
    setSysExitRC(NO_ENTITIES_FOUND)
  return (user, gmail, entityList, jcount)

def _validateUserGetMessageIds(user, entity):
  if entity:
    if entity[u'dict']:
      entityList = entity[u'dict'][user]
    else:
      entityList = entity[u'list']
  else:
    entityList = []
  user, gmail = buildGAPIServiceObject(GMAIL_API, user)
  if not gmail:
    return (user, None, None)
  return (user, gmail, entityList)

def _validateDelegatorGetObjectList(user, i, count, entity):
  if entity[u'dict']:
    entityList = entity[u'dict'][user]
  else:
    entityList = entity[u'list']
  jcount = len(entityList)
  delegatorEmail, delegatorName, delegatorDomain = splitEmailAddressOrUID(user)
  entityPerformActionNumItems([Entity.DELEGATOR, delegatorEmail], jcount, entity[u'item'], i, count)
  if jcount == 0:
    setSysExitRC(NO_ENTITIES_FOUND)
  return (delegatorEmail, delegatorName, delegatorDomain, entityList, jcount)

def getTodriveParameters():
  def invalidTodriveDestExit(entityType, message):
    CLArgs.ResetLocation(-1)
    if not localParent:
      usageErrorExit(PHRASE_INVALID_ENTITY_MESSAGE.format(Entity.Singular(entityType),
                                                          formatKeyValueList(u'',
                                                                             [Entity.Singular(Entity.CONFIG_FILE), GM_Globals[GM_GAM_CFG_FILE],
                                                                              Entity.Singular(Entity.ITEM), GC_TODRIVE_PARENT,
                                                                              Entity.Singular(Entity.VALUE), todrive[u'parent'],
                                                                              message],
                                                                             u'')))
    else:
      usageErrorExit(PHRASE_INVALID_ENTITY_MESSAGE.format(Entity.Singular(entityType), message))

  localParent = False
  CLArgs.SaveLocation()
  todrive = {u'title': None, u'parent': GC_Values[GC_TODRIVE_PARENT], u'timestamp': GC_Values[GC_TODRIVE_TIMESTAMP], u'daysoffset': 0, u'hoursoffset': 0}
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'tdtitle':
      todrive[u'title'] = getString(OB_STRING)
    elif myarg == u'tdparent':
      todrive[u'parent'] = getString(OB_DRIVE_FOLDER_NAME)
      CLArgs.SaveLocation()
      localParent = True
    elif myarg == u'tdtimestamp':
      todrive[u'timestamp'] = getBoolean()
    elif myarg == u'tddaysoffset':
      todrive[u'daysoffset'] = getInteger(minVal=0)
    elif myarg == u'tdhoursoffset':
      todrive[u'hoursoffset'] = getInteger(minVal=0)
    else:
      CLArgs.Backup()
      break
  if todrive[u'parent'] == u'root':
    todrive[u'parentId'] = u'root'
  else:
    drive = buildGAPIObject(DRIVE_API)
    if todrive[u'parent'].startswith(u'id:'):
      try:
        result = callGAPI(drive.files(), u'get',
                          throw_reasons=[GAPI_FILE_NOT_FOUND],
                          fileId=todrive[u'parent'][3:], fields=u'id,mimeType')
        if result[u'mimeType'] != MIMETYPE_GA_FOLDER:
          invalidTodriveDestExit(Entity.DRIVE_FOLDER_ID, PHRASE_NOT_AN_ENTITY.format(Entity.Singular(Entity.DRIVE_FOLDER)))
        todrive[u'parentId'] = result[u'id']
      except GAPI_fileNotFound:
        invalidTodriveDestExit(Entity.DRIVE_FOLDER_ID, PHRASE_NOT_FOUND)
    else:
      try:
        results = callGAPIpages(drive.files(), u'list', DRIVE_FILES_LIST,
                                throw_reasons=[GAPI_INVALID_QUERY],
                                q=u"{0} = '{1}'".format(DRIVE_FILE_NAME, todrive[u'parent']), fields=u'nextPageToken,{0}(id,mimeType)'.format(DRIVE_FILES_LIST), maxResults=1)
        if not results:
          invalidTodriveDestExit(Entity.DRIVE_FOLDER_NAME, PHRASE_NOT_FOUND)
        if results[0][u'mimeType'] != MIMETYPE_GA_FOLDER:
          invalidTodriveDestExit(Entity.DRIVE_FOLDER_NAME, PHRASE_NOT_AN_ENTITY.format(Entity.Singular(Entity.DRIVE_FOLDER)))
        todrive[u'parentId'] = results[0][u'id']
      except GAPI_invalidQuery:
        invalidTodriveDestExit(Entity.DRIVE_FOLDER_NAME, PHRASE_NOT_FOUND)
  return todrive

# Send an email
def send_email(msg_subj, msg_txt, msg_rcpt=None):
  from email.mime.text import MIMEText
  gmail = buildGAPIObject(GMAIL_API)
  sender_email = gmail._http.request.credentials.id_token[u'email']
  if not msg_rcpt:
    msg_rcpt = sender_email
  msg = MIMEText(msg_txt)
  msg[u'Subject'] = msg_subj
  msg[u'From'] = sender_email
  msg[u'To'] = msg_rcpt
  callGAPI(gmail.users().messages(), u'send',
           userId=sender_email, body={u'raw': base64.urlsafe_b64encode(msg.as_string())}, fields=u'')

# Write a CSV file
def addTitleToCSVfile(title, titles):
  titles[u'set'].add(title)
  titles[u'list'].append(title)

def addTitlesToCSVfile(addTitles, titles):
  for title in addTitles:
    if title not in titles[u'set']:
      addTitleToCSVfile(title, titles)

def removeTitlesFromCSVfile(removeTitles, titles):
  for title in removeTitles:
    if title in titles[u'set']:
      titles[u'set'].remove(title)
      titles[u'list'].remove(title)

def addRowTitlesToCSVfile(row, csvRows, titles):
  csvRows.append(row)
  for title in row:
    if title not in titles[u'set']:
      addTitleToCSVfile(title, titles)

# fieldName is command line argument
# fieldNameMap maps fieldName to API field names; CSV file header will be API field name
#ARGUMENT_TO_PROPERTY_MAP = {
#  u'admincreated': [u'adminCreated'],
#  u'aliases': [u'aliases', u'nonEditableAliases'],
#  }
# fieldsList is the list of API fields
# fieldsTitles maps the API field name to the CSV file header
def addFieldToCSVfile(fieldName, fieldNameMap, fieldsList, fieldsTitles, titles):
  for ftList in fieldNameMap[fieldName]:
    if ftList not in fieldsTitles:
      fieldsList.append(ftList)
      fieldsTitles[ftList] = ftList
      addTitlesToCSVfile([ftList], titles)

# fieldName is command line argument
# fieldNameTitleMap maps fieldName to API field name and CSV file header
#ARGUMENT_TO_PROPERTY_TITLE_MAP = {
#  u'admincreated': [u'adminCreated', u'Admin_Created'],
#  u'aliases': [u'aliases', u'Aliases', u'nonEditableAliases', u'NonEditableAliases'],
#  }
# fieldsList is the list of API fields
# fieldsTitles maps the API field name to the CSV file header
def addFieldTitleToCSVfile(fieldName, fieldNameTitleMap, fieldsList, fieldsTitles, titles):
  ftList = fieldNameTitleMap[fieldName]
  for i in range(0, len(ftList), 2):
    if ftList[i] not in fieldsTitles:
      fieldsList.append(ftList[i])
      fieldsTitles[ftList[i]] = ftList[i+1]
      addTitlesToCSVfile([ftList[i+1]], titles)

def initializeTitlesCSVfile(baseTitles):
  titles = {u'set': set(), u'list': []}
  csvRows = []
  if baseTitles is not None:
    addTitlesToCSVfile(baseTitles, titles)
  return (titles, csvRows)

def sortCSVTitles(firstTitle, titles):
  restoreTitles = []
  for title in firstTitle:
    if title in titles[u'set']:
      titles[u'list'].remove(title)
      restoreTitles.append(title)
  titles[u'list'].sort()
  for title in restoreTitles[::-1]:
    titles[u'list'].insert(0, title)

def writeCSVfile(csvRows, titles, list_type, todrive):
  if GM_Globals[GM_CSVFILE][GM_REDIRECT_QUEUE] is not None:
    GM_Globals[GM_CSVFILE][GM_REDIRECT_QUEUE].put((REDIRECT_QUEUE_NAME, list_type))
    GM_Globals[GM_CSVFILE][GM_REDIRECT_QUEUE].put((REDIRECT_QUEUE_TODRIVE, todrive))
    GM_Globals[GM_CSVFILE][GM_REDIRECT_QUEUE].put((REDIRECT_QUEUE_TITLES, titles[u'list']))
    GM_Globals[GM_CSVFILE][GM_REDIRECT_QUEUE].put((REDIRECT_QUEUE_DATA, csvRows))
    return
  csv.register_dialect(u'nixstdout', lineterminator=u'\n' if todrive or not GM_Globals[GM_WINDOWS] else u'\r\n')
  redirectCSVtoMultiprocessStdout = False
  if not todrive and GM_Globals[GM_CSVFILE][GM_REDIRECT_NAME] == u'-':
    if GM_Globals[GM_STDOUT][GM_REDIRECT_MULTI_FD]:
      redirectCSVtoMultiprocessStdout = True
    else:
      GM_Globals[GM_CSVFILE][GM_REDIRECT_NAME] = GM_Globals[GM_STDOUT][GM_REDIRECT_NAME]
  if todrive or redirectCSVtoMultiprocessStdout:
    csvFile = StringIO.StringIO()
  else:
    csvFile = openFile(GM_Globals[GM_CSVFILE][GM_REDIRECT_NAME], GM_Globals[GM_CSVFILE][GM_REDIRECT_MODE])
  if todrive:
    writer = csv.DictWriter(csvFile, fieldnames=titles[u'list'],
                            dialect=u'nixstdout',
                            quoting=csv.QUOTE_MINIMAL, delimiter=str(GM_Globals[GM_CSVFILE][GM_REDIRECT_COLUMN_DELIMITER]))
  else:
    writer = UnicodeDictWriter(csvFile, fieldnames=titles[u'list'],
                               dialect=u'nixstdout', encoding=GM_Globals[GM_CSVFILE][GM_REDIRECT_ENCODING],
                               quoting=csv.QUOTE_MINIMAL, delimiter=str(GM_Globals[GM_CSVFILE][GM_REDIRECT_COLUMN_DELIMITER]))
  try:
    if GM_Globals[GM_CSVFILE][GM_REDIRECT_WRITE_HEADER]:
      writer.writerow(dict((item, item) for item in writer.fieldnames))
      if GM_Globals[GM_CSVFILE][GM_REDIRECT_MODE] == u'ab':
        GM_Globals[GM_CSVFILE][GM_REDIRECT_WRITE_HEADER] = False
    writer.writerows(csvRows)
  except IOError as e:
    systemErrorExit(FILE_ERROR_RC, e)
  if redirectCSVtoMultiprocessStdout:
    try:
      GM_Globals[GM_STDOUT][GM_REDIRECT_MULTI_FD].write(csvFile.getvalue())
    except IOError as e:
      systemErrorExit(FILE_ERROR_RC, e)
    csvFile.close()
    return
  if todrive:
    if GC_Values[GC_TODRIVE_CONVERSION]:
      columns = len(titles[u'list'])
      rows = len(csvRows)
      cell_count = rows * columns
      if cell_count > 500000 or columns > 256:
        printKeyValueList([WARNING, MESSAGE_RESULTS_TOO_LARGE_FOR_GOOGLE_SPREADSHEET])
        convert = False
      else:
        convert = True
    else:
      convert = False
    title = todrive[u'title'] or u'{0} - {1}'.format(GC_Values[GC_DOMAIN], list_type)
    if todrive[u'timestamp']:
      timestamp = datetime.datetime.now(GC_Values[GC_TIMEZONE])+datetime.timedelta(days=-todrive[u'daysoffset'], hours=-todrive[u'hoursoffset'])
      title += u' - '+timestamp.isoformat()
    drive = buildGAPIObject(DRIVE_API)
    try:
      result = callGAPI(drive.files(), DRIVE_CREATE_FILE,
                        throw_reasons=[GAPI_INSUFFICIENT_PERMISSIONS, GAPI_FILE_NOT_FOUND],
                        convert=convert, body={u'parents': [{u'id': todrive[u'parentId']}], u'description': u' '.join(CLArgs.AllArguments()), DRIVE_FILE_NAME: title, u'mimeType': u'text/csv'},
                        media_body=googleapiclient.http.MediaIoBaseUpload(csvFile, mimetype=u'text/csv', resumable=True), fields=DRIVE_FILE_VIEW_LINK)
      file_url = result[DRIVE_FILE_VIEW_LINK]
      if GC_Values[GC_NO_BROWSER]:
        msg_txt = u'{0}:\n{1}'.format(PHRASE_DATA_UPLOADED_TO_DRIVE_FILE, file_url)
        send_email(title, msg_txt)
        printKeyValueList([msg_txt])
      else:
        import webbrowser
        webbrowser.open(file_url)
    except GAPI_insufficientPermissions:
      printWarningMessage(INSUFFICIENT_PERMISSIONS_RC, MESSAGE_INSUFFICIENT_PERMISSIONS_TO_PERFORM_TASK)
    except GAPI_fileNotFound:
      entityActionFailedWarning([Entity.DRIVE_FOLDER, todrive[u'parentId']], PHRASE_DOES_NOT_EXIST, 0, 0)
  if GM_Globals[GM_CSVFILE][GM_REDIRECT_NAME] != u'-':
    closeFile(csvFile)

def convertCRsNLs(value):
  return value.replace(u'\r', u'\\r').replace(u'\n', u'\\n')

# Flatten a JSON object
def flattenJSON(structure, key=u'', path=u'', flattened=None, listLimit=None, time_objects=None):
  if flattened is None:
    flattened = {}
  if time_objects is None:
    time_objects = []
  if not isinstance(structure, (dict, list, collections.deque)):
    if key not in time_objects:
      if isinstance(structure, (str, unicode)) and GC_Values[GC_CSV_OUTPUT_CONVERT_CR_NL]:
        flattened[((path+u'.') if path else u'')+key] = convertCRsNLs(structure)
      else:
        flattened[((path+u'.') if path else u'')+key] = structure
    else:
      flattened[((path+u'.') if path else u'')+key] = formatLocalTime(structure)
  elif isinstance(structure, (list, collections.deque)):
    listLen = len(structure)
    listLen = min(listLen, listLimit or listLen)
    flattened[((path+u'.') if path else u'')+key] = listLen
    for i in xrange(listLen):
      flattenJSON(structure[i], u'{0}'.format(i), u'.'.join([item for item in [path, key] if item]), flattened, listLimit, time_objects)
  else:
    for new_key, value in structure.items():
      if new_key in [u'kind', u'etag']:
        continue
      flattenJSON(value, new_key, u'.'.join([item for item in [path, key] if item]), flattened, listLimit, time_objects)
  return flattened

# Show a json object
def showJSON(object_name, object_value, skip_objects=None, time_objects=None, level=0):
  if skip_objects is None:
    skip_objects = []
  if time_objects is None:
    time_objects = []
  if object_name in [u'kind', u'etag', u'etags'] or object_name in skip_objects:
    return
  if object_name is not None:
    printJSONKey(object_name)
  if isinstance(object_value, list):
    if len(object_value) == 1 and isinstance(object_value[0], (str, unicode, int, bool)):
      if object_name is not None:
        printJSONValue(object_value[0])
      else:
        printKeyValueList([object_value[0]])
      return
    if object_name is not None:
      printBlankLine()
      Indent.Increment()
    for sub_value in object_value:
      if isinstance(sub_value, (str, unicode, int, bool)):
        printKeyValueList([sub_value])
      else:
        showJSON(None, sub_value, skip_objects, time_objects, level+1)
    if object_name is not None:
      Indent.Decrement()
  elif isinstance(object_value, dict):
    indentAfterFirst = unindentAfterLast = False
    if object_name is not None:
      printBlankLine()
      Indent.Increment()
    elif level > 0:
      indentAfterFirst = unindentAfterLast = True
    for sub_object in sorted(object_value):
      if sub_object not in skip_objects:
        showJSON(sub_object, object_value[sub_object], skip_objects, time_objects, level+1)
        if indentAfterFirst:
          Indent.Increment()
          indentAfterFirst = False
    if object_name is not None or unindentAfterLast:
      Indent.Decrement()
  else:
    if object_name not in time_objects:
      if isinstance(object_value, (str, unicode)) and object_value.find(u'\n') >= 0:
        if GC_Values[GC_SHOW_CONVERT_CR_NL]:
          printJSONValue(convertCRsNLs(object_value))
        else:
          printBlankLine()
          Indent.Increment()
          printKeyValueList([Indent.MultiLineText(object_value)])
          Indent.Decrement()
      else:
        printJSONValue(object_value)
    else:
      printJSONValue(formatLocalTime(object_value))

# Batch processing request_id fields
RI_ENTITY = 0
RI_I = 1
RI_COUNT = 2
RI_J = 3
RI_JCOUNT = 4
RI_ITEM = 5
RI_ROLE = 6

def batchRequestID(entityName, i, count, j, jcount, item, role=u''):
  return u'{0}\n{1}\n{2}\n{3}\n{4}\n{5}\n{6}'.format(entityName, i, count, j, jcount, item, role)

# gam version
def doVersion(checkForArgs=True):
  forceCheck = simple = False
  if checkForArgs:
    while CLArgs.ArgumentsRemaining():
      myarg = getArgument()
      if myarg == u'check':
        forceCheck = True
      elif myarg == u'simple':
        simple = True
      else:
        unknownArgumentExit()
  if simple:
    writeStdout(__version__)
    return
  import struct
  version_data = u'GAM {0} - {1}\n{2}\nPython {3}.{4}.{5} {6}-bit {7}\ngoogle-api-python-client {8}\n{9} {10}\nPath: {11}\n'
  writeStdout(version_data.format(__version__, GAM_URL, __author__, sys.version_info[0],
                                  sys.version_info[1], sys.version_info[2], struct.calcsize(u'P')*8,
                                  sys.version_info[3], googleapiclient.__version__, platform.platform(),
                                  platform.machine(), GM_Globals[GM_GAM_PATH]))
  if forceCheck:
    doGAMCheckForUpdates(forceCheck=True)

# gam help
def doUsage():
  printBlankLine()
  doVersion(checkForArgs=False)
  writeStdout(MESSAGE_HELP_SYNTAX.format(os.path.join(GM_Globals[GM_GAM_PATH], FN_GAMCOMMANDS_TXT)))
  writeStdout(MESSAGE_HELP_WIKI.format(GAM_WIKI))

def initializeLogging():
  import logging
  logging.getLogger().addHandler(logging.NullHandler())

def resetDefaultEncodingToUTF8():
  if sys.getdefaultencoding().upper() != u'UTF-8':
    reload(sys)
    if hasattr(sys, u'setdefaultencoding'):
      sys.setdefaultencoding(u'UTF-8')

def CSVFileQueueHandler(mpQueue):
  global CLArgs, GM_Globals, GC_Values
  resetDefaultEncodingToUTF8()
  if sys.platform.startswith('win'):
    signal.signal(signal.SIGINT, signal.SIG_IGN)
  CLArgs = glclargs.GamCLArgs()
  titles, csvRows = initializeTitlesCSVfile(None)
  list_type = u'CSV'
  todrive = {}
  while True:
    dataType, dataItem = mpQueue.get()
    if dataType == REDIRECT_QUEUE_NAME:
      list_type = dataItem
    elif dataType == REDIRECT_QUEUE_TODRIVE:
      todrive = dataItem
    elif dataType == REDIRECT_QUEUE_TITLES:
      addTitlesToCSVfile(dataItem, titles)
    elif dataType == REDIRECT_QUEUE_DATA:
      csvRows.extend(dataItem)
    elif dataType == REDIRECT_QUEUE_ARGS:
      CLArgs.InitializeArguments(dataItem)
    elif dataType == REDIRECT_QUEUE_GLOBALS:
      GM_Globals = dataItem
    elif dataType == REDIRECT_QUEUE_VALUES:
      GC_Values = dataItem
    else:
      break
  writeCSVfile(csvRows, titles, list_type, todrive)

def initializeCSVFileQueueHandler():
  import multiprocessing
  mpQueue = multiprocessing.Manager().Queue()
  mpQueueHandler = multiprocessing.Process(target=CSVFileQueueHandler, args=(mpQueue,))
  mpQueueHandler.start()
  return (mpQueue, mpQueueHandler)

def terminateCSVFileQueueHandler(mpQueue, mpQueueHandler):
  GM_Globals[GM_PARSER] = None
  GM_Globals[GM_CSVFILE][GM_REDIRECT_QUEUE] = None
  if GM_Globals[GM_WINDOWS]:
    mpQueue.put((REDIRECT_QUEUE_ARGS, CLArgs.AllArguments()))
    mpQueue.put((REDIRECT_QUEUE_GLOBALS, GM_Globals))
    mpQueue.put((REDIRECT_QUEUE_VALUES, GC_Values))
  mpQueue.put((REDIRECT_QUEUE_EOF, None))
  mpQueueHandler.join()

def StdQueueHandler(mpQueue, stdtype, gmGlobals, gcValues):
  global GM_Globals, GC_Values

  PROCESS_MSG = u'{0}: {1:6d}, {2:>5s}: {3}, RC: {4:3d}, Cmd: {5}\n'
  def _quotedArgumentList(items):
    qstr = u''
    for item in items:
      if item and (item.find(u' ') == -1) and (item.find(u',') == -1):
        qstr += item
      else:
        qstr += u"'"+item+u"'"
      qstr += u' '
    return qstr

  def _writePidData(pid, data):
    try:
      if pid != 0 and GC_Values[GC_SHOW_MULTIPROCESS_INFO]:
        fd.write(PROCESS_MSG.format(pidData[pid][u'queue'], pid, u'Start', pidData[pid][u'start'], data[0], pidData[pid][u'cmd']))
      if data[1] is not None:
        fd.write(data[1])
      if GC_Values[GC_SHOW_MULTIPROCESS_INFO]:
        fd.write(PROCESS_MSG.format(pidData[pid][u'queue'], pid, u'End', datetime.datetime.now(GC_Values[GC_TIMEZONE]).isoformat(), data[0], pidData[pid][u'cmd']))
      fd.flush()
    except IOError as e:
      systemErrorExit(FILE_ERROR_RC, e)

  resetDefaultEncodingToUTF8()
  if sys.platform.startswith('win'):
    signal.signal(signal.SIGINT, signal.SIG_IGN)
    GM_Globals = gmGlobals.copy()
    GC_Values = gcValues.copy()
  pid0DataItem = [KEYBOARD_INTERRUPT_RC, None]
  pidData = {}
  if GM_Globals[GM_WINDOWS]:
    if GM_Globals[stdtype][GM_REDIRECT_NAME] == u'null':
      fd = open(os.devnull, GM_Globals[stdtype][GM_REDIRECT_MODE])
    elif GM_Globals[stdtype][GM_REDIRECT_NAME] == u'-':
      fd = [sys.stderr, sys.stdout][GM_Globals[stdtype][GM_REDIRECT_QUEUE] == u'stdout']
    elif GM_Globals[stdtype][GM_REDIRECT_NAME] == u'stdout'and GM_Globals[stdtype][GM_REDIRECT_QUEUE] == u'stderr':
      fd = sys.stdout
    else:
      fd = openFile(GM_Globals[stdtype][GM_REDIRECT_NAME], GM_Globals[stdtype][GM_REDIRECT_MODE])
  else:
    fd = GM_Globals[stdtype][GM_REDIRECT_FD]
  while True:
    pid, dataType, dataItem = mpQueue.get()
    if dataType == REDIRECT_QUEUE_START:
      pidData[pid] = {u'queue': GM_Globals[stdtype][GM_REDIRECT_QUEUE], u'start': datetime.datetime.now(GC_Values[GC_TIMEZONE]).isoformat(), u'cmd': _quotedArgumentList(dataItem)}
      if pid == 0 and GC_Values[GC_SHOW_MULTIPROCESS_INFO]:
        fd.write(PROCESS_MSG.format(pidData[pid][u'queue'], pid, u'Start', pidData[pid][u'start'], 0, pidData[pid][u'cmd']))
    elif dataType == REDIRECT_QUEUE_END:
      if pid != 0:
        _writePidData(pid, dataItem)
        del pidData[pid]
      else:
        pid0DataItem = dataItem
    else:
      break
  for pid in pidData:
    if pid != 0:
      _writePidData(pid, [KEYBOARD_INTERRUPT_RC, None])
  _writePidData(0, pid0DataItem)
  if fd not in [sys.stdout, sys.stderr]:
    try:
      fd.close()
    except IOError:
      pass
  GM_Globals[stdtype][GM_REDIRECT_FD] = None

def initializeStdQueueHandler(stdtype, gmGlobals, gcValues):
  import multiprocessing
  mpQueue = multiprocessing.Manager().Queue()
  mpQueueHandler = multiprocessing.Process(target=StdQueueHandler, args=(mpQueue, stdtype, gmGlobals, gcValues))
  mpQueueHandler.start()
  return (mpQueue, mpQueueHandler)

def terminateStdQueueHandler(mpQueue, mpQueueHandler):
  mpQueue.put((0, REDIRECT_QUEUE_EOF, None))
  mpQueueHandler.join()

def ProcessGAMCommandMulti(pid, mpQueueCSVFile, mpQueueStdout, mpQueueStderr, gmGlobals, args):
  global GM_Globals
  resetDefaultEncodingToUTF8()
  initializeLogging()
  if sys.platform.startswith('win'):
    signal.signal(signal.SIGINT, signal.SIG_IGN)
    GM_Globals = gmGlobals.copy()
  GM_Globals[GM_PID] = pid
  GM_Globals[GM_CSVFILE] = {}
  if mpQueueCSVFile:
    GM_Globals[GM_CSVFILE][GM_REDIRECT_QUEUE] = mpQueueCSVFile
  if mpQueueStdout:
    GM_Globals[GM_STDOUT] = {GM_REDIRECT_NAME: u'', GM_REDIRECT_FD: None, GM_REDIRECT_MULTI_FD: StringIO.StringIO()}
    if GM_Globals[GM_SAVED_STDOUT] is not None:
      GM_Globals[GM_SAVED_STDOUT] = sys.stdout
      sys.stdout = GM_Globals[GM_STDOUT][GM_REDIRECT_MULTI_FD]
    mpQueueStdout.put((pid, REDIRECT_QUEUE_START, args))
  else:
    GM_Globals[GM_STDOUT] = {}
  if mpQueueStderr:
    if mpQueueStderr is not mpQueueStdout:
      GM_Globals[GM_STDERR] = {GM_REDIRECT_NAME: u'', GM_REDIRECT_FD: None, GM_REDIRECT_MULTI_FD: StringIO.StringIO()}
      mpQueueStderr.put((pid, REDIRECT_QUEUE_START, args))
    else:
      GM_Globals[GM_STDERR][GM_REDIRECT_MULTI_FD] = GM_Globals[GM_STDOUT][GM_REDIRECT_MULTI_FD]
  else:
    GM_Globals[GM_STDERR] = {}
  sysRC = ProcessGAMCommand(args)
  if mpQueueStdout:
    mpQueueStdout.put((pid, REDIRECT_QUEUE_END, [sysRC, GM_Globals[GM_STDOUT][GM_REDIRECT_MULTI_FD].getvalue()]))
    GM_Globals[GM_STDOUT][GM_REDIRECT_MULTI_FD].close()
    GM_Globals[GM_STDOUT][GM_REDIRECT_MULTI_FD] = None
  if mpQueueStderr and mpQueueStderr is not mpQueueStdout:
    mpQueueStderr.put((pid, REDIRECT_QUEUE_END, [sysRC, GM_Globals[GM_STDERR][GM_REDIRECT_MULTI_FD].getvalue()]))
    GM_Globals[GM_STDERR][GM_REDIRECT_MULTI_FD].close()
    GM_Globals[GM_STDERR][GM_REDIRECT_MULTI_FD] = None

def MultiprocessGAMCommands(items):
  import multiprocessing
  if not items:
    return
  totalItems = len(items)
  numPoolProcesses = min(totalItems, GC_Values[GC_NUM_THREADS])
  origSigintHandler = signal.signal(signal.SIGINT, signal.SIG_IGN)
  try:
    pool = multiprocessing.Pool(processes=numPoolProcesses)
  except IOError as e:
    systemErrorExit(FILE_ERROR_RC, e)
  except AssertionError as e:
    CLArgs.SetLocation(0)
    usageErrorExit(e.message)
  if GM_Globals[GM_CSVFILE][GM_REDIRECT_MULTIPROCESS]:
    mpQueueCSVFile, mpQueueHandlerCSVFile = initializeCSVFileQueueHandler()
  else:
    mpQueueCSVFile = None
  if GM_Globals[GM_STDOUT][GM_REDIRECT_MULTIPROCESS]:
    mpQueueStdout, mpQueueHandlerStdout = initializeStdQueueHandler(GM_STDOUT, GM_Globals, GC_Values)
    mpQueueStdout.put((0, REDIRECT_QUEUE_START, CLArgs.AllArguments()))
  else:
    mpQueueStdout = None
  if GM_Globals[GM_STDERR][GM_REDIRECT_MULTIPROCESS]:
    if GM_Globals[GM_STDERR][GM_REDIRECT_NAME] != u'stdout':
      mpQueueStderr, mpQueueHandlerStderr = initializeStdQueueHandler(GM_STDERR, GM_Globals, GC_Values)
      mpQueueStderr.put((0, REDIRECT_QUEUE_START, CLArgs.AllArguments()))
    else:
      mpQueueStderr = mpQueueStdout
  else:
    mpQueueStderr = None
  signal.signal(signal.SIGINT, origSigintHandler)
  writeStderr(u'Using %s processes...\n' % numPoolProcesses)
  try:
    pid = 0
    poolProcessesInUse = 0
    poolProcessResults = {}
    while items:
      item = items.popleft()
      totalItems -= 1
      if item[0] == u'commit-batch':
        writeStderr(u'commit-batch - waiting for running processes to finish before proceeding...\n')
        while poolProcessesInUse > 0:
          for ppid in poolProcessResults.keys():
            try:
              poolProcessResults[ppid].get(1)
              poolProcessesInUse -= 1
              del poolProcessResults[ppid]
            except (TypeError, IOError, multiprocessing.TimeoutError):
              pass
        writeStderr(u'commit-batch - complete\n')
        continue
      pid += 1
      poolProcessResults[pid] = pool.apply_async(ProcessGAMCommandMulti, [pid, mpQueueCSVFile, mpQueueStdout, mpQueueStderr, GM_Globals, item])
      poolProcessesInUse += 1
      while poolProcessesInUse == numPoolProcesses:
        for ppid in poolProcessResults.keys():
          try:
            poolProcessResults[ppid].get(1)
            poolProcessesInUse -= 1
            del poolProcessResults[ppid]
            break
          except (TypeError, IOError, multiprocessing.TimeoutError):
            pass
  except KeyboardInterrupt:
    setSysExitRC(KEYBOARD_INTERRUPT_RC)
    pool.terminate()
  else:
    pool.close()
  pool.join()
  if mpQueueCSVFile:
    terminateCSVFileQueueHandler(mpQueueCSVFile, mpQueueHandlerCSVFile)
  if mpQueueStdout:
    mpQueueStdout.put((0, REDIRECT_QUEUE_END, [GM_Globals[GM_SYSEXITRC], GM_Globals[GM_STDOUT][GM_REDIRECT_MULTI_FD].getvalue()]))
    GM_Globals[GM_STDOUT][GM_REDIRECT_MULTI_FD].close()
    GM_Globals[GM_STDOUT][GM_REDIRECT_MULTI_FD] = None
    terminateStdQueueHandler(mpQueueStdout, mpQueueHandlerStdout)
  if mpQueueStderr and mpQueueStderr is not mpQueueStdout:
    mpQueueStderr.put((0, REDIRECT_QUEUE_END, [GM_Globals[GM_SYSEXITRC], GM_Globals[GM_STDERR][GM_REDIRECT_MULTI_FD].getvalue()]))
    GM_Globals[GM_STDERR][GM_REDIRECT_MULTI_FD].close()
    GM_Globals[GM_STDERR][GM_REDIRECT_MULTI_FD] = None
    terminateStdQueueHandler(mpQueueStderr, mpQueueHandlerStderr)

# gam batch <FileName>|- [charset <Charset>]
def doBatch():
  import shlex
  filename = getString(OB_FILE_NAME)
  if (filename == u'-') and (GC_Values[GC_DEBUG_LEVEL] > 0):
    CLArgs.Backup()
    usageErrorExit(MESSAGE_BATCH_CSV_LOOP_DASH_DEBUG_INCOMPATIBLE.format(u'batch'))
  encoding = getCharSet()
  checkForExtraneousArguments()
  items = collections.deque()
  f = openFile(filename)
  batchFile = UTF8Recoder(f, encoding) if encoding != u'utf-8' else f
  try:
    for line in batchFile:
      argv = shlex.split(line)
      if len(argv) > 0:
        cmd = argv[0].strip().lower()
        if (not cmd) or cmd.startswith(u'#') or ((len(argv) == 1) and (cmd != COMMIT_BATCH_CMD)):
          continue
        if cmd == GAM_CMD:
          items.append([arg.encode(GM_Globals[GM_SYS_ENCODING]) for arg in argv])
        elif cmd == COMMIT_BATCH_CMD:
          items.append([cmd])
        else:
          writeStderr(u'Command: >>>{0}<<< {1}\n'.format(CLArgs.QuotedArgumentList([argv[0]]), CLArgs.QuotedArgumentList(argv[1:])))
          stderrErrorMsg(u'{0}: {1} <{2}>'.format(ARGUMENT_ERROR_NAMES[ARGUMENT_INVALID][1],
                                                  PHRASE_EXPECTED,
                                                  formatChoiceList([GAM_CMD, COMMIT_BATCH_CMD])))
  except IOError as e:
    systemErrorExit(FILE_ERROR_RC, e)
  closeFile(f)
  MultiprocessGAMCommands(items)

def doAutoBatch(entityType, entityList, CL_command):
  remaining = CLArgs.Remaining()
  items = collections.deque()
  for entity in entityList:
    items.append([GAM_CMD, entityType, entity, CL_command]+remaining)
  MultiprocessGAMCommands(items)

# Process command line arguments, find substitutions
# An argument containing instances of ~~xxx~!~pattern~!~replacement~~ has ~~...~~ replaced by re.sub(pattern, replacement, value of field xxx from the CSV file)
# For example, ~~primaryEmail~!~^(.+)@(.+)$~!~\1 AT \2~~ would replace foo@bar.com (from the primaryEmail column) with foo AT bar.com
# An argument containing instances of ~~xxx~~ has xxx replaced by the value of field xxx from the CSV file
# An argument containing exactly ~xxx is replaced by the value of field xxx from the CSV file
# Otherwise, the argument is preserved as is

SUB_PATTERN = re.compile(r'~~(.+?)~~')
RE_PATTERN = re.compile(r'~~(.+?)~!~(.+?)~!~(.+?)~~')
SUB_TYPE = u'sub'
RE_TYPE = u're'

# SubFields is a dictionary; the key is the argument number, the value is a list of tuples that mark
# the substition (type, fieldname, start, end). Type is 'sub' for simple substitution, 're' for regex substitution.
# Example: update user '~User' address type work unstructured '~~Street~~, ~~City~~, ~~State~~ ~~ZIP~~' primary
# {2: [('sub', 'User', 0, 5)], 7: [('sub', 'Street', 0, 10), ('sub', 'City', 12, 20), ('sub', 'State', 22, 31), ('sub', 'ZIP', 32, 39)]}
def getSubFields(initial_argv, fieldNames):
  subFields = {}
  GAM_argv = initial_argv[:]
  GAM_argvI = len(GAM_argv)
  while CLArgs.ArgumentsRemaining():
    myarg = CLArgs.Current()
    if not myarg:
      GAM_argv.append(myarg)
    elif SUB_PATTERN.search(myarg):
      pos = 0
      subFields.setdefault(GAM_argvI, [])
      while True:
        submatch = SUB_PATTERN.search(myarg, pos)
        if not submatch:
          break
        rematch = RE_PATTERN.match(submatch.group(0))
        if not rematch:
          fieldName = submatch.group(1)
          if fieldName not in fieldNames:
            csvFieldErrorExit(fieldName, fieldNames)
          subFields[GAM_argvI].append((SUB_TYPE, fieldName, submatch.start(), submatch.end()))
        else:
          fieldName = rematch.group(1)
          if fieldName not in fieldNames:
            csvFieldErrorExit(fieldName, fieldNames)
          try:
            re.compile(rematch.group(2))
            subFields[GAM_argvI].append((RE_TYPE, fieldName, submatch.start(), submatch.end(), rematch.group(2), rematch.group(3)))
          except re.error as e:
            usageErrorExit(u'{0} {1}: {2}'.format(OB_RE_PATTERN, PHRASE_ERROR, e))
        pos = submatch.end()
      GAM_argv.append(myarg)
    elif myarg[0] == u'~':
      fieldName = myarg[1:]
      if fieldName in fieldNames:
        subFields[GAM_argvI] = [(SUB_TYPE, fieldName, 0, len(myarg))]
        GAM_argv.append(myarg)
      else:
        csvFieldErrorExit(fieldName, fieldNames)
    else:
      GAM_argv.append(myarg.encode(GM_Globals[GM_SYS_ENCODING]))
    GAM_argvI += 1
    CLArgs.Advance()
  return(GAM_argv, subFields)

def processSubFields(GAM_argv, row, subFields):
  argv = GAM_argv[:]
  for GAM_argvI, fields in subFields.iteritems():
    oargv = argv[GAM_argvI][:]
    argv[GAM_argvI] = u''
    pos = 0
    for field in fields:
      argv[GAM_argvI] += oargv[pos:field[2]]
      if field[0] == SUB_TYPE:
        if row[field[1]]:
          argv[GAM_argvI] += row[field[1]]
      else:
        if row[field[1]]:
          argv[GAM_argvI] += re.sub(field[4], field[5], row[field[1]])
      pos = field[3]
    argv[GAM_argvI] += oargv[pos:]
    argv[GAM_argvI] = argv[GAM_argvI].encode(GM_Globals[GM_SYS_ENCODING])
  return argv

# gam csv <FileName>|- [charset <Charset>] [columndelimiter <String>] [fields <FieldNameList>] (matchfield <FieldName> <RegularExpression>)* gam <GAM argument list>
def doCSV():
  filename = getString(OB_FILE_NAME)
  if (filename == u'-') and (GC_Values[GC_DEBUG_LEVEL] > 0):
    CLArgs.Backup()
    usageErrorExit(MESSAGE_BATCH_CSV_LOOP_DASH_DEBUG_INCOMPATIBLE.format(u'csv'))
  f, csvFile = openCSVFileReader(filename)
  matchFields = getMatchFields(csvFile.fieldnames)
  checkArgumentPresent([GAM_CMD,], required=True)
  if not CLArgs.ArgumentsRemaining():
    missingArgumentExit(OB_GAM_ARGUMENT_LIST)
  GAM_argv, subFields = getSubFields([GAM_CMD,], csvFile.fieldnames)
  items = collections.deque()
  for row in csvFile:
    if (not matchFields) or checkMatchFields(row, matchFields):
      items.append(processSubFields(GAM_argv, row, subFields))
  closeFile(f)
  MultiprocessGAMCommands(items)

def _doList(entityList, entityType):
  buildGAPIObject(DIRECTORY_API)
  if checkArgumentPresent(TODRIVE_ARGUMENT):
    todrive = getTodriveParameters()
  else:
    todrive = {}
  if entityList is None:
    entityList = getEntityList(OB_ENTITY)
  if GM_Globals[GM_CSV_DATA_DICT]:
    keyField = GM_Globals[GM_CSV_KEY_FIELD]
    dataField = GM_Globals[GM_CSV_DATA_FIELD]
  else:
    keyField = u'Entity'
    dataField = u'Data'
  titles, csvRows = initializeTitlesCSVfile([keyField])
  showData = checkArgumentPresent(DATA_ARGUMENT)
  if showData:
    if not entityType:
      itemType, itemList = getEntityToModify(crosAllowed=True)
    else:
      itemType = None
      itemList = getEntityList(OB_ENTITY)
    entityItemLists = itemList if isinstance(itemList, dict) else None
    addTitleToCSVfile(dataField, titles)
  else:
    entityItemLists = None
  dataDelimiter = getDelimiter(True)
  checkForExtraneousArguments()
  _, _, entityList = getEntityArgument(entityList)
  for entity in entityList:
    entityEmail = normalizeEmailAddressOrUID(entity)
    if showData:
      if entityItemLists:
        if entity not in entityItemLists:
          csvRows.append({keyField: entityEmail})
          continue
        itemList = entityItemLists[entity]
        if itemType == CL_ENTITY_USERS:
          for i, item in enumerate(itemList):
            itemList[i] = normalizeEmailAddressOrUID(item)
      if dataDelimiter:
        csvRows.append({keyField: entityEmail, dataField: dataDelimiter.join(itemList)})
      else:
        for item in itemList:
          csvRows.append({keyField: entityEmail, dataField: item})
    else:
      csvRows.append({keyField: entityEmail})
  writeCSVfile(csvRows, titles, u'Entity', todrive)

# gam list [todrive [<ToDriveAttributes>]] <EntityList> [data <CrOSTypeEntity>|<UserTypeEntity> [delimiter <String>]]
def doListType():
  _doList(None, None)

# gam <CrOSTypeEntity> list [todrive [<ToDriveAttributes>]] [data <EntityList> [delimiter <String>]]
def doListCrOS(entityList):
  _doList(entityList, CL_ENTITY_CROS)

# gam <UserTypeEntity> list [todrive [<ToDriveAttributes>]] [data <EntityList> [delimiter <String>]]
def doListUser(entityList):
  _doList(entityList, CL_ENTITY_USERS)

class cmd_flags(object):
  def __init__(self, noLocalWebserver):
    self.short_url = True
    self.noauth_local_webserver = noLocalWebserver
    self.logging_level = u'ERROR'
    self.auth_host_name = u'localhost'
    self.auth_host_port = [8080, 9090]

OAUTH2_SCOPES = [
  {u'name': u'Admin Settings API',
   u'credfam': OAUTH2_FAM2_SCOPES,
   u'subscopes': [],
   u'scope': u'https://apps-apis.google.com/a/feeds/domain/'},
  {u'name': u'Admin User - Email upload report document notifications',
   u'credfam': OAUTH2_FAM1_SCOPES,
   u'subscopes': [],
   u'scope': u'https://www.googleapis.com/auth/gmail.send'},
  {u'name': u'Admin User - Find documents in Google Drive',
   u'credfam': OAUTH2_FAM1_SCOPES,
   u'subscopes': [],
   u'scope': u'https://www.googleapis.com/auth/drive'},
  {u'name': u'Admin User - Upload report documents to Google Drive',
   u'credfam': OAUTH2_FAM1_SCOPES,
   u'subscopes': [],
   u'scope': u'https://www.googleapis.com/auth/drive.file'},
  {u'name': u'Calendar Data API',
   u'credfam': OAUTH2_FAM1_SCOPES,
   u'subscopes': [u'readonly'],
   u'scope': u'https://www.googleapis.com/auth/calendar'},
  {u'name': u'Classroom API - Courses',
   u'credfam': OAUTH2_FAM2_SCOPES,
   u'subscopes': [u'readonly'],
   u'scope': u'https://www.googleapis.com/auth/classroom.courses'},
  {u'name': u'Classroom API - Student Guardians',
   u'credfam': OAUTH2_FAM2_SCOPES,
   u'subscopes': [u'readonly'],
   u'scope': u'https://www.googleapis.com/auth/classroom.guardianlinks.students'},
  {u'name': u'Classroom API - Profile Emails',
   u'credfam': OAUTH2_FAM2_SCOPES,
   u'subscopes': [],
   u'scope': u'https://www.googleapis.com/auth/classroom.profile.emails'},
  {u'name': u'Classroom API - Profile Photos',
   u'credfam': OAUTH2_FAM2_SCOPES,
   u'subscopes': [],
   u'scope': u'https://www.googleapis.com/auth/classroom.profile.photos'},
  {u'name': u'Classroom API - Rosters',
   u'credfam': OAUTH2_FAM2_SCOPES,
   u'subscopes': [u'readonly'],
   u'scope': u'https://www.googleapis.com/auth/classroom.rosters'},
  {u'name': u'Cloudprint API',
   u'credfam': OAUTH2_FAM2_SCOPES,
   u'subscopes': [],
   u'scope': u'https://www.googleapis.com/auth/cloudprint'},
  {u'name': u'Contacts API - Domain Shared and Users and GAL',
   u'credfam': OAUTH2_FAM2_SCOPES,
   u'subscopes': [],
   u'scope': u'https://www.google.com/m8/feeds'},
  {u'name': u'Data Transfer API',
   u'credfam': OAUTH2_FAM1_SCOPES,
   u'subscopes': [u'readonly'],
   u'scope': u'https://www.googleapis.com/auth/admin.datatransfer'},
  {u'name': u'Directory API - Chrome OS Devices',
   u'credfam': OAUTH2_FAM1_SCOPES,
   u'subscopes': [u'readonly'],
   u'scope': u'https://www.googleapis.com/auth/admin.directory.device.chromeos'},
  {u'name': u'Directory API - Customers',
   u'credfam': OAUTH2_FAM1_SCOPES,
   u'subscopes': [u'readonly'],
   u'scope': u'https://www.googleapis.com/auth/admin.directory.customer'},
  {u'name': u'Directory API - Domains',
   u'credfam': OAUTH2_FAM1_SCOPES,
   u'subscopes': [u'readonly'],
   u'scope': u'https://www.googleapis.com/auth/admin.directory.domain'},
  {u'name': u'Directory API - Groups',
   u'credfam': OAUTH2_FAM1_SCOPES,
   u'subscopes': [u'readonly'],
   u'scope': u'https://www.googleapis.com/auth/admin.directory.group'},
  {u'name': u'Directory API - Mobile Devices Directory',
   u'credfam': OAUTH2_FAM1_SCOPES,
   u'subscopes': [u'readonly', u'action'],
   u'scope': u'https://www.googleapis.com/auth/admin.directory.device.mobile'},
  {u'name': u'Directory API - Notifications',
   u'credfam': OAUTH2_FAM1_SCOPES,
   u'subscopes': [],
   u'scope': u'https://www.googleapis.com/auth/admin.directory.notifications'},
  {u'name': u'Directory API - Organizational Units',
   u'credfam': OAUTH2_FAM1_SCOPES,
   u'subscopes': [u'readonly'],
   u'scope': u'https://www.googleapis.com/auth/admin.directory.orgunit'},
  {u'name': u'Directory API - Resource Calendars',
   u'credfam': OAUTH2_FAM1_SCOPES,
   u'subscopes': [u'readonly'],
   u'scope': u'https://www.googleapis.com/auth/admin.directory.resource.calendar'},
  {u'name': u'Directory API - Roles',
   u'credfam': OAUTH2_FAM1_SCOPES,
   u'subscopes': [u'readonly'],
   u'scope': u'https://www.googleapis.com/auth/admin.directory.rolemanagement'},
  {u'name': u'Directory API - User Schemas',
   u'credfam': OAUTH2_FAM1_SCOPES,
   u'subscopes': [u'readonly'],
   u'scope': u'https://www.googleapis.com/auth/admin.directory.userschema'},
  {u'name': u'Directory API - User Security',
   u'credfam': OAUTH2_FAM1_SCOPES,
   u'subscopes': [],
   u'scope': u'https://www.googleapis.com/auth/admin.directory.user.security'},
  {u'name': u'Directory API - Users',
   u'credfam': OAUTH2_FAM1_SCOPES,
   u'subscopes': [u'readonly'],
   u'scope': u'https://www.googleapis.com/auth/admin.directory.user'},
  {u'name': u'Email Audit API',
   u'credfam': OAUTH2_FAM2_SCOPES,
   u'subscopes': [],
   u'scope': u'https://apps-apis.google.com/a/feeds/compliance/audit/'},
  {u'name': u'Email Settings API - Users',
   u'credfam': OAUTH2_FAM1_SCOPES,
   u'subscopes': [],
   u'scope': u'https://apps-apis.google.com/a/feeds/emailsettings/2.0/'},
  {u'name': u'Groups Migration API',
   u'credfam': OAUTH2_FAM2_SCOPES,
   u'subscopes': [],
   u'scope': u'https://www.googleapis.com/auth/apps.groups.migration'},
  {u'name': u'Groups Settings API',
   u'credfam': OAUTH2_FAM2_SCOPES,
   u'subscopes': [],
   u'scope': u'https://www.googleapis.com/auth/apps.groups.settings'},
  {u'name': u'License Manager API',
   u'credfam': OAUTH2_FAM1_SCOPES,
   u'subscopes': [],
   u'scope': u'https://www.googleapis.com/auth/apps.licensing'},
  {u'name': u'Reports API - Audit Reports',
   u'credfam': OAUTH2_FAM2_SCOPES,
   u'subscopes': [],
   u'scope': u'https://www.googleapis.com/auth/admin.reports.audit.readonly'},
  {u'name': u'Reports API - Usage Reports',
   u'credfam': OAUTH2_FAM2_SCOPES,
   u'subscopes': [],
   u'scope': u'https://www.googleapis.com/auth/admin.reports.usage.readonly'},
  {u'name': u'Site Verification API',
   u'credfam': OAUTH2_FAM2_SCOPES,
   u'subscopes': [],
   u'scope': u'https://www.googleapis.com/auth/siteverification'},
  {u'name': u'Sites API',
   u'credfam': OAUTH2_FAM2_SCOPES,
   u'subscopes': [],
   u'scope': u'https://sites.google.com/feeds'},
  ]

OAUTH2_CMDS = [u's', u'u', u'e', u'c']

def revokeCredentials(credFamilyList):
  http = httplib2.Http(disable_ssl_certificate_validation=GC_Values[GC_NO_VERIFY_SSL])
  for cred_family in credFamilyList:
    credentials = getCredentialsForScope(cred_family)
    if credentials and not credentials.invalid:
      credentials.revoke_uri = oauth2client.GOOGLE_REVOKE_URI
      try:
        credentials.revoke(http)
        time.sleep(2)
      except oauth2client.client.TokenRevokeError as e:
        printErrorMessage(INVALID_TOKEN_RC, e.message)

VALIDEMAIL_PATTERN = re.compile(r'^[^@]+@[^@]+\.[^@]+$')

def getValidateLoginHint(login_hint):
  if login_hint:
    login_hint = login_hint.strip()
    if VALIDEMAIL_PATTERN.match(login_hint):
      return login_hint
  while True:
    login_hint = raw_input(u'\nWhat is your G Suite admin email address? ').strip()
    if VALIDEMAIL_PATTERN.match(login_hint):
      return login_hint
    print u'Error: that is not a valid email address'

PROFILE_SCOPE = u'profile'

# gam oauth|oauth2 create|request [<EmailAddress>]
def doOAuthRequest():
  cs_data = readFile(GC_Values[GC_CLIENT_SECRETS_JSON], continueOnError=True, displayError=True)
  if not cs_data:
    invalidClientSecretsJsonExit()
  try:
    cs_json = json.loads(cs_data)
    client_id = cs_json[u'installed'][u'client_id']
    client_secret = cs_json[u'installed'][u'client_secret']
  except (ValueError, IndexError, KeyError):
    invalidClientSecretsJsonExit()

  login_hint = getEmailAddress(noUid=True, optional=True)
  checkForExtraneousArguments()
  login_hint = getValidateLoginHint(login_hint)
  oauth2_menu = u'''
Select the authorized scopes by entering a number.
Append an 'r' to grant read-only access or an 'a' to grant action-only access.

'''
  for a_scope in OAUTH2_SCOPES:
    oauth2_menu += u'[%%%%s] %%2d)  %s' % (a_scope[u'name'])
    if a_scope[u'subscopes']:
      oauth2_menu += u' (supports %s)' % (u' and '.join(a_scope[u'subscopes']))
    oauth2_menu += '\n'
  oauth2_menu += '''
     s)  Select all scopes
     u)  Unselect all scopes
     e)  Exit without changes
     c)  Continue to authorization
'''
  num_scopes = len(OAUTH2_SCOPES)
  menu = oauth2_menu % tuple(range(num_scopes))
  selected_scopes = [u'*'] * num_scopes
  for cred_family in OAUTH2_FAM_LIST:
    credentials = getCredentialsForScope(cred_family)
    if credentials and not credentials.invalid:
      currentScopes = sorted(credentials.scopes)
      i = 0
      for a_scope in OAUTH2_SCOPES:
        if cred_family == a_scope[u'credfam']:
          selected_scopes[i] = u' '
          possibleScope = a_scope[u'scope']
          for currentScope in currentScopes:
            if currentScope == possibleScope:
              selected_scopes[i] = u'*'
              break
            if u'readonly' in a_scope[u'subscopes']:
              if currentScope == possibleScope+u'.readonly':
                selected_scopes[i] = u'R'
                break
            if u'action' in a_scope[u'subscopes']:
              if currentScope == possibleScope+u'.action':
                selected_scopes[i] = u'A'
                break
        i += 1
    else:
      i = 0
      for a_scope in OAUTH2_SCOPES:
        if cred_family == a_scope[u'credfam']:
          selected_scopes[i] = u'*'
        i += 1
  prompt = u'Please enter 0-{0}[a|r] or {1}: '.format(num_scopes-1, u'|'.join(OAUTH2_CMDS))
  while True:
    os.system([u'clear', u'cls'][GM_Globals[GM_WINDOWS]])
    sys.stdout.write(menu % tuple(selected_scopes))
    while True:
      choice = raw_input(prompt)
      if choice:
        selection = choice.lower()
        if selection.find(u'r') >= 0:
          mode = u'R'
          selection = selection.replace(u'r', u'')
        elif selection.find(u'a') >= 0:
          mode = u'A'
          selection = selection.replace(u'a', u'')
        else:
          mode = u' '
        if selection and selection.isdigit():
          selection = int(selection)
        if isinstance(selection, int) and selection < num_scopes:
          if mode == u'R':
            if u'readonly' not in OAUTH2_SCOPES[selection][u'subscopes']:
              sys.stdout.write(u'{0}Scope {1} does not support read-only mode!\n'.format(ERROR_PREFIX, selection))
              continue
          elif mode == u'A':
            if u'action' not in OAUTH2_SCOPES[selection][u'subscopes']:
              sys.stdout.write(u'{0}Scope {1} does not support action-only mode!\n'.format(ERROR_PREFIX, selection))
              continue
          elif selected_scopes[selection] != u'*':
            mode = u'*'
          else:
            mode = u' '
          selected_scopes[selection] = mode
          break
        elif isinstance(selection, str) and selection in OAUTH2_CMDS:
          if selection == u's':
            for i in range(num_scopes):
              selected_scopes[i] = u'*'
          elif selection == u'u':
            for i in range(num_scopes):
              selected_scopes[i] = u' '
          elif selection == u'e':
            return
          break
        sys.stdout.write(u'{0}Invalid input "{1}"\n'.format(ERROR_PREFIX, choice))
    if selection == u'c':
      break
  revokeCredentials(OAUTH2_FAM_LIST)
  flags = cmd_flags(noLocalWebserver=GC_Values[GC_NO_BROWSER])
  http = httplib2.Http(disable_ssl_certificate_validation=GC_Values[GC_NO_VERIFY_SSL])
  for cred_family in OAUTH2_FAM_LIST:
    scopes = [PROFILE_SCOPE,] # Email Display Scope, always included for client
    i = 0
    for a_scope in OAUTH2_SCOPES:
      if cred_family == a_scope[u'credfam']:
        if selected_scopes[i] == u'*':
          scopes.append(a_scope[u'scope'])
        elif selected_scopes[i] == u'R':
          scopes.append(u'{0}.readonly'.format(a_scope[u'scope']))
        elif selected_scopes[i] == u'A':
          scopes.append(u'{0}.action'.format(a_scope[u'scope']))
      i += 1
    flow = oauth2client.client.OAuth2WebServerFlow(client_id=client_id,
                                                   client_secret=client_secret, scope=scopes, redirect_uri=oauth2client.client.OOB_CALLBACK_URN,
                                                   user_agent=GAM_INFO, response_type=u'code', login_hint=login_hint)
    storage = getCredentialsForScope(cred_family, storageOnly=True)
    try:
      oauth2client.tools.run_flow(flow=flow, storage=storage, flags=flags, http=http)
      time.sleep(3)
    except httplib2.CertificateValidationUnsupported:
      noPythonSSLExit()
  entityActionPerformed([Entity.OAUTH2_TXT_FILE, GC_Values[GC_OAUTH2_TXT]])

CRED_FAMILY_CHOICES_MAP = [u'current', u'previous']

# gam oauth|oauth2 delete|revoke
def doOAuthDelete():
  currPrev = getChoice(CRED_FAMILY_CHOICES_MAP, defaultChoice=None)
  checkForExtraneousArguments()
  if os.path.isfile(GC_Values[GC_OAUTH2_TXT]):
    if currPrev is None:
      entityType = Entity.OAUTH2_TXT_FILE
      entityName = GC_Values[GC_OAUTH2_TXT]
    else:
      entityType = Entity.CREDENTIALS
      entityName = currPrev
    sys.stdout.write(u'{0}: {1}, will be Deleted in 3...'.format(Entity.Singular(entityType), entityName))
    sys.stdout.flush()
    time.sleep(1)
    sys.stdout.write(u'2...')
    sys.stdout.flush()
    time.sleep(1)
    sys.stdout.write(u'1...')
    sys.stdout.flush()
    time.sleep(1)
    sys.stdout.write(u'boom!\n')
    sys.stdout.flush()
    if currPrev == u'current':
      revokeCredentials(OAUTH2_FAM_LIST)
    elif currPrev == u'previous':
      revokeCredentials(OAUTH2_PREV_FAM_LIST)
    else:
      revokeCredentials(OAUTH2_FAM_LIST)
      revokeCredentials(OAUTH2_PREV_FAM_LIST)
      deleteFile(GC_Values[GC_OAUTH2_TXT], continueOnError=True)
    entityActionPerformed([entityType, entityName])

# gam oauth|oauth2 info [<AccessToken>]
def doOAuthInfo():

  def _printCredentials(credentials):
    if not credentials or credentials.invalid:
      return
    printKeyValueList([u'Client ID', credentials.client_id])
    printKeyValueList([u'Secret', credentials.client_secret])
    scopes = sorted(credentials.scopes)
    if PROFILE_SCOPE in scopes:
      scopes.remove(PROFILE_SCOPE)
    printKeyValueList([u'Scopes', len(scopes)])
    Indent.Increment()
    for scope in scopes:
      printKeyValueList([scope])
    Indent.Decrement()
    printKeyValueList([u'G Suite Admin', credentials.id_token.get(u'email', u'Unknown')])
    printBlankLine()

  access_token = getString(OB_ACCESS_TOKEN, optional=True)
  checkForExtraneousArguments()
  if access_token:
    for cred_family in OAUTH2_FAM_LIST:
      credentials = getClientCredentials(cred_family)
      if credentials.access_token == access_token:
        _printCredentials(credentials)
        break
    else:
      entityActionFailedWarning([Entity.ACCESS_TOKEN, access_token], PHRASE_DOES_NOT_EXIST)
  else:
    if os.path.isfile(GC_Values[GC_OAUTH2_TXT]):
      printEntity([Entity.OAUTH2_TXT_FILE, GC_Values[GC_OAUTH2_TXT]])
      fam1Credentials = getCredentialsForScope(OAUTH2_FAM1_SCOPES)
      fam2Credentials = getCredentialsForScope(OAUTH2_FAM2_SCOPES)
      if (fam1Credentials and not fam1Credentials.invalid and
          fam2Credentials and not fam2Credentials.invalid and
          fam1Credentials.client_id == fam2Credentials.client_id and
          fam1Credentials.client_secret == fam2Credentials.client_secret and
          fam1Credentials.id_token.get(PROFILE_SCOPE) == fam2Credentials.id_token.get(PROFILE_SCOPE)):
        fam1Credentials.scopes = fam1Credentials.scopes.union(fam2Credentials.scopes)
        _printCredentials(fam1Credentials)
      else:
        _printCredentials(fam1Credentials)
        _printCredentials(fam2Credentials)
    else:
      invalidOauth2TxtExit()

# gam <UserTypeEntity> check serviceaccount
def checkServiceAccount(users):
  checkForExtraneousArguments()
  all_scopes_pass = True
  all_scopes = []
  for api in API_INFO:
    for scope in API_INFO[api].get(u'svcacctscopes', []):
      if scope not in all_scopes:
        all_scopes.append(scope)
  all_scopes.sort()
  jcount = len(all_scopes)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = convertUserUIDtoEmailAddress(user)
    entityPerformActionNumItems([Entity.USER, user], jcount, Entity.SCOPE, i, count)
    Indent.Increment()
    j = 0
    for scope in all_scopes:
      j += 1
      try:
        credentials = getSvcAcctCredentials(scope, user)
        credentials.refresh(httplib2.Http(disable_ssl_certificate_validation=GC_Values[GC_NO_VERIFY_SSL]))
        result = u'PASS'
      except httplib2.ServerNotFoundError as e:
        systemErrorExit(NETWORK_ERROR_RC, e.message)
      except oauth2client.client.HttpAccessTokenRefreshError:
        result = u'FAIL'
        all_scopes_pass = False
      entityActionPerformedMessage([Entity.SCOPE, u'{0:60}'.format(scope)], result, j, jcount)
    Indent.Decrement()
    service_account = credentials.serialization_data[u'client_id']
    _, _, user_domain = splitEmailAddressOrUID(user)
  printBlankLine()
  if all_scopes_pass:
    printLine(MESSAGE_SCOPE_AUTHORIZATION_PASSED.format(service_account))
  else:
    printErrorMessage(SCOPES_NOT_AUTHORIZED, MESSAGE_SCOPE_AUTHORIZATION_FAILED.format(user_domain, service_account, ',\n'.join(all_scopes)))

def getCRMService(login_hint):
  from oauth2client.contrib.dictionary_storage import DictionaryStorage
  login_hint = getValidateLoginHint(login_hint)
  scope = u'https://www.googleapis.com/auth/cloud-platform'
  client_id = u'297408095146-fug707qsjv4ikron0hugpevbrjhkmsk7.apps.googleusercontent.com'
  client_secret = u'qM3dP8f_4qedwzWQE1VR4zzU'
  flow = oauth2client.client.OAuth2WebServerFlow(client_id=client_id,
                                                 client_secret=client_secret, scope=scope, redirect_uri=oauth2client.client.OOB_CALLBACK_URN,
                                                 user_agent=GAM_INFO, access_type=u'online', response_type=u'code', login_hint=login_hint)
  storage_dict = {}
  storage = DictionaryStorage(storage_dict, u'credentials')
  flags = cmd_flags(noLocalWebserver=GC_Values[GC_NO_BROWSER])
  http = httplib2.Http(disable_ssl_certificate_validation=GC_Values[GC_NO_VERIFY_SSL])
  try:
    credentials = oauth2client.tools.run_flow(flow=flow, storage=storage, flags=flags, http=http)
  except httplib2.CertificateValidationUnsupported:
    noPythonSSLExit()
  credentials.user_agent = GAM_INFO
  http = credentials.authorize(httplib2.Http(disable_ssl_certificate_validation=GC_Values[GC_NO_VERIFY_SSL],
                                             cache=GC_Values[GC_CACHE_DIR]))
  return (googleapiclient.discovery.build(u'cloudresourcemanager', u'v1', http=http, cache_discovery=False), http)

# gam create project [<EmailAddress>]
def doCreateProject():
  login_hint = getEmailAddress(noUid=True, optional=True)
  checkForExtraneousArguments()
  crm, http = getCRMService(login_hint)
  project_id = u'gam-project'
  for i in range(3):
    project_id += u'-%s' % ''.join(random.choice(string.digits+string.ascii_lowercase) for i in range(3))
  project_name = u'project:%s' % project_id
  body = {u'projectId': project_id, u'name': u'GAM Project'}
  while True:
    create_again = False
    print u'Creating project "%s"...' % body[u'name']
    create_operation = callGAPI(crm.projects(), u'create', body=body)
    operation_name = create_operation[u'name']
    time.sleep(5) # Google recommends always waiting at least 5 seconds
    for i in range(1, 5):
      print u'Checking project status...'
      status = callGAPI(crm.operations(), u'get', name=operation_name)
      if u'error' in status:
        if u'message' in status[u'error'] and status[u'error'][u'message'].find(u'Callers must accept ToS') != -1:
          print u'''Please go to:

https://console.cloud.google.com/start

and accept the Terms of Service (ToS). As soon as you've accepted the ToS popup, you can return here and press enter.'''
          raw_input()
          create_again = True
          break
        else:
          print status
          sys.exit(1)
      if u'done' in status and status[u'done']:
        break
      sleep_time = i ** 2
      print u'Project still being created. Sleeping %s seconds' % sleep_time
      time.sleep(sleep_time)
    if create_again:
      continue
    if not u'done' in status or not status[u'done']:
      print u'Failed to create project: %s' % status
      sys.exit(1)
    elif u'error' in status:
      print status[u'error']
      sys.exit(2)
    break

  _, c = httplib2.Http(disable_ssl_certificate_validation=GC_Values[GC_NO_VERIFY_SSL]).request(GAM_PROJECT_APIS, u'GET')
  apis = c.splitlines()
  serveman = googleapiclient.discovery.build(u'servicemanagement', u'v1', http=http, cache_discovery=False)
  Action.Set(Action.ENABLE)
  count = len(apis)
  performActionNumItems(count, Entity.API)
  Indent.Increment()
  i = 0
  for api in apis:
    i += 1
    while True:
      try:
        callGAPI(serveman.services(), u'enable',
                 throw_reasons=[GAPI_FAILED_PRECONDITION, GAPI_FORBIDDEN],
                 serviceName=api, body={u'consumerId': project_name})
        entityActionPerformed([Entity.API, api], i, count)
        break
      except GAPI_failedPrecondition as e:
        entityActionFailedWarning([Entity.API, api], e.message, i, count)
        writeStderr(u'\nPlease resolve error as described above\n\n')
        raw_input(u'Press enter once resolved and we will try enabling the API again.')
      except GAPI_forbidden as e:
        entityActionFailedWarning([Entity.API, api], e.message, i, count)
        break
  Indent.Decrement()
  iam = googleapiclient.discovery.build(u'iam', u'v1', http=http, cache_discovery=False)
  print u'Creating Service Account'
  service_account = callGAPI(iam.projects().serviceAccounts(), u'create',
                             name=u'projects/%s' % project_id,
                             body={u'accountId': project_id, u'serviceAccount': {u'displayName': u'GAM Project'}})
  body = {u'privateKeyType': u'TYPE_GOOGLE_CREDENTIALS_FILE', u'keyAlgorithm': u'KEY_ALG_RSA_2048'}
  key = callGAPI(iam.projects().serviceAccounts().keys(), u'create',
                 name=service_account[u'name'], body=body)
  oauth2service_data = base64.b64decode(key[u'privateKeyData'])
  service_account_file = GC_Values[GC_OAUTH2SERVICE_JSON]
  if os.path.isfile(service_account_file):
    service_account_file = u'%s-%s' % (service_account_file, project_id)
  writeFile(service_account_file, oauth2service_data, continueOnError=False)
  console_credentials_url = u'https://console.developers.google.com/apis/credentials?project=%s' % project_id
  print u'''Please go to:

%s

1. Click the blue "Create credentials" button. Choose "OAuth client ID".
2. Click the blue "Configure consent screen" button. Enter "GAM" for "Product name to show to users".
3. Leave other fields blank. Click "Save" button.
3. Choose "Other" and click the blue "Create" button.
4. Copy your "client ID" value.

''' % console_credentials_url
  client_id = raw_input(u'Enter your Client ID: ')
  print u'\nNow go back to your browser and copy your client secret.'
  client_secret = raw_input(u'Enter your Client Secret: ')
  cs_data = u'''{
    "installed": {
        "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
        "auth_uri": "https://accounts.google.com/o/oauth2/auth",
        "client_id": "%s",
        "client_secret": "%s",
        "project_id": "%s",
        "redirect_uris": [
            "urn:ietf:wg:oauth:2.0:oob",
            "http://localhost"
        ],
        "token_uri": "https://accounts.google.com/o/oauth2/token"
    }
}''' % (client_id, client_secret, project_id)
  client_secrets_file = GC_Values[GC_CLIENT_SECRETS_JSON]
  if os.path.isfile(client_secrets_file):
    client_secrets_file = u'%s-%s' % (client_secrets_file, project_id)
  writeFile(client_secrets_file, cs_data, continueOnError=False)
  print u'''Almost there! Now please switch back to your browser and:

1. Click OK to close "OAuth client" popup if it's still open.
2. Click "Manage service accounts" on the right of the screen.
3. Click the 3 dots to the right of your service account.
4. Choose Edit.
5. Check the "Enable G Suite Domain-wide Delegation" box and click Save.
'''
  raw_input(u'Press Enter when done...')
  print u'That\'s it! Your GAM Project is created and ready to use.'

# gam delete projects [<EmailAddress>]
def doDeleteProjects():
  # Leave undocumented. Most users should never need.
  # Deletes all projects with ID gam-project-*
  login_hint = getEmailAddress(noUid=True, optional=True)
  checkForExtraneousArguments()
  crm, _ = getCRMService(login_hint)
  projects = callGAPIpages(crm.projects(), u'list', items=u'projects')
  gam_pids = [project[u'projectId'] for project in projects if project[u'projectId'].startswith(u'gam-project-')]
  count = len(gam_pids)
  performActionNumItems(count, Entity.PROJECT)
  Indent.Increment()
  i = 0
  for pid in gam_pids:
    i += 1
    try:
      callGAPI(crm.projects(), u'delete',
               throw_reasons=[GAPI_FORBIDDEN],
               projectId=pid)
      entityActionPerformed([Entity.PROJECT, pid], i, count)
    except GAPI_forbidden as e:
      entityActionFailedWarning([Entity.PROJECT, pid], e.message, i, count)
  Indent.Decrement()

# gam whatis <EmailItem> [noinfo]
def doWhatIs():
  def _showEmailType(entityType, email):
    printEntity([entityType, email])

  cd = buildGAPIObject(DIRECTORY_API)
  email = getEmailAddress()
  showInfo = False if checkArgumentPresent(NOINFO_ARGUMENT) else True
  if not showInfo:
    checkForExtraneousArguments()
  try:
    result = callGAPI(cd.users(), u'get',
                      throw_reasons=GAPI_USER_GET_THROW_REASONS,
                      userKey=email, fields=u'id,primaryEmail')
    if (result[u'primaryEmail'].lower() == email) or (result[u'id'] == email):
      if showInfo:
        infoUsers(entityList=[email])
      else:
        _showEmailType(Entity.USER, email)
      setSysExitRC(ENTITY_IS_A_USER_RC)
    else:
      if showInfo:
        infoAliases(entityList=[email])
      else:
        _showEmailType(Entity.USER_ALIAS, email)
      setSysExitRC(ENTITY_IS_A_USER_ALIAS_RC)
    return
  except (GAPI_userNotFound, GAPI_badRequest):
    pass
  except (GAPI_domainNotFound, GAPI_forbidden, GAPI_backendError, GAPI_systemError):
    entityUnknownWarning(Entity.EMAIL, email)
    setSysExitRC(ENTITY_IS_UKNOWN_RC)
    return
  try:
    result = callGAPI(cd.groups(), u'get',
                      throw_reasons=GAPI_GROUP_GET_THROW_REASONS,
                      groupKey=email, fields=u'id,email')
    if (result[u'email'].lower() == email) or (result[u'id'] == email):
      if showInfo:
        infoGroups(entityList=[email])
      else:
        _showEmailType(Entity.GROUP, email)
      setSysExitRC(ENTITY_IS_A_GROUP_RC)
    else:
      if showInfo:
        infoAliases(entityList=[email])
      else:
        _showEmailType(Entity.GROUP_ALIAS, email)
      setSysExitRC(ENTITY_IS_A_GROUP_ALIAS_RC)
    return
  except GAPI_groupNotFound:
    pass
  except (GAPI_domainNotFound, GAPI_forbidden, GAPI_badRequest):
    entityUnknownWarning(Entity.EMAIL, email)
    setSysExitRC(ENTITY_IS_UKNOWN_RC)
    return
  entityUnknownWarning(Entity.EMAIL, email)
  setSysExitRC(ENTITY_IS_UKNOWN_RC)

# Report choices
#
NL_SPACES_PATTERN = re.compile(r'\n +')

REPORTS_PARAMETERS_SIMPLE_TYPES = [u'intValue', u'boolValue', u'datetimeValue', u'stringValue',]

REPORT_CHOICES_MAP = {
  u'admin': u'admin',
  u'calendar': u'calendar',
  u'calendars': u'calendar',
  u'customer': u'customer',
  u'customers': u'customer',
  u'doc': u'drive',
  u'docs': u'drive',
  u'domain': u'customer',
  u'drive': u'drive',
  u'group': u'groups',
  u'groups': u'groups',
  u'login': u'login',
  u'logins': u'login',
  u'mobile': u'mobile',
  u'token': u'token',
  u'tokens': u'token',
  u'user': u'user',
  u'users': u'user',
  }

REPORT_ACTIVITIES_TIME_OBJECTS = [u'time']

# gam report <users|user> [todrive [<ToDriveAttributes>]] [nodatechange] [maxresults <Number>]
#	[date <Date>] [user all|<UserItem>] [select <UserTypeEntity>] [filter|filters <String>] [fields|parameters <String>]
# gam report <customers|customer|domain> [todrive [<ToDriveAttributes>]] [nodatechange]
#	[date <Date>] [fields|parameters <String>]
# gam report <admin|calendars|drive|docs|doc|groups|group|logins|login|mobile|tokens|token> [todrive [<ToDriveAttributes>]] [maxresults <Number>]
#	[([start <Time>] [end <Time>])|yesterday] [user all|<UserItem>] [select <UserTypeEntity>] [event <String>] [filter|filters <String>] [fields|parameters <String>] [ip <String>] countsonly summary
def doReport():

  def _adjustDate(errMsg):
    match_date = re.match(u'Data for dates later than (.*) is not yet available. Please check back later', errMsg)
    if not match_date:
      match_date = re.match(u'Start date can not be later than (.*)', errMsg)
    if (not match_date) or noDateChange:
      printWarningMessage(DATA_NOT_AVALIABLE_RC, errMsg)
      return None
    return str(match_date.group(1))

  report = getChoice(REPORT_CHOICES_MAP, mapChoice=True)
  rep = buildGAPIObject(REPORTS_API)
  customerId = GC_Values[GC_CUSTOMER_ID]
  if customerId == MY_CUSTOMER:
    customerId = None
  maxResults = try_date = filters = parameters = actorIpAddress = startTime = endTime = startDateTime = endDateTime = eventName = None
  countsOnly = exitUserLoop = noDateChange = normalizeUsers = select = summary = False
  todrive = {}
  userKey = u'all'
  filtersUserValid = report != u'customer'
  usageReports = report in [u'customer', u'user']
  activityReports = not usageReports
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'todrive':
      todrive = getTodriveParameters()
    elif usageReports and myarg == u'date':
      try_date = getYYYYMMDD()
    elif usageReports and myarg == u'nodatechange':
      noDateChange = True
    elif usageReports and myarg in [u'fields', u'parameters']:
      parameters = getString(OB_STRING)
    elif activityReports and myarg == u'start':
      startDateTime, tzinfo, startTime = getFullTime(True)
      earliestDateTime = datetime.datetime.now(tzinfo)-datetime.timedelta(days=180)
      if startDateTime < earliestDateTime:
        CLArgs.Backup()
        usageErrorExit(MESSAGE_INVALID_TIME_RANGE.format(u'start', startTime, PHRASE_GOOGLE_EARLIEST_REPORT_TIME, earliestDateTime.isoformat()))
      if endDateTime and endDateTime < startDateTime:
        CLArgs.Backup()
        usageErrorExit(MESSAGE_INVALID_TIME_RANGE.format(u'end', endTime, u'start', startTime))
    elif activityReports and myarg == u'end':
      endDateTime, _, endTime = getFullTime(True)
      if startDateTime and endDateTime < startDateTime:
        CLArgs.Backup()
        usageErrorExit(MESSAGE_INVALID_TIME_RANGE.format(u'end', endTime, u'start', startTime))
    elif activityReports and myarg == u'yesterday':
      today = datetime.date.today()
      startDateTime = datetime.datetime(today.year, today.month, today.day, tzinfo=iso8601.UTC)+datetime.timedelta(days=-1)
      startTime = startDateTime.isoformat()
      endDateTime = datetime.datetime(today.year, today.month, today.day, tzinfo=iso8601.UTC)+datetime.timedelta(seconds=-1)
      endTime = endDateTime.isoformat()
    elif activityReports and myarg == u'event':
      eventName = getString(OB_STRING)
    elif activityReports and myarg == u'ip':
      actorIpAddress = getString(OB_STRING)
    elif activityReports and myarg == u'countsonly':
      countsOnly = True
    elif activityReports and myarg == u'summary':
      summary = True
    elif filtersUserValid and myarg == u'maxresults':
      maxResults = getInteger(minVal=1, maxVal=1000)
    elif filtersUserValid and myarg == u'user':
      userKey = getString(OB_EMAIL_ADDRESS)
    elif filtersUserValid and myarg == u'select':
      _, users = getEntityToModify(defaultEntityType=CL_ENTITY_USERS)
      select = True
    elif filtersUserValid and myarg in [u'filter', u'filters']:
      filters = getString(OB_STRING)
    else:
      unknownArgumentExit()
  if try_date is None:
    try_date = str(datetime.date.today())
  if report == u'user':
    if select:
      page_message = None
      normalizeUsers = True
    elif userKey == u'all':
      printGettingAccountEntitiesInfo(Entity.USER)
      page_message = getPageMessage(showTotal=False)
      users = [u'all']
    else:
      Entity.SetGetting(Entity.USER)
      page_message = getPageMessage(showTotal=False)
      users = [normalizeEmailAddressOrUID(userKey)]
    titles, csvRows = initializeTitlesCSVfile([u'email', u'date'])
    i = 0
    count = len(users)
    for user in users:
      i += 1
      if normalizeUsers:
        user = normalizeEmailAddressOrUID(user)
      while True:
        try:
          feed = callGAPIpages(rep.userUsageReport(), u'get', u'usageReports',
                               page_message=page_message,
                               throw_reasons=[GAPI_INVALID, GAPI_BAD_REQUEST, GAPI_FORBIDDEN],
                               date=try_date, userKey=user, customerId=customerId, filters=filters, parameters=parameters,
                               maxResults=maxResults)
          while feed:
            user_report = feed.popleft()
            if u'entity' not in user_report:
              continue
            row = {u'email': user_report[u'entity'][u'userEmail'], u'date': try_date}
            for item in user_report.get(u'parameters', {}):
              name = item[u'name']
              if name not in titles[u'set']:
                addTitleToCSVfile(name, titles)
              for ptype in REPORTS_PARAMETERS_SIMPLE_TYPES:
                if ptype in item:
                  if ptype != u'datetimeValue':
                    row[name] = item[ptype]
                  else:
                    row[name] = formatLocalTime(item[ptype])
                  break
              else:
                row[name] = u''
            csvRows.append(row)
          break
        except GAPI_invalid as e:
          try_date = _adjustDate(e.message)
          if not try_date:
            return
        except GAPI_badRequest:
          if user != u'all':
            entityUnknownWarning(Entity.USER, user, i, count)
          else:
            printErrorMessage(BAD_REQUEST_RC, PHRASE_BAD_REQUEST)
            exitUserLoop = True
          break
        except GAPI_forbidden:
          accessErrorExit(None)
      if exitUserLoop:
        break
    sortCSVTitles([u'email', u'date'], titles)
    writeCSVfile(csvRows, titles, u'User Reports - {0}'.format(try_date), todrive)
  elif report == u'customer':
    titles, csvRows = initializeTitlesCSVfile([u'name', u'value', u'client_id'])
    auth_apps = []
    while True:
      try:
        usage = callGAPIpages(rep.customerUsageReports(), u'get', u'usageReports',
                              throw_reasons=[GAPI_INVALID, GAPI_FORBIDDEN],
                              customerId=customerId, date=try_date, parameters=parameters)
        for item in usage[0][u'parameters']:
          name = item[u'name']
          for ptype in REPORTS_PARAMETERS_SIMPLE_TYPES:
            if ptype in item:
              if ptype != u'datetimeValue':
                csvRows.append({u'name': name, u'value': item[ptype]})
              else:
                csvRows.append({u'name': name, u'value': formatLocalTime(item[ptype])})
              break
          else:
            if u'msgValue' in item:
              if name == u'accounts:authorized_apps':
                for subitem in item[u'msgValue']:
                  app = {}
                  for an_item in subitem:
                    if an_item == u'client_name':
                      app[u'name'] = u'App: {0}'.format(convertCRsNLs(subitem[an_item]))
                    elif an_item == u'num_users':
                      app[u'value'] = u'{0} users'.format(subitem[an_item])
                    elif an_item == u'client_id':
                      app[u'client_id'] = subitem[an_item]
                  auth_apps.append(app)
        for row in auth_apps: # put apps at bottom
          csvRows.append(row)
        break
      except GAPI_invalid as e:
        try_date = _adjustDate(e.message)
        if not try_date:
          return
      except GAPI_forbidden:
        accessErrorExit(None)
    writeCSVfile(csvRows, titles, u'Customer Report - {0}'.format(try_date), todrive)
  else:     # admin, calendar, drive, groups, login, mobile, token
    if select:
      page_message = None
      normalizeUsers = True
    elif userKey == u'all':
      printGettingAccountEntitiesInfo(Entity.ACTIVITY)
      page_message = getPageMessage(showTotal=False)
      users = [u'all']
    else:
      Entity.SetGetting(Entity.ACTIVITY)
      page_message = getPageMessage(showTotal=False)
      users = [normalizeEmailAddressOrUID(userKey)]
    eventCounts = {}
    titles, csvRows = initializeTitlesCSVfile(None)
    i = 0
    count = len(users)
    for user in users:
      i += 1
      if normalizeUsers:
        user = normalizeEmailAddressOrUID(user)
      try:
        feed = callGAPIpages(rep.activities(), u'list', u'items',
                             page_message=page_message,
                             throw_reasons=[GAPI_BAD_REQUEST, GAPI_INVALID, GAPI_AUTH_ERROR],
                             applicationName=report, userKey=user, customerId=customerId,
                             actorIpAddress=actorIpAddress, startTime=startTime, endTime=endTime, eventName=eventName, filters=filters,
                             maxResults=maxResults)
        while feed:
          activity = feed.popleft()
          events = activity[u'events']
          del activity[u'events']
          if not countsOnly:
            activity_row = flattenJSON(activity, time_objects=REPORT_ACTIVITIES_TIME_OBJECTS)
            for event in events:
              for item in event.get(u'parameters', []):
                if item[u'name'] in [u'start_time', u'end_time']:
                  val = item.get(u'intValue')
                  if val is not None:
                    item[u'dateTimeValue'] = datetime.datetime.fromtimestamp(int(val)-62135683200, GC_Values[GC_TIMEZONE]).isoformat()
                    item.pop(u'intValue')
                if u'value' in item:
                  item[u'value'] = NL_SPACES_PATTERN.sub(u'', item[u'value'])
              row = flattenJSON(event)
              row.update(activity_row)
              addRowTitlesToCSVfile(row, csvRows, titles)
          elif not summary:
            actor = activity[u'actor'][u'email']
            eventCounts.setdefault(actor, {})
            for event in events:
              eventCounts[actor].setdefault(event[u'name'], 0)
              eventCounts[actor][event[u'name']] += 1
          else:
            for event in events:
              eventCounts.setdefault(event[u'name'], 0)
              eventCounts[event[u'name']] += 1
      except GAPI_badRequest:
        if user != u'all':
          entityUnknownWarning(Entity.USER, user, i, count)
        else:
          printErrorMessage(BAD_REQUEST_RC, PHRASE_BAD_REQUEST)
          break
      except GAPI_invalid as e:
        systemErrorExit(GOOGLE_API_ERROR_RC, e.message)
      except GAPI_authError:
        accessErrorExit(None)
    if not countsOnly:
      sortCSVTitles([u'name',], titles)
    elif not summary:
      addTitlesToCSVfile([u'emailAddress',], titles)
      for actor, events in eventCounts.items():
        row = {u'emailAddress': actor}
        for event, count in events.items():
          row[event] = count
        addRowTitlesToCSVfile(row, csvRows, titles)
      sortCSVTitles([u'emailAddress',], titles)
    else:
      addTitlesToCSVfile([u'event', u'count'], titles)
      for event in sorted(eventCounts):
        csvRows.append({u'event': event, u'count': eventCounts[event]})
    writeCSVfile(csvRows, titles, u'{0} Activity Report'.format(report.capitalize()), todrive)

# gam create domainalias|aliasdomain <DomainAlias> <DomainName>
def doCreateDomainAlias():
  cd = buildGAPIObject(DIRECTORY_API)
  body = {u'domainAliasName': getString(OB_DOMAIN_ALIAS)}
  body[u'parentDomainName'] = getString(OB_DOMAIN_NAME)
  checkForExtraneousArguments()
  try:
    callGAPI(cd.domainAliases(), u'insert',
             throw_reasons=[GAPI_DOMAIN_NOT_FOUND, GAPI_DUPLICATE, GAPI_BAD_REQUEST, GAPI_NOT_FOUND, GAPI_FORBIDDEN],
             customer=GC_Values[GC_CUSTOMER_ID], body=body, fields=u'')
    entityActionPerformed([Entity.DOMAIN, body[u'parentDomainName'], Entity.DOMAIN_ALIAS, body[u'domainAliasName']])
  except GAPI_domainNotFound:
    entityActionFailedWarning([Entity.DOMAIN, body[u'parentDomainName']], PHRASE_DOES_NOT_EXIST)
  except GAPI_duplicate:
    entityActionFailedWarning([Entity.DOMAIN, body[u'parentDomainName'], Entity.DOMAIN_ALIAS, body[u'domainAliasName']], PHRASE_DUPLICATE)
  except (GAPI_badRequest, GAPI_notFound, GAPI_forbidden):
    accessErrorExit(cd)

# gam delete domainalias|aliasdomain <DomainAlias>
def doDeleteDomainAlias():
  cd = buildGAPIObject(DIRECTORY_API)
  domainAliasName = getString(OB_DOMAIN_ALIAS)
  checkForExtraneousArguments()
  try:
    callGAPI(cd.domainAliases(), u'delete',
             throw_reasons=[GAPI_DOMAIN_ALIAS_NOT_FOUND, GAPI_BAD_REQUEST, GAPI_NOT_FOUND, GAPI_FORBIDDEN],
             customer=GC_Values[GC_CUSTOMER_ID], domainAliasName=domainAliasName)
    entityActionPerformed([Entity.DOMAIN_ALIAS, domainAliasName])
  except GAPI_domainAliasNotFound:
    entityActionFailedWarning([Entity.DOMAIN_ALIAS, domainAliasName], PHRASE_DOES_NOT_EXIST)
  except (GAPI_badRequest, GAPI_notFound, GAPI_forbidden):
    accessErrorExit(cd)

DOMAIN_ALIAS_PRINT_ORDER = [u'parentDomainName', u'creationTime', u'verified',]

def _showDomainAlias(alias, alias_skip_objects):
  printEntity([Entity.DOMAIN_ALIAS, alias[u'domainAliasName']])
  Indent.Increment()
  if u'creationTime' in alias:
    alias[u'creationTime'] = formatLocalTimestamp(alias[u'creationTime'])
  for field in DOMAIN_ALIAS_PRINT_ORDER:
    if field in alias:
      printKeyValueList([field, alias[field]])
      alias_skip_objects.append(field)
  showJSON(None, alias, alias_skip_objects)
  Indent.Decrement()

# gam info domainalias|aliasdomain <DomainAlias>
def doInfoDomainAlias():
  cd = buildGAPIObject(DIRECTORY_API)
  domainAliasName = getString(OB_DOMAIN_ALIAS)
  checkForExtraneousArguments()
  try:
    result = callGAPI(cd.domainAliases(), u'get',
                      throw_reasons=[GAPI_DOMAIN_ALIAS_NOT_FOUND, GAPI_BAD_REQUEST, GAPI_NOT_FOUND, GAPI_FORBIDDEN],
                      customer=GC_Values[GC_CUSTOMER_ID], domainAliasName=domainAliasName)
    alias_skip_objects = [u'domainAliasName',]
    _showDomainAlias(result, alias_skip_objects)
  except GAPI_domainAliasNotFound:
    entityActionFailedWarning([Entity.DOMAIN_ALIAS, domainAliasName], PHRASE_DOES_NOT_EXIST)
  except (GAPI_badRequest, GAPI_notFound, GAPI_forbidden):
    accessErrorExit(cd)

# gam print domainaliases [todrive [<ToDriveAttributes>]]
def doPrintDomainAliases():
  cd = buildGAPIObject(DIRECTORY_API)
  todrive = {}
  titles, csvRows = initializeTitlesCSVfile([u'domainAliasName',])
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'todrive':
      todrive = getTodriveParameters()
    else:
      unknownArgumentExit()
  try:
    result = callGAPI(cd.domainAliases(), u'list',
                      throw_reasons=[GAPI_BAD_REQUEST, GAPI_NOT_FOUND, GAPI_FORBIDDEN],
                      customer=GC_Values[GC_CUSTOMER_ID])
    for domainAlias in result.get(u'domainAliases', []):
      row = {}
      for attr in domainAlias:
        if attr in [u'kind', u'etag']:
          continue
        if attr == u'creationTime':
          domainAlias[attr] = formatLocalTimestamp(domainAlias[attr])
        row[attr] = domainAlias[attr]
        if attr not in titles[u'set']:
          addTitleToCSVfile(attr, titles)
      csvRows.append(row)
  except (GAPI_badRequest, GAPI_notFound, GAPI_forbidden):
    accessErrorExit(cd)
  writeCSVfile(csvRows, titles, u'Domain Aliases', todrive)

# gam create domain <DomainName>
def doCreateDomain():
  cd = buildGAPIObject(DIRECTORY_API)
  body = {u'domainName': getString(OB_DOMAIN_NAME)}
  checkForExtraneousArguments()
  try:
    callGAPI(cd.domains(), u'insert',
             throw_reasons=[GAPI_DUPLICATE, GAPI_BAD_REQUEST, GAPI_NOT_FOUND, GAPI_FORBIDDEN],
             customer=GC_Values[GC_CUSTOMER_ID], body=body, fields=u'')
    entityActionPerformed([Entity.DOMAIN, body[u'domainName']])
  except GAPI_duplicate:
    entityDuplicateWarning(Entity.DOMAIN, body[u'domainName'])
  except (GAPI_badRequest, GAPI_notFound, GAPI_forbidden):
    accessErrorExit(cd)

# gam update domain <DomainName> primary
def doUpdateDomain():
  cd = buildGAPIObject(DIRECTORY_API)
  domainName = getString(OB_DOMAIN_NAME)
  body = {}
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'primary':
      body[u'customerDomain'] = domainName
    else:
      unknownArgumentExit()
  if not body:
    missingArgumentExit(u'primary')
  try:
    callGAPI(cd.customers(), u'patch',
             throw_reasons=[GAPI_DOMAIN_NOT_VERIFIED_SECONDARY, GAPI_BAD_REQUEST, GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN],
             customerKey=GC_Values[GC_CUSTOMER_ID], body=body, fields=u'')
    entityActionPerformedMessage([Entity.DOMAIN, domainName], PHRASE_NOW_THE_PRIMARY_DOMAIN)
  except GAPI_domainNotVerifiedSecondary:
    entityActionFailedWarning([Entity.DOMAIN, domainName], PHRASE_DOMAIN_NOT_VERIFIED_SECONDARY)
  except (GAPI_badRequest, GAPI_resourceNotFound, GAPI_forbidden):
    accessErrorExit(cd)

# gam delete domain <DomainName>
def doDeleteDomain():
  cd = buildGAPIObject(DIRECTORY_API)
  domainName = getString(OB_DOMAIN_NAME)
  checkForExtraneousArguments()
  try:
    callGAPI(cd.domains(), u'delete',
             throw_reasons=[GAPI_BAD_REQUEST, GAPI_NOT_FOUND, GAPI_FORBIDDEN],
             customer=GC_Values[GC_CUSTOMER_ID], domainName=domainName)
    entityActionPerformed([Entity.DOMAIN, domainName])
  except (GAPI_badRequest, GAPI_notFound, GAPI_forbidden):
    accessErrorExit(cd)

DOMAIN_PRINT_ORDER = [u'customerDomain', u'creationTime', u'isPrimary', u'verified',]

# gam info domain [<DomainName>]
def doInfoDomain():
  if (not CLArgs.ArgumentsRemaining()) or (CLArgs.Current().lower() == u'logo'):
    doInfoInstance()
    return
  cd = buildGAPIObject(DIRECTORY_API)
  domainName = getString(OB_DOMAIN_NAME)
  checkForExtraneousArguments()
  try:
    result = callGAPI(cd.domains(), u'get',
                      throw_reasons=[GAPI_DOMAIN_NOT_FOUND, GAPI_BAD_REQUEST, GAPI_NOT_FOUND, GAPI_FORBIDDEN],
                      customer=GC_Values[GC_CUSTOMER_ID], domainName=domainName)
    skip_objects = [u'domainName', u'domainAliases']
    printEntity([Entity.DOMAIN, result[u'domainName']])
    Indent.Increment()
    if u'creationTime' in result:
      result[u'creationTime'] = formatLocalTimestamp(result[u'creationTime'])
    for field in DOMAIN_PRINT_ORDER:
      if field in result:
        printKeyValueList([field, result[field]])
        skip_objects.append(field)
    field = u'domainAliases'
    aliases = result.get(field)
    if aliases:
      skip_objects.append(field)
      alias_skip_objects = [u'domainAliasName',]
      for alias in aliases:
        _showDomainAlias(alias, alias_skip_objects)
        showJSON(None, alias, alias_skip_objects)
    showJSON(None, result, skip_objects)
    Indent.Decrement()
  except GAPI_domainNotFound:
    entityActionFailedWarning([Entity.DOMAIN, domainName], PHRASE_DOES_NOT_EXIST)
  except (GAPI_badRequest, GAPI_notFound, GAPI_forbidden):
    accessErrorExit(cd)

# gam print domains [todrive [<ToDriveAttributes>]]
def doPrintDomains():
  cd = buildGAPIObject(DIRECTORY_API)
  todrive = {}
  titles, csvRows = initializeTitlesCSVfile([u'domainName',])
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'todrive':
      todrive = getTodriveParameters()
    else:
      unknownArgumentExit()
  try:
    domains = callGAPI(cd.domains(), u'list',
                       throw_reasons=[GAPI_BAD_REQUEST, GAPI_NOT_FOUND, GAPI_FORBIDDEN],
                       customer=GC_Values[GC_CUSTOMER_ID])
    for domain in domains[u'domains']:
      row = {}
      domain[u'type'] = [u'secondary', u'primary'][domain[u'isPrimary']]
      for attr in domain:
        if attr in [u'kind', u'etag', u'domainAliases', u'isPrimary']:
          continue
        if attr == u'creationTime':
          domain[attr] = formatLocalTimestamp(domain[attr])
        row[attr] = domain[attr]
        if attr not in titles[u'set']:
          addTitleToCSVfile(attr, titles)
      csvRows.append(row)
      if u'domainAliases' in domain:
        for aliasdomain in domain[u'domainAliases']:
          aliasdomain[u'domainName'] = aliasdomain[u'domainAliasName']
          del aliasdomain[u'domainAliasName']
          aliasdomain[u'type'] = u'alias'
          row = {}
          for attr in aliasdomain:
            if attr in [u'kind', u'etag']:
              continue
            if attr == u'creationTime':
              aliasdomain[attr] = formatLocalTimestamp(aliasdomain[attr])
            row[attr] = aliasdomain[attr]
            if attr not in titles[u'set']:
              addTitleToCSVfile(attr, titles)
          csvRows.append(row)
  except (GAPI_badRequest, GAPI_notFound, GAPI_forbidden):
    accessErrorExit(cd)
  writeCSVfile(csvRows, titles, u'Domains', todrive)

# gam print adminroles|roles [todrive [<ToDriveAttributes>]]
def doPrintAdminRoles():
  cd = buildGAPIObject(DIRECTORY_API)
  todrive = {}
  titles, csvRows = initializeTitlesCSVfile([u'roleId', u'roleName', u'roleDescription', u'isSuperAdminRole', u'isSystemRole'])
  fields = u'nextPageToken,items({0})'.format(u','.join(titles[u'list']))
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'todrive':
      todrive = getTodriveParameters()
    else:
      unknownArgumentExit()
  try:
    roles = callGAPIpages(cd.roles(), u'list', u'items',
                          throw_reasons=[GAPI_BAD_REQUEST, GAPI_CUSTOMER_NOT_FOUND, GAPI_FORBIDDEN],
                          customer=GC_Values[GC_CUSTOMER_ID], fields=fields)
    for role in roles:
      row = {}
      for attr, value in role.items():
        row[attr] = value
      csvRows.append(row)
  except (GAPI_badRequest, GAPI_customerNotFound, GAPI_forbidden):
    accessErrorExit(cd)
  writeCSVfile(csvRows, titles, u'Admin Roles', todrive)

def buildOrgUnitIdToNameMap():
  cd = buildGAPIObject(DIRECTORY_API)
  try:
    result = callGAPI(cd.orgunits(), u'list',
                      throw_reasons=[GAPI_BAD_REQUEST, GAPI_INVALID_CUSTOMER_ID, GAPI_LOGIN_REQUIRED],
                      customerId=GC_Values[GC_CUSTOMER_ID],
                      fields=u'organizationUnits(orgUnitPath,orgUnitId)', type=u'all')
    GM_Globals[GM_MAP_ORGUNIT_ID_TO_NAME] = {}
    for orgUnit in result[u'organizationUnits']:
      GM_Globals[GM_MAP_ORGUNIT_ID_TO_NAME][orgUnit[u'orgUnitId']] = orgUnit[u'orgUnitPath']
  except (GAPI_badRequest, GAPI_invalidCustomerId, GAPI_loginRequired):
    accessErrorExit(cd)

def orgunit_from_orgunitid(orgunitid):
  if not GM_Globals[GM_MAP_ORGUNIT_ID_TO_NAME]:
    buildOrgUnitIdToNameMap()
  return GM_Globals[GM_MAP_ORGUNIT_ID_TO_NAME].get(orgunitid, orgunitid)

def buildRoleIdToNameToIdMap():
  cd = buildGAPIObject(DIRECTORY_API)
  try:
    result = callGAPIpages(cd.roles(), u'list', u'items',
                           throw_reasons=[GAPI_BAD_REQUEST, GAPI_CUSTOMER_NOT_FOUND, GAPI_FORBIDDEN],
                           customer=GC_Values[GC_CUSTOMER_ID],
                           fields=u'nextPageToken,items(roleId,roleName)',
                           maxResults=100)
    GM_Globals[GM_MAP_ROLE_ID_TO_NAME] = {}
    GM_Globals[GM_MAP_ROLE_NAME_TO_ID] = {}
    for role in result:
      GM_Globals[GM_MAP_ROLE_ID_TO_NAME][role[u'roleId']] = role[u'roleName']
      GM_Globals[GM_MAP_ROLE_NAME_TO_ID][role[u'roleName']] = role[u'roleId']
  except (GAPI_badRequest, GAPI_customerNotFound, GAPI_forbidden):
    accessErrorExit(cd)

def role_from_roleid(roleid):
  if not GM_Globals[GM_MAP_ROLE_ID_TO_NAME]:
    buildRoleIdToNameToIdMap()
  return GM_Globals[GM_MAP_ROLE_ID_TO_NAME].get(roleid, roleid)

def roleid_from_role(role):
  if not GM_Globals[GM_MAP_ROLE_NAME_TO_ID]:
    buildRoleIdToNameToIdMap()
  return GM_Globals[GM_MAP_ROLE_NAME_TO_ID].get(role, None)

def buildUserIdToNameMap():
  cd = buildGAPIObject(DIRECTORY_API)
  try:
    result = callGAPIpages(cd.users(), u'list', u'users',
                           customer=GC_Values[GC_CUSTOMER_ID],
                           throw_reasons=[GAPI_BAD_REQUEST, GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN],
                           fields=u'nextPageToken,users(id,primaryEmail)',
                           maxResults=GC_Values[GC_USER_MAX_RESULTS])
    GM_Globals[GM_MAP_USER_ID_TO_NAME] = {}
    for user in result:
      GM_Globals[GM_MAP_USER_ID_TO_NAME][user[u'id']] = user[u'primaryEmail']
  except (GAPI_badRequest, GAPI_resourceNotFound, GAPI_forbidden):
    accessErrorExit(cd)

def user_from_userid(userid):
  if not GM_Globals[GM_MAP_USER_ID_TO_NAME]:
    buildUserIdToNameMap()
  return GM_Globals[GM_MAP_USER_ID_TO_NAME].get(userid, u'')

def getRoleId():
  role = getString(OB_ROLE_ID)
  if role[:3].lower() == u'id:':
    roleId = role[3:]
  elif role[:4].lower() == u'uid:':
    roleId = role[4:]
  else:
    roleId = roleid_from_role(role)
    if not roleId:
      CLArgs.Backup()
      invalidChoiceExit(GM_Globals[GM_MAP_ROLE_NAME_TO_ID])
  return (role, roleId)

def getOrgUnitId(cd):
  orgUnit = getOrgUnitItem()
  if orgUnit[:3] == u'id:':
    return (orgUnit, orgUnit[3:])
  try:
    result = callGAPI(cd.orgunits(), u'get',
                      throw_reasons=[GAPI_INVALID_ORGUNIT, GAPI_ORGUNIT_NOT_FOUND, GAPI_BACKEND_ERROR, GAPI_BAD_REQUEST, GAPI_INVALID_CUSTOMER_ID, GAPI_LOGIN_REQUIRED],
                      customerId=GC_Values[GC_CUSTOMER_ID], orgUnitPath=makeOrgUnitPathRelative(orgUnit),
                      fields=u'orgUnitId')
    return (orgUnit, result[u'orgUnitId'][3:])
  except (GAPI_invalidOrgunit, GAPI_orgunitNotFound, GAPI_backendError):
    CLArgs.Backup()
    usageErrorExit(formatKeyValueList(Indent.Spaces(),
                                      [Entity.Singular(Entity.ORGANIZATIONAL_UNIT), orgUnit,
                                       PHRASE_DOES_NOT_EXIST],
                                      u'\n'))
  except (GAPI_badRequest, GAPI_invalidCustomerId, GAPI_loginRequired):
    accessErrorExit(cd)

ADMIN_SCOPE_TYPE_CHOICE_MAP = {u'customer': u'CUSTOMER', u'orgunit': u'ORG_UNIT', u'org': u'ORG_UNIT', u'ou': u'ORG_UNIT'}

# gam create admin <UserItem> <RoleItem> customer|(org_unit <OrgUnitItem>)
def doCreateAdmin():
  cd = buildGAPIObject(DIRECTORY_API)
  user = getEmailAddress()
  body = {u'assignedTo': convertEmailToUserID(user)}
  role, roleId = getRoleId()
  body[u'roleId'] = roleId
  body[u'scopeType'] = getChoice(ADMIN_SCOPE_TYPE_CHOICE_MAP, mapChoice=True)
  if body[u'scopeType'] == u'ORG_UNIT':
    orgUnit, body[u'orgUnitId'] = getOrgUnitId(cd)
    scope = u'ORG_UNIT {0}'.format(orgUnit)
  else:
    scope = u'CUSTOMER'
  checkForExtraneousArguments()
  try:
    result = callGAPI(cd.roleAssignments(), u'insert',
                      throw_reasons=[GAPI_INTERNAL_ERROR, GAPI_BAD_REQUEST, GAPI_CUSTOMER_NOT_FOUND, GAPI_FORBIDDEN, GAPI_INVALID_ORGUNIT, GAPI_DUPLICATE],
                      customer=GC_Values[GC_CUSTOMER_ID], body=body, fields=u'roleAssignmentId')
    entityActionPerformedMessage([Entity.ROLE_ASSIGNMENT_ID, result[u'roleAssignmentId']],
                                 u'{0} {1}, {2} {3}, {4} {5}'.format(Entity.Singular(Entity.USER), user,
                                                                     Entity.Singular(Entity.ROLE), role,
                                                                     Entity.Singular(Entity.SCOPE), scope))
  except GAPI_internalError:
    pass
  except (GAPI_badRequest, GAPI_customerNotFound, GAPI_forbidden):
    accessErrorExit(cd)
  except GAPI_invalidOrgunit:
    entityActionFailedWarning([Entity.ADMINISTRATOR, user], PHRASE_INVALID_ORGUNIT)
  except GAPI_duplicate:
    entityActionFailedWarning([Entity.ADMINISTRATOR, user, Entity.ROLE, role], PHRASE_DUPLICATE)

# gam delete admin <RoleAssignmentId>
def doDeleteAdmin():
  cd = buildGAPIObject(DIRECTORY_API)
  roleAssignmentId = getString(OB_ROLE_ASSIGNMENT_ID)
  checkForExtraneousArguments()
  try:
    callGAPI(cd.roleAssignments(), u'delete',
             throw_reasons=[GAPI_NOT_FOUND, GAPI_BAD_REQUEST, GAPI_CUSTOMER_NOT_FOUND, GAPI_FORBIDDEN],
             customer=GC_Values[GC_CUSTOMER_ID], roleAssignmentId=roleAssignmentId)
    entityActionPerformed([Entity.ROLE_ASSIGNMENT_ID, roleAssignmentId])
  except GAPI_notFound:
    entityActionFailedWarning([Entity.ROLE_ASSIGNMENT_ID, roleAssignmentId], PHRASE_DOES_NOT_EXIST)
  except (GAPI_badRequest, GAPI_customerNotFound, GAPI_forbidden):
    accessErrorExit(cd)

# gam print admins [todrive [<ToDriveAttributes>]] [user <UserItem>] [role <RoleItem>]
def doPrintAdmins():
  cd = buildGAPIObject(DIRECTORY_API)
  roleId = None
  userKey = None
  todrive = {}
  titles, csvRows = initializeTitlesCSVfile([u'roleAssignmentId', u'roleId', u'role', u'assignedTo', u'assignedToUser', u'scopeType', u'orgUnitId', u'orgUnit'])
  fields = u'nextPageToken,items({0})'.format(u','.join([u'roleAssignmentId', u'roleId', u'assignedTo', u'scopeType', u'orgUnitId']))
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'user':
      userKey = getEmailAddress()
    elif myarg == u'role':
      _, roleId = getRoleId()
    else:
      unknownArgumentExit()
  try:
    feed = callGAPIpages(cd.roleAssignments(), u'list', u'items',
                         throw_reasons=[GAPI_INVALID, GAPI_BAD_REQUEST, GAPI_CUSTOMER_NOT_FOUND, GAPI_FORBIDDEN],
                         customer=GC_Values[GC_CUSTOMER_ID], userKey=userKey, roleId=roleId, fields=fields)
    while feed:
      admin = feed.popleft()
      row = {}
      for attr, value in admin.items():
        if attr == u'assignedTo':
          row[u'assignedToUser'] = user_from_userid(value)
        elif attr == u'roleId':
          row[u'role'] = role_from_roleid(value)
        elif attr == u'orgUnitId':
          value = u'id:{0}'.format(value)
          row[u'orgUnit'] = orgunit_from_orgunitid(value)
        row[attr] = value
      csvRows.append(row)
    writeCSVfile(csvRows, titles, u'Admins', todrive)
  except GAPI_invalid:
    entityUnknownWarning(Entity.USER, userKey)
  except (GAPI_badRequest, GAPI_customerNotFound, GAPI_forbidden):
    accessErrorExit(cd)

ADDRESS_FIELDS_PRINT_ORDER = [u'contactName', u'organizationName', u'addressLine1', u'addressLine2', u'addressLine3', u'locality', u'region', u'postalCode', u'countryCode']

# gam info customer
def doInfoCustomer():
  cd = buildGAPIObject(DIRECTORY_API)
  checkForExtraneousArguments()
  try:
    customer_info = callGAPI(cd.customers(), u'get',
                             throw_reasons=[GAPI_BAD_REQUEST, GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN],
                             customerKey=GC_Values[GC_CUSTOMER_ID])
    printKeyValueList([u'Customer ID', customer_info[u'id']])
    printKeyValueList([u'Primary Domain', customer_info[u'customerDomain']])
    printKeyValueList([u'Customer Creation Time', formatLocalTime(customer_info[u'customerCreationTime'])])
    verified = callGAPI(cd.domains(), u'get',
                        customer=customer_info[u'id'], domainName=customer_info[u'customerDomain'], fields=u'verified')[u'verified']
    printKeyValueList([u'Primary Domain Verified', verified])
    printKeyValueList([u'Default Language', customer_info[u'language']])
    if u'postalAddress' in customer_info:
      printKeyValueList([u'Address', None])
      Indent.Increment()
      for field in ADDRESS_FIELDS_PRINT_ORDER:
        if field in customer_info[u'postalAddress']:
          printKeyValueList([field, customer_info[u'postalAddress'][field]])
      Indent.Decrement()
    if u'phoneNumber' in customer_info:
      printKeyValueList([u'Phone', customer_info[u'phoneNumber']])
    printKeyValueList([u'Admin Secondary Email', customer_info[u'alternateEmail']])
  except (GAPI_badRequest, GAPI_resourceNotFound, GAPI_forbidden):
    accessErrorExit(cd)

ADDRESS_FIELDS_ARGUMENT_MAP = {
  u'contact': u'contactName', u'contactname': u'contactName',
  u'name': u'organizationName', u'organizationname': u'organizationName',
  u'address1': u'addressLine1', u'addressline1': u'addressLine1',
  u'address2': u'addressLine2', u'addressline2': u'addressLine2',
  u'address3': u'addressLine3', u'addressline3': u'addressLine3',
  u'locality': u'locality',
  u'region': u'region',
  u'postalcode': u'postalCode',
  u'country': u'countryCode', u'countrycode': u'countryCode',
  }

# gam update customer [primary <DomainName>] [adminsecondaryemail|alternateemail <EmailAddress>] [language <LanguageCode] [phone|phonenumber <String>]
#	[contact|contactname <String>] [name|organizationname <String>]
#	[address1|addressline1 <String>] [address2|addressline2 <String>] [address3|addressline3 <String>]
#	[locality <String>] [region <String>] [postalcode <String>] [country|countrycode <String>]
def doUpdateCustomer():
  cd = buildGAPIObject(DIRECTORY_API)
  body = {}
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in ADDRESS_FIELDS_ARGUMENT_MAP:
      body.setdefault(u'postalAddress', {})
      body[u'postalAddress'][ADDRESS_FIELDS_ARGUMENT_MAP[myarg]] = getString(OB_STRING, minLen=0)
    elif myarg == u'primary':
      body[u'customerDomain'] = getString(OB_DOMAIN_NAME)
    elif myarg in [u'adminsecondaryemail', u'alternateemail']:
      body[u'alternateEmail'] = getEmailAddress(noUid=True)
    elif myarg in [u'phone', u'phonenumber']:
      body[u'phoneNumber'] = getString(OB_STRING, minLen=0)
    elif myarg == u'language':
      body[u'language'] = getChoice(LANGUAGE_CODES_MAP, mapChoice=True)
    else:
      unknownArgumentExit()
  if body:
    try:
      callGAPI(cd.customers(), u'patch',
               throw_reasons=[GAPI_DOMAIN_NOT_VERIFIED_SECONDARY, GAPI_BAD_REQUEST, GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN],
               customerKey=GC_Values[GC_CUSTOMER_ID], body=body, fields=u'')
      entityActionPerformed([Entity.CUSTOMER_ID, GC_Values[GC_CUSTOMER_ID]])
    except GAPI_domainNotVerifiedSecondary:
      entityActionFailedWarning([Entity.CUSTOMER_ID, GC_Values[GC_CUSTOMER_ID], Entity.DOMAIN, body[u'customerDomain']], PHRASE_DOMAIN_NOT_VERIFIED_SECONDARY)
    except (GAPI_badRequest, GAPI_resourceNotFound, GAPI_forbidden):
      accessErrorExit(cd)

SERVICE_NAME_TO_ID_MAP = {u'Drive and Docs': u'55656082996', u'Google+': u'553547912911',}

def appID2app(dt, appID):
  for serviceName, serviceID in SERVICE_NAME_TO_ID_MAP.items():
    if appID == serviceID:
      return serviceName
  try:
    online_services = callGAPIpages(dt.applications(), u'list', u'applications',
                                    throw_reasons=[GAPI_UNKNOWN_ERROR, GAPI_FORBIDDEN],
                                    customerId=GC_Values[GC_CUSTOMER_ID])
    for online_service in online_services:
      if appID == online_service[u'id']:
        return online_service[u'name']
    return u'applicationId: {0}'.format(appID)
  except (GAPI_unknownError, GAPI_forbidden):
    accessErrorExit(None)

SERVICE_NAME_CHOICES_MAP = {
  u'drive': u'Drive and Docs',
  u'drive and docs': u'Drive and Docs',
  u'googledrive': u'Drive and Docs',
  u'gdrive': u'Drive and Docs',
  }

def getService(dt):
  serviceName = getString(OB_SERVICE_NAME).lower()
  if serviceName in SERVICE_NAME_CHOICES_MAP:
    return (SERVICE_NAME_CHOICES_MAP[serviceName], SERVICE_NAME_TO_ID_MAP[SERVICE_NAME_CHOICES_MAP[serviceName]])
  try:
    online_services = callGAPIpages(dt.applications(), u'list', u'applications',
                                    throw_reasons=[GAPI_UNKNOWN_ERROR, GAPI_FORBIDDEN],
                                    customerId=GC_Values[GC_CUSTOMER_ID])
    serviceNameList = []
    for online_service in online_services:
      olServiceName = online_service[u'name']
      if olServiceName:
        if serviceName == olServiceName.lower():
          return (olServiceName, online_service[u'id'])
        serviceNameList.append(olServiceName.lower())
    CLArgs.Backup()
    invalidChoiceExit(serviceNameList)
  except (GAPI_unknownError, GAPI_forbidden):
    accessErrorExit(None)

# gam create datatransfer|transfer <OldOwnerID> <Service> <NewOwnerID> (<ParameterKey> <ParameterValue>)*
def doCreateDataTransfer():
  dt = buildGAPIObject(DATATRANSFER_API)
  old_owner = getEmailAddress()
  body = {u'oldOwnerUserId': convertEmailToUserID(old_owner)}
  serviceName, serviceID = getService(dt)
  new_owner = getEmailAddress()
  body[u'newOwnerUserId'] = convertEmailToUserID(new_owner)
  if body[u'oldOwnerUserId'] == body[u'newOwnerUserId']:
    CLArgs.Backup()
    usageErrorExit(PHRASE_NEW_OWNER_MUST_DIFFER_FROM_OLD_OWNER)
  parameters = {}
  while CLArgs.ArgumentsRemaining():
    key = getString(OB_PARAMETER_KEY).upper()
    parameters[key] = getString(OB_PARAMETER_VALUE).upper().split(u',')
  body[u'applicationDataTransfers'] = [{u'applicationId': serviceID}]
  for key in parameters:
    body[u'applicationDataTransfers'][0].setdefault(u'applicationTransferParams', [])
    body[u'applicationDataTransfers'][0][u'applicationTransferParams'].append({u'key': key, u'value': parameters[key]})
  result = callGAPI(dt.transfers(), u'insert',
                    body=body, fields=u'id')
  entityActionPerformed([Entity.TRANSFER_REQUEST, None])
  Indent.Increment()
  printEntity([Entity.TRANSFER_ID, result[u'id']])
  printEntity([Entity.SERVICE, serviceName])
  printKeyValueList([PHRASE_FROM, old_owner])
  printKeyValueList([PHRASE_TO, new_owner])
  Indent.Decrement()

# gam info datatransfer|transfer <TransferID>
def doInfoDataTransfer():
  dt = buildGAPIObject(DATATRANSFER_API)
  dtId = getString(OB_TRANSFER_ID)
  checkForExtraneousArguments()
  try:
    transfer = callGAPI(dt.transfers(), u'get',
                        throw_reasons=[GAPI_NOT_FOUND],
                        dataTransferId=dtId)
    printEntity([Entity.TRANSFER_ID, transfer[u'id']])
    Indent.Increment()
    printKeyValueList([u'Old Owner', convertUserIDtoEmail(transfer[u'oldOwnerUserId'])])
    printKeyValueList([u'New Owner', convertUserIDtoEmail(transfer[u'newOwnerUserId'])])
    printKeyValueList([u'Request Time', transfer[u'requestTime']])
    for app in transfer[u'applicationDataTransfers']:
      printKeyValueList([u'Application', appID2app(dt, app[u'applicationId'])])
      Indent.Increment()
      printKeyValueList([u'Status', app[u'applicationTransferStatus']])
      printKeyValueList([u'Parameters', None])
      Indent.Increment()
      if u'applicationTransferParams' in app:
        for param in app[u'applicationTransferParams']:
          printKeyValueList([param[u'key'], u','.join(param[u'value'])])
      else:
        printKeyValueList([u'None', None])
      Indent.Decrement()
      Indent.Decrement()
    Indent.Decrement()
    printBlankLine()
  except GAPI_notFound:
    entityActionFailedWarning([Entity.TRANSFER_ID, dtId], PHRASE_DOES_NOT_EXIST)

DATA_TRANSFER_STATUS_MAP = {
  u'completed': u'completed',
  u'failed': u'failed',
  u'pending': u'pending',
  u'inprogress': u'inProgress',
  }

# gam print datatransfers|transfers [todrive [<ToDriveAttributes>]] [olduser|oldowner <UserItem>] [newuser|newowner <UserItem>] [status <String>] [delimiter <String>]]
def doPrintDataTransfers():
  dt = buildGAPIObject(DATATRANSFER_API)
  newOwnerUserId = None
  oldOwnerUserId = None
  status = None
  todrive = {}
  titles, csvRows = initializeTitlesCSVfile([u'id',])
  delimiter = GC_Values[GC_CSV_OUTPUT_FIELD_DELIMITER]
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg in [u'olduser', u'oldowner']:
      oldOwnerUserId = convertEmailToUserID(getEmailAddress())
    elif myarg in [u'newuser', u'newowner']:
      newOwnerUserId = convertEmailToUserID(getEmailAddress())
    elif myarg == u'status':
      status = getChoice(DATA_TRANSFER_STATUS_MAP, mapChoice=True)
    elif myarg == u'delimiter':
      delimiter = getDelimiter()
    else:
      unknownArgumentExit()
  try:
    transfers = callGAPIpages(dt.transfers(), u'list', u'dataTransfers',
                              throw_reasons=[GAPI_UNKNOWN_ERROR, GAPI_FORBIDDEN],
                              customerId=GC_Values[GC_CUSTOMER_ID], status=status,
                              newOwnerUserId=newOwnerUserId, oldOwnerUserId=oldOwnerUserId)
    for transfer in transfers:
      for i in range(len(transfer[u'applicationDataTransfers'])):
        a_transfer = {}
        a_transfer[u'oldOwnerUserEmail'] = convertUserIDtoEmail(transfer[u'oldOwnerUserId'])
        a_transfer[u'newOwnerUserEmail'] = convertUserIDtoEmail(transfer[u'newOwnerUserId'])
        a_transfer[u'requestTime'] = transfer[u'requestTime']
        a_transfer[u'applicationId'] = transfer[u'applicationDataTransfers'][i][u'applicationId']
        a_transfer[u'application'] = appID2app(dt, a_transfer[u'applicationId'])
        a_transfer[u'status'] = transfer[u'applicationDataTransfers'][i][u'applicationTransferStatus']
        a_transfer[u'id'] = transfer[u'id']
        for param in transfer[u'applicationDataTransfers'][i].get(u'applicationTransferParams', []):
          a_transfer[param[u'key']] = delimiter.join(param[u'value'])
      addRowTitlesToCSVfile(a_transfer, csvRows, titles)
  except (GAPI_unknownError, GAPI_forbidden):
    accessErrorExit(None)
  writeCSVfile(csvRows, titles, u'Data Transfers', todrive)

# gam print transferapps
def doPrintTransferApps():
  dt = buildGAPIObject(DATATRANSFER_API)
  checkForExtraneousArguments()
  try:
    apps = callGAPIpages(dt.applications(), u'list', u'applications',
                         throw_reasons=[GAPI_UNKNOWN_ERROR, GAPI_FORBIDDEN],
                         customerId=GC_Values[GC_CUSTOMER_ID])
    for app in apps:
      showJSON(None, app)
      printBlankLine()
  except (GAPI_unknownError, GAPI_forbidden):
    accessErrorExit(None)

UPDATE_INSTANCE_CHOICES = [u'logo', u'ssokey', u'ssosettings',]

# gam update instance
def doUpdateInstance():
  adminSettingsObject = getAdminSettingsObject()
  command = getChoice(UPDATE_INSTANCE_CHOICES)
  try:
    if command == u'logo':
# gam update instance logo <FileName>
      logoFile = getString(OB_FILE_NAME)
      checkForExtraneousArguments()
      logoImage = readFile(logoFile, mode=u'rb')
      callGData(adminSettingsObject, u'UpdateDomainLogo',
                throw_errors=[GDATA_INVALID_DOMAIN, GDATA_INVALID_VALUE],
                logoImage=logoImage)
      entityActionPerformed([Entity.INSTANCE, u'', Entity.LOGO, logoFile])
    elif command == u'ssosettings':
# gam update instance sso_settings [enabled <Boolean>] [sign_on_uri <URI>] [sign_out_uri <URI>] [password_uri <URI>] [whitelist <CIDRnetmask>] [use_domain_specific_issuer <Boolean>]
      enableSSO = samlSignonUri = samlLogoutUri = changePasswordUri = ssoWhitelist = useDomainSpecificIssuer = None
      while CLArgs.ArgumentsRemaining():
        myarg = getArgument()
        if myarg == u'enabled':
          enableSSO = getBoolean()
        elif myarg == u'signonuri':
          samlSignonUri = getString(OB_URI)
        elif myarg == u'signouturi':
          samlLogoutUri = getString(OB_URI)
        elif myarg == u'passworduri':
          changePasswordUri = getString(OB_URI)
        elif myarg == u'whitelist':
          ssoWhitelist = getString(OB_CIDR_NETMASK)
        elif myarg == u'usedomainspecificissuer':
          useDomainSpecificIssuer = getBoolean()
        else:
          unknownArgumentExit()
      callGData(adminSettingsObject, u'UpdateSSOSettings',
                throw_errors=[GDATA_INVALID_DOMAIN, GDATA_INVALID_VALUE],
                enableSSO=enableSSO, samlSignonUri=samlSignonUri, samlLogoutUri=samlLogoutUri, changePasswordUri=changePasswordUri,
                ssoWhitelist=ssoWhitelist, useDomainSpecificIssuer=useDomainSpecificIssuer)
      entityActionPerformed([Entity.INSTANCE, u'', Entity.SSO_SETTINGS, u''])
    elif command == u'ssokey':
# gam update instance sso_key <FileName>
      keyFile = getString(OB_FILE_NAME)
      checkForExtraneousArguments()
      keyData = readFile(keyFile)
      callGData(adminSettingsObject, u'UpdateSSOKey',
                throw_errors=[GDATA_INVALID_DOMAIN, GDATA_INVALID_VALUE],
                signingKey=keyData)
      entityActionPerformed([Entity.INSTANCE, u'', Entity.SSO_KEY, keyFile])
  except GData_invalidDomain as e:
    printErrorMessage(INVALID_DOMAIN_RC, e.message)
  except GData_invalidValue as e:
    printErrorMessage(INVALID_DOMAIN_VALUE_RC, e.message)
#
MAXIMUM_USERS_MAP = [u'maximumNumberOfUsers', u'Maximum Users']
CURRENT_USERS_MAP = [u'currentNumberOfUsers', u'Current Users']
DOMAIN_EDITION_MAP = [u'edition', u'Domain Edition']
CUSTOMER_PIN_MAP = [u'customerPIN', u'Customer PIN']
SINGLE_SIGN_ON_SETTINGS_MAP = [u'enableSSO', u'SSO Enabled',
                               u'samlSignonUri', u'SSO Signon Page',
                               u'samlLogoutUri', u'SSO Logout Page',
                               u'changePasswordUri', u'SSO Password Page',
                               u'ssoWhitelist', u'SSO Whitelist IPs',
                               u'useDomainSpecificIssuer', u'SSO Use Domain Specific Issuer']
SINGLE_SIGN_ON_SIGNING_KEY_MAP = [u'algorithm', u'SSO Key Algorithm',
                                  u'format', u'SSO Key Format',
                                  u'modulus', u'SSO Key Modulus',
                                  u'exponent', u'SSO Key Exponent',
                                  u'yValue', u'SSO Key yValue',
                                  u'signingKey', u'Full SSO Key']

# gam info instance [logo <FileName>]
def doInfoInstance():
  def _printAdminSetting(service, propertyTitleMap):
    try:
      result = callGAPI(service, u'get',
                        throw_reasons=[GAPI_DOMAIN_NOT_FOUND, GAPI_INVALID],
                        domainName=GC_Values[GC_DOMAIN])
      if result and (u'entry' in result) and (u'apps$property' in result[u'entry']):
        for i in range(0, len(propertyTitleMap), 2):
          asProperty = propertyTitleMap[i]
          for entry in result[u'entry'][u'apps$property']:
            if entry[u'name'] == asProperty:
              printKeyValueList([propertyTitleMap[i+1], entry[u'value']])
              break
    except GAPI_domainNotFound:
      systemErrorExit(INVALID_DOMAIN_RC, formatKeyValueList(u'', [Entity.Singular(Entity.DOMAIN), GC_Values[GC_DOMAIN], PHRASE_DOES_NOT_EXIST], u''))
    except GAPI_invalid:
      pass

  if checkArgumentPresent(LOGO_ARGUMENT):
    Action.Set(Action.DOWNLOAD)
    logoFile = getString(OB_FILE_NAME)
    checkForExtraneousArguments()
    _, data = httplib2.Http(disable_ssl_certificate_validation=GC_Values[GC_NO_VERIFY_SSL]).request(u'http://www.google.com/a/cpanel/{0}/images/logo.gif'.format(GC_Values[GC_DOMAIN]), u'GET')
    writeFile(logoFile, data)
    entityActionPerformed([Entity.INSTANCE, u'', Entity.LOGO, logoFile])
    return
  checkForExtraneousArguments()
  doInfoCustomer()
  adm = buildGAPIObject(ADMIN_SETTINGS_API)
  _printAdminSetting(adm.maximumNumberOfUsers(), MAXIMUM_USERS_MAP)
  _printAdminSetting(adm.currentNumberOfUsers(), CURRENT_USERS_MAP)
  _printAdminSetting(adm.edition(), DOMAIN_EDITION_MAP)
  _printAdminSetting(adm.customerPIN(), CUSTOMER_PIN_MAP)
  _printAdminSetting(adm.ssoGeneral(), SINGLE_SIGN_ON_SETTINGS_MAP)
  _printAdminSetting(adm.ssoSigningKey(), SINGLE_SIGN_ON_SIGNING_KEY_MAP)

# gam create org|ou <String> [description <String>] [parent <OrgUnitItem>] [inherit|noinherit|(blockinheritance <Boolean>)] [buildpath]
def doCreateOrg():

  def _createOrg(body, parentPath, fullPath):
    try:
      callGAPI(cd.orgunits(), u'insert',
               throw_reasons=[GAPI_INVALID_PARENT_ORGUNIT, GAPI_INVALID_ORGUNIT, GAPI_BACKEND_ERROR, GAPI_BAD_REQUEST, GAPI_INVALID_CUSTOMER_ID, GAPI_LOGIN_REQUIRED],
               customerId=GC_Values[GC_CUSTOMER_ID], body=body, fields=u'')
      entityActionPerformed([Entity.ORGANIZATIONAL_UNIT, fullPath])
    except GAPI_invalidParentOrgunit:
      entityActionFailedWarning([Entity.ORGANIZATIONAL_UNIT, fullPath, Entity.PARENT_ORGANIZATIONAL_UNIT, parentPath], PHRASE_ENTITY_DOES_NOT_EXIST.format(Entity.Singular(Entity.PARENT_ORGANIZATIONAL_UNIT)))
      return False
    except (GAPI_invalidOrgunit, GAPI_backendError):
      entityDuplicateWarning(Entity.ORGANIZATIONAL_UNIT, fullPath)
    except (GAPI_badRequest, GAPI_invalidCustomerId, GAPI_loginRequired):
      checkEntityAFDNEorAccessErrorExit(cd, Entity.ORGANIZATIONAL_UNIT, fullPath)
    return True

  cd = buildGAPIObject(DIRECTORY_API)
  name = getOrgUnitItem(pathOnly=True, absolutePath=False)
  parent = u''
  body = {}
  buildPath = False
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'description':
      body[u'description'] = getString(OB_STRING, minLen=0).replace(u'\\n', u'\n')
    elif myarg == u'parent':
      parent = getOrgUnitItem()
    elif myarg == u'noinherit':
      body[u'blockInheritance'] = True
    elif myarg == u'inherit':
      body[u'blockInheritance'] = False
    elif myarg in [u'blockinheritance', u'inheritanceblocked']:
      body[u'blockInheritance'] = getBoolean()
    elif myarg == u'buildpath':
      buildPath = True
    else:
      unknownArgumentExit()
  if parent.startswith(u'id:'):
    parentPath = None
    try:
      parentPath = callGAPI(cd.orgunits(), u'get',
                            throw_reasons=[GAPI_INVALID_ORGUNIT, GAPI_ORGUNIT_NOT_FOUND, GAPI_BACKEND_ERROR, GAPI_BAD_REQUEST, GAPI_INVALID_CUSTOMER_ID, GAPI_LOGIN_REQUIRED],
                            customerId=GC_Values[GC_CUSTOMER_ID], orgUnitPath=parent, fields=u'orgUnitPath')[u'orgUnitPath']
    except (GAPI_invalidOrgunit, GAPI_orgunitNotFound, GAPI_backendError):
      pass
    except (GAPI_badRequest, GAPI_invalidCustomerId, GAPI_loginRequired):
      errMsg = accessErrorMessage(cd)
      if errMsg:
        systemErrorExit(INVALID_DOMAIN_RC, errMsg)
    if not parentPath and not buildPath:
      entityActionFailedWarning([Entity.ORGANIZATIONAL_UNIT, name, Entity.PARENT_ORGANIZATIONAL_UNIT, parent], PHRASE_ENTITY_DOES_NOT_EXIST.format(Entity.Singular(Entity.PARENT_ORGANIZATIONAL_UNIT)))
      return
    parent = parentPath
  if parent == u'/':
    orgUnitPath = parent+name
  else:
    orgUnitPath = parent+u'/'+name
  if orgUnitPath.count(u'/') > 1:
    body[u'parentOrgUnitPath'], body[u'name'] = orgUnitPath.rsplit(u'/', 1)
  else:
    body[u'parentOrgUnitPath'] = u'/'
    body[u'name'] = orgUnitPath[1:]
  parent = body[u'parentOrgUnitPath']
  if _createOrg(body, parent, orgUnitPath) or not buildPath:
    return
  description = body.pop(u'description', None)
  fullPath = u'/'
  getPath = u''
  orgNames = orgUnitPath.split(u'/')
  n = len(orgNames)-1
  for i in range(1, n+1):
    body[u'parentOrgUnitPath'] = fullPath
    if fullPath != u'/':
      fullPath += u'/'
    fullPath += orgNames[i]
    if getPath != u'':
      getPath += u'/'
    getPath += orgNames[i]
    try:
      callGAPI(cd.orgunits(), u'get',
               throw_reasons=[GAPI_INVALID_ORGUNIT, GAPI_ORGUNIT_NOT_FOUND, GAPI_BACKEND_ERROR, GAPI_BAD_REQUEST, GAPI_INVALID_CUSTOMER_ID, GAPI_LOGIN_REQUIRED],
               customerId=GC_Values[GC_CUSTOMER_ID], orgUnitPath=getPath, fields=u'')
      printKeyValueList([Entity.Singular(Entity.ORGANIZATIONAL_UNIT), fullPath, PHRASE_EXISTS])
    except (GAPI_invalidOrgunit, GAPI_orgunitNotFound, GAPI_backendError):
      body[u'name'] = orgNames[i]
      if i == n and description:
        body[u'description'] = description
      if not _createOrg(body, body[u'parentOrgUnitPath'], fullPath):
        return
    except (GAPI_badRequest, GAPI_invalidCustomerId, GAPI_loginRequired):
      checkEntityAFDNEorAccessErrorExit(cd, Entity.ORGANIZATIONAL_UNIT, fullPath)

def checkOrgUnitPathExists(cd, orgUnitPath, i=0, count=0):
  if orgUnitPath == u'/':
    return orgUnitPath
  orgUnitPath = makeOrgUnitPathRelative(orgUnitPath)
  try:
    return callGAPI(cd.orgunits(), u'get',
                    throw_reasons=[GAPI_INVALID_ORGUNIT, GAPI_ORGUNIT_NOT_FOUND, GAPI_BACKEND_ERROR, GAPI_BAD_REQUEST, GAPI_INVALID_CUSTOMER_ID, GAPI_LOGIN_REQUIRED],
                    customerId=GC_Values[GC_CUSTOMER_ID], orgUnitPath=orgUnitPath, fields=u'orgUnitPath')[u'orgUnitPath']
  except (GAPI_invalidOrgunit, GAPI_orgunitNotFound, GAPI_backendError):
    pass
  except (GAPI_badRequest, GAPI_invalidCustomerId, GAPI_loginRequired):
    errMsg = accessErrorMessage(cd)
    if errMsg:
      systemErrorExit(INVALID_DOMAIN_RC, errMsg)
  entityActionFailedWarning([Entity.ORGANIZATIONAL_UNIT, orgUnitPath], PHRASE_DOES_NOT_EXIST, i, count)
  return None

def _doUpdateOrgs(entityList):

  def _callbackMoveCrOSesToOrgUnit(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      entityActionPerformed([Entity.ORGANIZATIONAL_UNIT, ri[RI_ENTITY], Entity.CROS_DEVICE, ri[RI_ITEM]], int(ri[RI_J]), int(ri[RI_JCOUNT]))
    else:
      http_status, reason, message = checkGAPIError(exception)
      if reason in [GAPI_BAD_REQUEST, GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN]:
        checkEntityItemValueAFDNEorAccessErrorExit(cd, Entity.ORGANIZATIONAL_UNIT, ri[RI_ENTITY], Entity.CROS_DEVICE, ri[RI_ITEM], int(ri[RI_J]), int(ri[RI_JCOUNT]))
      else:
        errMsg = getHTTPError({}, http_status, reason, message)
        entityActionFailedWarning([Entity.ORGANIZATIONAL_UNIT, ri[RI_ENTITY], Entity.CROS_DEVICE, ri[RI_ITEM]], errMsg, int(ri[RI_J]), int(ri[RI_JCOUNT]))

  _MOVE_USER_REASON_TO_MESSAGE_MAP = {GAPI_USER_NOT_FOUND: PHRASE_DOES_NOT_EXIST, GAPI_DOMAIN_NOT_FOUND: PHRASE_SERVICE_NOT_APPLICABLE, GAPI_FORBIDDEN: PHRASE_SERVICE_NOT_APPLICABLE}
  def _callbackMoveUsersToOrgUnit(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      entityActionPerformed([Entity.ORGANIZATIONAL_UNIT, ri[RI_ENTITY], Entity.USER, ri[RI_ITEM]], int(ri[RI_J]), int(ri[RI_JCOUNT]))
    else:
      http_status, reason, message = checkGAPIError(exception)
      errMsg = getHTTPError(_MOVE_USER_REASON_TO_MESSAGE_MAP, http_status, reason, message)
      entityActionFailedWarning([Entity.ORGANIZATIONAL_UNIT, ri[RI_ENTITY], Entity.USER, ri[RI_ITEM]], errMsg, int(ri[RI_J]), int(ri[RI_JCOUNT]))

  cd = buildGAPIObject(DIRECTORY_API)
  if checkArgumentPresent(MOVE_ADD_ARGUMENT):
    entityType, items = getEntityToModify(defaultEntityType=CL_ENTITY_USERS, crosAllowed=True)
    orgItemLists = items if isinstance(items, dict) else None
    checkForExtraneousArguments()
    Action.Set(Action.ADD)
    i = 0
    count = len(entityList)
    for orgUnitPath in entityList:
      i += 1
      if orgItemLists:
        items = orgItemLists[orgUnitPath]
      orgUnitPath = checkOrgUnitPathExists(cd, orgUnitPath, i, count)
      if not orgUnitPath:
        continue
      jcount = len(items)
      entityPerformActionNumItems([Entity.ORGANIZATIONAL_UNIT, orgUnitPath], jcount, [Entity.CROS_DEVICE, Entity.USER][entityType == CL_ENTITY_USERS], i, count)
      Indent.Increment()
      if entityType == CL_ENTITY_USERS:
        svcargs = dict([(u'userKey', None), (u'body', {u'orgUnitPath': orgUnitPath}), (u'fields', u'')]+GM_Globals[GM_EXTRA_ARGS_LIST])
        dbatch = googleapiclient.http.BatchHttpRequest(callback=_callbackMoveUsersToOrgUnit)
        bcount = 0
        j = 0
        for user in items:
          j += 1
          svcparms = svcargs.copy()
          svcparms[u'userKey'] = normalizeEmailAddressOrUID(user)
          dbatch.add(cd.users().patch(**svcparms), request_id=batchRequestID(orgUnitPath, 0, 0, j, jcount, svcparms[u'userKey']))
          bcount += 1
          if bcount >= GC_Values[GC_BATCH_SIZE]:
            dbatch.execute()
            dbatch = googleapiclient.http.BatchHttpRequest(callback=_callbackMoveUsersToOrgUnit)
            bcount = 0
        if bcount > 0:
          dbatch.execute()
      else:
        svcargs = dict([(u'customerId', GC_Values[GC_CUSTOMER_ID]), (u'deviceId', None), (u'body', {u'orgUnitPath': orgUnitPath}), (u'fields', u'')]+GM_Globals[GM_EXTRA_ARGS_LIST])
        dbatch = googleapiclient.http.BatchHttpRequest(callback=_callbackMoveCrOSesToOrgUnit)
        bcount = 0
        j = 0
        for deviceId in items:
          j += 1
          svcparms = svcargs.copy()
          svcparms[u'deviceId'] = deviceId
          dbatch.add(cd.chromeosdevices().patch(**svcparms), request_id=batchRequestID(orgUnitPath, 0, 0, j, jcount, deviceId))
          bcount += 1
          if bcount >= GC_Values[GC_BATCH_SIZE]:
            dbatch.execute()
            dbatch = googleapiclient.http.BatchHttpRequest(callback=_callbackMoveCrOSesToOrgUnit)
            bcount = 0
        if bcount > 0:
          dbatch.execute()
      Indent.Decrement()
  else:
    body = {}
    while CLArgs.ArgumentsRemaining():
      myarg = getArgument()
      if myarg == u'name':
        body[u'name'] = getString(OB_STRING)
      elif myarg == u'description':
        body[u'description'] = getString(OB_STRING, minLen=0).replace(u'\\n', u'\n')
      elif myarg == u'parent':
        parent = getOrgUnitItem()
        if parent.startswith(u'id:'):
          body[u'parentOrgUnitId'] = parent
        else:
          body[u'parentOrgUnitPath'] = parent
      elif myarg == u'noinherit':
        body[u'blockInheritance'] = True
      elif myarg == u'inherit':
        body[u'blockInheritance'] = False
      elif myarg in [u'blockinheritance', u'inheritanceblocked']:
        body[u'blockInheritance'] = getBoolean()
      else:
        unknownArgumentExit()
    i = 0
    count = len(entityList)
    for orgUnitPath in entityList:
      i += 1
      try:
        callGAPI(cd.orgunits(), u'update',
                 throw_reasons=[GAPI_INVALID_ORGUNIT, GAPI_ORGUNIT_NOT_FOUND, GAPI_BACKEND_ERROR, GAPI_BAD_REQUEST, GAPI_INVALID_CUSTOMER_ID, GAPI_LOGIN_REQUIRED],
                 customerId=GC_Values[GC_CUSTOMER_ID], orgUnitPath=makeOrgUnitPathRelative(orgUnitPath), body=body, fields=u'')
        entityActionPerformed([Entity.ORGANIZATIONAL_UNIT, orgUnitPath], i, count)
      except (GAPI_invalidOrgunit, GAPI_orgunitNotFound, GAPI_backendError):
        entityActionFailedWarning([Entity.ORGANIZATIONAL_UNIT, orgUnitPath], PHRASE_DOES_NOT_EXIST, i, count)
      except (GAPI_badRequest, GAPI_invalidCustomerId, GAPI_loginRequired):
        checkEntityAFDNEorAccessErrorExit(cd, Entity.ORGANIZATIONAL_UNIT, orgUnitPath)

# gam update orgs|ous <OrgUnitEntity> [name <String>] [description <String>] [parent <OrgUnitItem>] [inherit|noinherit|(blockinheritance <Boolean>)]
# gam update orgs|ous <OrgUnitEntity> add|move <CrosTypeEntity>|<UserTypeEntity>
def doUpdateOrgs():
  _doUpdateOrgs(getEntityList(OB_ORGUNIT_ENTITY, shlexSplit=True))

# gam update org|ou <OrgUnitItem> [name <String>] [description <String>]  [parent <OrgUnitItem>] [inherit|noinherit|(blockinheritance <Boolean>)]
# gam update org|ou <OrgUnitItem> add|move <CrosTypeEntity>|<UserTypeEntity>
def doUpdateOrg():
  _doUpdateOrgs([getOrgUnitItem()])

def _doDeleteOrgs(entityList):
  cd = buildGAPIObject(DIRECTORY_API)
  checkForExtraneousArguments()
  i = 0
  count = len(entityList)
  for orgUnitPath in entityList:
    i += 1
    try:
      orgUnitPath = makeOrgUnitPathAbsolute(orgUnitPath)
      callGAPI(cd.orgunits(), u'delete',
               throw_reasons=[GAPI_CONDITION_NOT_MET, GAPI_INVALID_ORGUNIT, GAPI_ORGUNIT_NOT_FOUND, GAPI_BACKEND_ERROR, GAPI_BAD_REQUEST, GAPI_INVALID_CUSTOMER_ID, GAPI_LOGIN_REQUIRED],
               customerId=GC_Values[GC_CUSTOMER_ID], orgUnitPath=makeOrgUnitPathRelative(orgUnitPath))
      entityActionPerformed([Entity.ORGANIZATIONAL_UNIT, orgUnitPath], i, count)
    except GAPI_conditionNotMet:
      entityActionFailedWarning([Entity.ORGANIZATIONAL_UNIT, orgUnitPath], PHRASE_HAS_CHILD_ORGS.format(Entity.Plural(Entity.ORGANIZATIONAL_UNIT)), i, count)
    except (GAPI_invalidOrgunit, GAPI_orgunitNotFound, GAPI_backendError):
      entityActionFailedWarning([Entity.ORGANIZATIONAL_UNIT, orgUnitPath], PHRASE_DOES_NOT_EXIST, i, count)
    except (GAPI_badRequest, GAPI_invalidCustomerId, GAPI_loginRequired):
      checkEntityAFDNEorAccessErrorExit(cd, Entity.ORGANIZATIONAL_UNIT, orgUnitPath)

# gam delete orgs|ous <OrgUnitEntity>
def doDeleteOrgs():
  _doDeleteOrgs(getEntityList(OB_ORGUNIT_ENTITY, shlexSplit=True))

# gam delete org|ou <OrgUnitItem>
def doDeleteOrg():
  _doDeleteOrgs([getOrgUnitItem()])

ORG_FIELD_INFO_ORDER = [u'orgUnitId', u'name', u'description', u'parentOrgUnitPath', u'parentOrgUnitId', u'blockInheritance']
ORG_FIELDS_WITH_CRS_NLS = [u'description']

def _doInfoOrgs(entityList):
  cd = buildGAPIObject(DIRECTORY_API)
  getUsers = True
  showChildren = False
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'nousers':
      getUsers = False
    elif myarg in [u'children', u'child']:
      showChildren = True
    else:
      unknownArgumentExit()
  i = 0
  count = len(entityList)
  for orgUnitPath in entityList:
    i += 1
    try:
      if orgUnitPath == u'/':
        orgs = callGAPI(cd.orgunits(), u'list',
                        throw_reasons=[GAPI_BAD_REQUEST, GAPI_INVALID_CUSTOMER_ID, GAPI_LOGIN_REQUIRED],
                        customerId=GC_Values[GC_CUSTOMER_ID], type=u'children',
                        fields=u'organizationUnits(parentOrgUnitId)')
        orgUnitPath = orgs[u'organizationUnits'][0][u'parentOrgUnitId']
      else:
        orgUnitPath = makeOrgUnitPathRelative(orgUnitPath)
      result = callGAPI(cd.orgunits(), u'get',
                        throw_reasons=[GAPI_INVALID_ORGUNIT, GAPI_ORGUNIT_NOT_FOUND, GAPI_BACKEND_ERROR, GAPI_BAD_REQUEST, GAPI_INVALID_CUSTOMER_ID, GAPI_LOGIN_REQUIRED],
                        customerId=GC_Values[GC_CUSTOMER_ID], orgUnitPath=orgUnitPath)
      printEntity([Entity.ORGANIZATIONAL_UNIT, result[u'orgUnitPath']], i, count)
      Indent.Increment()
      for field in ORG_FIELD_INFO_ORDER:
        value = result.get(field, None)
        if value is not None:
          if field not in ORG_FIELDS_WITH_CRS_NLS:
            printKeyValueList([field, value])
          else:
            printKeyValueList([field, convertCRsNLs(value)])
      if getUsers:
        orgUnitPath = result[u'orgUnitPath']
        users = callGAPIpages(cd.users(), u'list', u'users',
                              throw_reasons=[GAPI_BAD_REQUEST, GAPI_INVALID_INPUT, GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN],
                              customer=GC_Values[GC_CUSTOMER_ID], query=orgUnitPathQuery(orgUnitPath),
                              fields=u'nextPageToken,users(primaryEmail,orgUnitPath)',
                              maxResults=GC_Values[GC_USER_MAX_RESULTS])
        printEntitiesCount(Entity.USER, users)
        Indent.Increment()
        orgUnitPath = orgUnitPath.lower()
        for user in users:
          if orgUnitPath == user[u'orgUnitPath'].lower():
            printKeyValueList([user[u'primaryEmail']])
          elif showChildren:
            printKeyValueList([u'{0} (child)'.format(user[u'primaryEmail'])])
        Indent.Decrement()
      Indent.Decrement()
    except (GAPI_invalidInput, GAPI_invalidOrgunit, GAPI_orgunitNotFound, GAPI_backendError):
      entityActionFailedWarning([Entity.ORGANIZATIONAL_UNIT, orgUnitPath], PHRASE_DOES_NOT_EXIST, i, count)
    except (GAPI_badRequest, GAPI_invalidCustomerId, GAPI_loginRequired, GAPI_resourceNotFound, GAPI_forbidden):
      checkEntityAFDNEorAccessErrorExit(cd, Entity.ORGANIZATIONAL_UNIT, orgUnitPath)

# gam info orgs|ous <OrgUnitEntity> [nousers] [children|child]
def doInfoOrgs():
  _doInfoOrgs(getEntityList(OB_ORGUNIT_ENTITY, shlexSplit=True))

# gam info org|ou <OrgUnitItem> [nousers] [children|child]
def doInfoOrg():
  _doInfoOrgs([getOrgUnitItem()])

# CL argument: [API field name, CSV field title]
#
ORG_ARGUMENT_TO_PROPERTY_TITLE_MAP = {
  u'blockinheritance': [u'blockInheritance', u'InheritanceBlocked'],
  u'inheritanceblocked': [u'blockInheritance', u'InheritanceBlocked'],
  u'inherit': [u'blockInheritance', u'InheritanceBlocked'],
  u'description': [u'description', u'Description'],
  u'orgunitid': [u'orgUnitId', u'ID'],
  u'id': [u'orgUnitId', u'ID'],
  u'name': [u'name', u'Name'],
  u'orgunitpath': [u'orgUnitPath', u'Path'],
  u'path': [u'orgUnitPath', u'Path'],
  u'parentorgunitid': [u'parentOrgUnitId', u'ParentID'],
  u'parentid': [u'parentOrgUnitId', u'ParentID'],
  u'parentorgunitpath': [u'parentOrgUnitPath', u'Parent'],
  u'parent': [u'parentOrgUnitPath', u'Parent'],
  }
ORG_FIELD_PRINT_ORDER = [u'orgunitpath', u'id', u'name', u'description', u'parent', u'parentid', u'inherit']

# gam print orgs|ous [todrive [<ToDriveAttributes>]] [from_parent <OrgUnitItem>] [toplevelonly] [allfields|<OrgUnitFieldName>*|(fields <OrgUnitFieldNameList>)] [convertcrnl]
def doPrintOrgs():
  cd = buildGAPIObject(DIRECTORY_API)
  convertCRNL = GC_Values[GC_CSV_OUTPUT_CONVERT_CR_NL]
  listType = u'all'
  orgUnitPath = u'/'
  todrive = {}
  fieldsList = []
  fieldsTitles = {}
  titles, csvRows = initializeTitlesCSVfile(None)
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'toplevelonly':
      listType = u'children'
    elif myarg == u'fromparent':
      orgUnitPath = getOrgUnitItem()
    elif myarg == u'allfields':
      fieldsList = []
      fieldsTitles = {}
      titles, csvRows = initializeTitlesCSVfile(None)
      for field in ORG_FIELD_PRINT_ORDER:
        addFieldTitleToCSVfile(field, ORG_ARGUMENT_TO_PROPERTY_TITLE_MAP, fieldsList, fieldsTitles, titles)
    elif myarg in ORG_ARGUMENT_TO_PROPERTY_TITLE_MAP:
      addFieldTitleToCSVfile(myarg, ORG_ARGUMENT_TO_PROPERTY_TITLE_MAP, fieldsList, fieldsTitles, titles)
    elif myarg == u'fields':
      fieldNameList = getString(OB_FIELD_NAME_LIST)
      for field in fieldNameList.lower().replace(u',', u' ').split():
        if field in ORG_ARGUMENT_TO_PROPERTY_TITLE_MAP:
          addFieldTitleToCSVfile(field, ORG_ARGUMENT_TO_PROPERTY_TITLE_MAP, fieldsList, fieldsTitles, titles)
        else:
          CLArgs.Backup()
          invalidChoiceExit(ORG_ARGUMENT_TO_PROPERTY_TITLE_MAP.keys())
    elif myarg in [u'convertcrnl', u'converttextnl']:
      convertCRNL = True
    else:
      unknownArgumentExit()
  if not fieldsList:
    addFieldTitleToCSVfile(u'orgunitpath', ORG_ARGUMENT_TO_PROPERTY_TITLE_MAP, fieldsList, fieldsTitles, titles)
  printGettingAccountEntitiesInfo(Entity.ORGANIZATIONAL_UNIT)
  try:
    orgs = callGAPI(cd.orgunits(), u'list',
                    throw_reasons=[GAPI_ORGUNIT_NOT_FOUND, GAPI_BAD_REQUEST, GAPI_INVALID_CUSTOMER_ID, GAPI_LOGIN_REQUIRED],
                    customerId=GC_Values[GC_CUSTOMER_ID], type=listType, orgUnitPath=orgUnitPath, fields=u'organizationUnits({0})'.format(u','.join(set(fieldsList))))
  except GAPI_orgunitNotFound:
    entityActionFailedWarning([Entity.ORGANIZATIONAL_UNIT, orgUnitPath], PHRASE_DOES_NOT_EXIST)
    return
  except (GAPI_badRequest, GAPI_invalidCustomerId, GAPI_loginRequired):
    accessErrorExit(cd)
  if (not orgs) or (u'organizationUnits' not in orgs):
    printGettingAccountEntitiesDoneInfo(0)
    return
  printGettingAccountEntitiesDoneInfo(len(orgs[u'organizationUnits']))
  for orgUnit in orgs[u'organizationUnits']:
    row = {}
    for field in fieldsList:
      if convertCRNL and field in ORG_FIELDS_WITH_CRS_NLS:
        row[fieldsTitles[field]] = convertCRsNLs(orgUnit.get(field, u''))
      else:
        row[fieldsTitles[field]] = orgUnit.get(field, u'')
    csvRows.append(row)
  writeCSVfile(csvRows, titles, u'Orgs', todrive)

# gam show orgtree [from_parent <OrgUnitItem>]
def doShowOrgTree():
  def addOrgUnitToTree(orgPathList, i, n, tree):
    if orgPathList[i] not in tree:
      tree[orgPathList[i]] = {}
    if i < n:
      addOrgUnitToTree(orgPathList, i+1, n, tree[orgPathList[i]])

  def printOrgUnit(parentOrgUnit, tree):
    printKeyValueList([parentOrgUnit])
    Indent.Increment()
    for childOrgUnit in sorted(tree[parentOrgUnit]):
      printOrgUnit(childOrgUnit, tree[parentOrgUnit])
    Indent.Decrement()

  cd = buildGAPIObject(DIRECTORY_API)
  listType = u'all'
  orgUnitPath = u'/'
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'fromparent':
      orgUnitPath = getOrgUnitItem()
    else:
      unknownArgumentExit()
  printGettingAccountEntitiesInfo(Entity.ORGANIZATIONAL_UNIT)
  try:
    orgs = callGAPI(cd.orgunits(), u'list',
                    throw_reasons=[GAPI_ORGUNIT_NOT_FOUND, GAPI_BAD_REQUEST, GAPI_INVALID_CUSTOMER_ID, GAPI_LOGIN_REQUIRED],
                    customerId=GC_Values[GC_CUSTOMER_ID], type=listType, orgUnitPath=orgUnitPath, fields=u'organizationUnits(orgUnitPath)')
  except GAPI_orgunitNotFound:
    entityActionFailedWarning([Entity.ORGANIZATIONAL_UNIT, orgUnitPath], PHRASE_DOES_NOT_EXIST)
    return
  except (GAPI_badRequest, GAPI_invalidCustomerId, GAPI_loginRequired):
    accessErrorExit(cd)
  if (not orgs) or (u'organizationUnits' not in orgs):
    printGettingAccountEntitiesDoneInfo(0)
    return
  printGettingAccountEntitiesDoneInfo(len(orgs[u'organizationUnits']))
  orgUnits = {}
  for orgUnit in orgs[u'organizationUnits']:
    orgPath = orgUnit['orgUnitPath'].split(u'/')
    addOrgUnitToTree(orgPath, 1, len(orgPath)-1, orgUnits)
  for org in sorted(orgUnits):
    printOrgUnit(org, orgUnits)

ALIAS_TARGET_TYPES = [u'user', u'group', u'target',]

def _doCreateUpdateAliases(doUpdate):
  cd = buildGAPIObject(DIRECTORY_API)
  aliasList = getEntityList(OB_EMAIL_ADDRESS_ENTITY)
  targetType = getChoice(ALIAS_TARGET_TYPES)
  targetEmails = getEntityList(OB_GROUP_ENTITY)
  entityLists = targetEmails if isinstance(targetEmails, dict) else None
  checkForExtraneousArguments()
  i = 0
  count = len(aliasList)
  for aliasEmail in aliasList:
    i += 1
    if entityLists:
      targetEmails = entityLists[aliasEmail]
    aliasEmail = normalizeEmailAddressOrUID(aliasEmail, noUid=True)
    body = {u'alias': aliasEmail}
    jcount = len(targetEmails)
    if jcount > 0:
# Only process first target
      targetEmail = normalizeEmailAddressOrUID(targetEmails[0])
      if doUpdate:
        try:
          callGAPI(cd.users().aliases(), u'delete',
                   throw_reasons=[GAPI_USER_NOT_FOUND, GAPI_BAD_REQUEST, GAPI_INVALID, GAPI_FORBIDDEN],
                   userKey=aliasEmail, alias=aliasEmail)
          printEntityKVList([Entity.USER_ALIAS, aliasEmail], [Action.PerformedName(Action.DELETE)], i, count)
        except (GAPI_userNotFound, GAPI_badRequest, GAPI_invalid, GAPI_forbidden):
          try:
            callGAPI(cd.groups().aliases(), u'delete',
                     throw_reasons=[GAPI_GROUP_NOT_FOUND, GAPI_BAD_REQUEST, GAPI_INVALID, GAPI_FORBIDDEN],
                     groupKey=aliasEmail, alias=aliasEmail)
          except GAPI_forbidden:
            entityUnknownWarning(Entity.GROUP_ALIAS, aliasEmail, i, count)
            continue
          except (GAPI_groupNotFound, GAPI_badRequest, GAPI_invalid):
            entityUnknownWarning(Entity.ALIAS, aliasEmail, i, count)
      if targetType != u'group':
        try:
          callGAPI(cd.users().aliases(), u'insert',
                   throw_reasons=[GAPI_USER_NOT_FOUND, GAPI_BAD_REQUEST, GAPI_INVALID, GAPI_INVALID_INPUT, GAPI_FORBIDDEN, GAPI_DUPLICATE],
                   userKey=targetEmail, body=body, fields=u'')
          entityActionPerformed([Entity.USER_ALIAS, aliasEmail, Entity.USER, targetEmail], i, count)
          continue
        except GAPI_duplicate:
          entityActionFailedWarning([Entity.USER_ALIAS, aliasEmail, Entity.USER, targetEmail], PHRASE_DUPLICATE, i, count)
          continue
        except (GAPI_invalid, GAPI_invalidInput):
          entityActionFailedWarning([Entity.USER_ALIAS, aliasEmail, Entity.USER, targetEmail], PHRASE_INVALID_ALIAS, i, count)
          continue
        except (GAPI_userNotFound, GAPI_badRequest, GAPI_forbidden):
          if targetType == u'user':
            entityUnknownWarning(Entity.ALIAS_TARGET, targetEmail, i, count)
            continue
      try:
        callGAPI(cd.groups().aliases(), u'insert',
                 throw_reasons=[GAPI_GROUP_NOT_FOUND, GAPI_USER_NOT_FOUND, GAPI_BAD_REQUEST, GAPI_INVALID, GAPI_INVALID_INPUT, GAPI_FORBIDDEN, GAPI_DUPLICATE],
                 groupKey=targetEmail, body=body, fields=u'')
        entityActionPerformed([Entity.GROUP_ALIAS, aliasEmail, Entity.GROUP, targetEmail], i, count)
      except GAPI_duplicate:
        entityActionFailedWarning([Entity.GROUP_ALIAS, aliasEmail, Entity.GROUP, targetEmail], PHRASE_DUPLICATE, i, count)
      except (GAPI_invalid, GAPI_invalidInput):
        entityActionFailedWarning([Entity.GROUP_ALIAS, aliasEmail, Entity.GROUP, targetEmail], PHRASE_INVALID_ALIAS, i, count)
      except (GAPI_groupNotFound, GAPI_userNotFound, GAPI_badRequest, GAPI_forbidden):
        entityUnknownWarning(Entity.ALIAS_TARGET, targetEmail, i, count)

# gam create aliases|nicknames <EmailAddressEntity> user|group|target <UniqueID>|<EmailAddress>
def doCreateAliases():
  _doCreateUpdateAliases(False)

# gam update aliases|nicknames <EmailAddressEntity> user|group|target <UniqueID>|<EmailAddress>
def doUpdateAliases():
  _doCreateUpdateAliases(True)

# gam delete aliases|nicknames [user|group|target] <EmailAddressEntity>
def doDeleteAliases():
  cd = buildGAPIObject(DIRECTORY_API)
  targetType = getChoice(ALIAS_TARGET_TYPES, defaultChoice=u'target')
  entityList = getEntityList(OB_EMAIL_ADDRESS_ENTITY)
  checkForExtraneousArguments()
  i = 0
  count = len(entityList)
  for aliasEmail in entityList:
    i += 1
    aliasEmail = normalizeEmailAddressOrUID(aliasEmail, noUid=True)
    if targetType != u'group':
      try:
        callGAPI(cd.users().aliases(), u'delete',
                 throw_reasons=[GAPI_USER_NOT_FOUND, GAPI_BAD_REQUEST, GAPI_INVALID, GAPI_FORBIDDEN],
                 userKey=aliasEmail, alias=aliasEmail)
        entityActionPerformed([Entity.USER_ALIAS, aliasEmail], i, count)
        continue
      except (GAPI_userNotFound, GAPI_badRequest, GAPI_invalid, GAPI_forbidden):
        if targetType == u'user':
          entityUnknownWarning(Entity.USER_ALIAS, aliasEmail, i, count)
          continue
    try:
      callGAPI(cd.groups().aliases(), u'delete',
               throw_reasons=[GAPI_GROUP_NOT_FOUND, GAPI_USER_NOT_FOUND, GAPI_BAD_REQUEST, GAPI_INVALID, GAPI_FORBIDDEN],
               groupKey=aliasEmail, alias=aliasEmail)
      entityActionPerformed([Entity.GROUP_ALIAS, aliasEmail], i, count)
      continue
    except (GAPI_groupNotFound, GAPI_userNotFound, GAPI_badRequest, GAPI_invalid, GAPI_forbidden):
      if targetType == u'group':
        entityUnknownWarning(Entity.GROUP_ALIAS, aliasEmail, i, count)
        continue
    entityUnknownWarning(Entity.ALIAS, aliasEmail, i, count)

def infoAliases(entityList):

  def _showAliasInfo(uid, email, aliasEmail, entityType, aliasEntityType, i, count):
    if email.lower() != aliasEmail:
      printEntity([aliasEntityType, aliasEmail], i, count)
      Indent.Increment()
      printEntity([entityType, email])
      printEntity([Entity.UNIQUE_ID, uid])
      Indent.Decrement()
    else:
      setSysExitRC(ENTITY_IS_NOT_AN_ALIAS_RC)
      printEntityKVList([Entity.EMAIL, aliasEmail],
                        [u'Is a {0}, not a {1}'.format(Entity.Singular(entityType),
                                                       Entity.Singular(aliasEntityType))],
                        i, count)

  cd = buildGAPIObject(DIRECTORY_API)
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
# Ignore info group/user arguments that may have come from whatis
    if (myarg in INFO_GROUP_OPTIONS) or (myarg in INFO_USER_OPTIONS):
      if myarg == u'schemas':
        getString(OB_SCHEMA_NAME_LIST)
    else:
      unknownArgumentExit()
  i = 0
  count = len(entityList)
  for aliasEmail in entityList:
    i += 1
    aliasEmail = normalizeEmailAddressOrUID(aliasEmail, noUid=True)
    try:
      result = callGAPI(cd.users(), u'get',
                        throw_reasons=GAPI_USER_GET_THROW_REASONS,
                        userKey=aliasEmail, fields=u'id,primaryEmail')
      _showAliasInfo(result[u'id'], result[u'primaryEmail'], aliasEmail, Entity.USER_EMAIL, Entity.USER_ALIAS, i, count)
      continue
    except (GAPI_userNotFound, GAPI_badRequest):
      pass
    except (GAPI_domainNotFound, GAPI_forbidden, GAPI_backendError, GAPI_systemError):
      entityUnknownWarning(Entity.USER_ALIAS, aliasEmail, i, count)
      continue
    try:
      result = callGAPI(cd.groups(), u'get',
                        throw_reasons=GAPI_GROUP_GET_THROW_REASONS,
                        groupKey=aliasEmail, fields=u'id,email')
      _showAliasInfo(result[u'id'], result[u'email'], aliasEmail, Entity.GROUP_EMAIL, Entity.GROUP_ALIAS, i, count)
      continue
    except GAPI_groupNotFound:
      pass
    except (GAPI_domainNotFound, GAPI_forbidden, GAPI_badRequest):
      entityUnknownWarning(Entity.GROUP_ALIAS, aliasEmail, i, count)
      continue
    entityUnknownWarning(Entity.EMAIL, aliasEmail, i, count)

# gam info aliases|nicknames <EmailAddressEntity>
def doInfoAliases():
  infoAliases(getEntityList(OB_EMAIL_ADDRESS_ENTITY))

# gam print aliases|nicknames [todrive [<ToDriveAttributes>]] [shownoneditable]
def doPrintAliases():
  cd = buildGAPIObject(DIRECTORY_API)
  todrive = {}
  titlesList = [u'Alias', u'Target', u'TargetType']
  userFields = [u'primaryEmail', u'aliases']
  groupFields = [u'email', u'aliases']
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'shownoneditable':
      titlesList.insert(1, u'NonEditableAlias')
      userFields.append(u'nonEditableAliases')
      groupFields.append(u'nonEditableAliases')
    else:
      unknownArgumentExit()
  titles, csvRows = initializeTitlesCSVfile(titlesList)
  printGettingAccountEntitiesInfo(Entity.USER_ALIAS)
  page_message = getPageMessage(showTotal=False, showFirstLastItems=True)
  try:
    entityList = callGAPIpages(cd.users(), u'list', u'users',
                               page_message=page_message, message_attribute=u'primaryEmail',
                               throw_reasons=[GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN, GAPI_BAD_REQUEST],
                               customer=GC_Values[GC_CUSTOMER_ID], fields=u'nextPageToken,users({0})'.format(u','.join(userFields)), maxResults=GC_Values[GC_USER_MAX_RESULTS])
    for user in entityList:
      for alias in user.get(u'aliases', []):
        csvRows.append({u'Alias': alias, u'Target': user[u'primaryEmail'], u'TargetType': u'User'})
      for alias in user.get(u'nonEditableAliases', []):
        csvRows.append({u'NonEditableAlias': alias, u'Target': user[u'primaryEmail'], u'TargetType': u'User'})
  except (GAPI_resourceNotFound, GAPI_forbidden, GAPI_badRequest):
    accessErrorExit(cd)
  printGettingAccountEntitiesInfo(Entity.GROUP_ALIAS)
  page_message = getPageMessage(showTotal=False, showFirstLastItems=True)
  try:
    entityList = callGAPIpages(cd.groups(), u'list', u'groups',
                               page_message=page_message, message_attribute=u'email',
                               throw_reasons=[GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN, GAPI_BAD_REQUEST],
                               customer=GC_Values[GC_CUSTOMER_ID], fields=u'nextPageToken,groups({0})'.format(u','.join(groupFields)))
    for group in entityList:
      for alias in group.get(u'aliases', []):
        csvRows.append({u'Alias': alias, u'Target': group[u'email'], u'TargetType': u'Group'})
      for alias in group.get(u'nonEditableAliases', []):
        csvRows.append({u'NonEditableAlias': alias, u'Target': group[u'email'], u'TargetType': u'Group'})
  except (GAPI_resourceNotFound, GAPI_forbidden, GAPI_badRequest):
    accessErrorExit(cd)
  writeCSVfile(csvRows, titles, u'Aliases', todrive)

# gam audit uploadkey <ValueReadFromStdin>
def doUploadAuditKey():
  auditObject = getAuditObject()
  checkForExtraneousArguments()
  auditkey = sys.stdin.read()
  callGData(auditObject, u'updatePGPKey',
            pgpkey=auditkey)

# Audit activity/export command utilities
def checkDownloadResults(results):
  if results[u'status'] != u'COMPLETED':
    printWarningMessage(REQUEST_NOT_COMPLETED_RC, MESSAGE_REQUEST_NOT_COMPLETE.format(results[u'status']))
    return False
  if int(results.get(u'numberOfFiles', u'0') >= 1):
    return True
  printWarningMessage(REQUEST_COMPLETED_NO_RESULTS_RC, MESSAGE_REQUEST_COMPLETED_NO_FILES)
  return False

# Audit command utilities
def getAuditParameters(emailAddressRequired=True, requestIdRequired=True, destUserRequired=False):
  auditObject = getAuditObject()
  emailAddress = getEmailAddress(noUid=True, optional=not emailAddressRequired)
  parameters = {}
  if emailAddress:
    parameters[u'auditUser'] = emailAddress
    parameters[u'auditUserName'], auditObject.domain = splitEmailAddress(emailAddress)
    if requestIdRequired:
      parameters[u'requestId'] = getString(OB_REQUEST_ID)
    if destUserRequired:
      destEmailAddress = getEmailAddress(noUid=True)
      parameters[u'auditDestUser'] = destEmailAddress
      parameters[u'auditDestUserName'], destDomain = splitEmailAddress(destEmailAddress)
      if auditObject.domain != destDomain:
        CLArgs.Backup()
        invalidArgumentExit(u'{0}@{1}'.format(parameters[u'auditDestUserName'], auditObject.domain))
  return (auditObject, parameters)

def _showFileURLs(request):
  if u'numberOfFiles' in request:
    printKeyValueList([u'Number Of Files', request[u'numberOfFiles']])
    Indent.Increment()
    for i in range(int(request[u'numberOfFiles'])):
      printKeyValueList([u'Url{0}'.format(i), request[u'fileUrl'+str(i)]])
    Indent.Decrement()

def _showMailboxActivityRequestStatus(request, i, count, showFiles=False):
  printEntity([Entity.REQUEST_ID, request[u'requestId']], i, count)
  Indent.Increment()
  printEntity([Entity.USER, request[u'userEmailAddress']])
  printKeyValueList([u'Status', request[u'status']])
  printKeyValueList([u'Request Date', request[u'requestDate']])
  printKeyValueList([u'Requested By', request[u'adminEmailAddress']])
  if showFiles:
    _showFileURLs(request)
  Indent.Decrement()

# gam audit activity request <EmailAddress>
def doSubmitActivityRequest():
  auditObject, parameters = getAuditParameters(emailAddressRequired=True, requestIdRequired=False, destUserRequired=False)
  checkForExtraneousArguments()
  try:
    request = callGData(auditObject, u'createAccountInformationRequest',
                        throw_errors=[GDATA_INVALID_DOMAIN, GDATA_DOES_NOT_EXIST],
                        user=parameters[u'auditUserName'])
    entityActionPerformed([Entity.USER, parameters[u'auditUser'], Entity.AUDIT_ACTIVITY_REQUEST, None])
    Indent.Increment()
    _showMailboxActivityRequestStatus(request, 0, 0, showFiles=False)
    Indent.Decrement()
  except (GData_invalidDomain, GData_doesNotExist):
    entityUnknownWarning(Entity.USER, parameters[u'auditUser'])

# gam audit activity delete <EmailAddress> <RequestID>
def doDeleteActivityRequest():
  auditObject, parameters = getAuditParameters(emailAddressRequired=True, requestIdRequired=True, destUserRequired=False)
  checkForExtraneousArguments()
  try:
    callGData(auditObject, u'deleteAccountInformationRequest',
              throw_errors=[GDATA_INVALID_DOMAIN, GDATA_DOES_NOT_EXIST, GDATA_INVALID_VALUE],
              user=parameters[u'auditUserName'], request_id=parameters[u'requestId'])
    entityActionPerformed([Entity.USER, parameters[u'auditUser'], Entity.AUDIT_ACTIVITY_REQUEST, parameters[u'requestId']])
  except (GData_invalidDomain, GData_doesNotExist):
    entityUnknownWarning(Entity.USER, parameters[u'auditUser'])
  except GData_invalidValue:
    entityActionFailedWarning([Entity.USER, parameters[u'auditUser'], Entity.AUDIT_ACTIVITY_REQUEST, parameters[u'requestId']], PHRASE_INVALID_REQUEST)

# gam audit activity download <EmailAddress> <RequestID>
def doDownloadActivityRequest():
  auditObject, parameters = getAuditParameters(emailAddressRequired=True, requestIdRequired=True, destUserRequired=False)
  checkForExtraneousArguments()
  try:
    results = callGData(auditObject, u'getAccountInformationRequestStatus',
                        throw_errors=[GDATA_INVALID_DOMAIN, GDATA_DOES_NOT_EXIST, GDATA_INVALID_VALUE],
                        user=parameters[u'auditUserName'], request_id=parameters[u'requestId'])
    if not checkDownloadResults(results):
      return
    count = int(results[u'numberOfFiles'])
    for i in range(count):
      filename = u'activity-{0}-{1}-{2}.txt.gpg'.format(parameters[u'auditUserName'], parameters[u'requestId'], i)
      entityPerformActionInfo([Entity.USER, parameters[u'auditUser'], Entity.AUDIT_ACTIVITY_REQUEST, parameters[u'requestId']], filename, i+1, count)
      _, data = httplib2.Http(disable_ssl_certificate_validation=GC_Values[GC_NO_VERIFY_SSL]).request(results[u'fileUrl'+str(i)], u'GET')
      writeFile(filename, data)
  except (GData_invalidDomain, GData_doesNotExist):
    entityUnknownWarning(Entity.USER, parameters[u'auditUser'])
  except GData_invalidValue:
    entityActionFailedWarning([Entity.USER, parameters[u'auditUser'], Entity.AUDIT_ACTIVITY_REQUEST, parameters[u'requestId']], PHRASE_INVALID_REQUEST)

# gam audit activity status [<EmailAddress> <RequestID>]
def doStatusActivityRequests():
  auditObject, parameters = getAuditParameters(emailAddressRequired=False, requestIdRequired=True, destUserRequired=False)
  checkForExtraneousArguments()
  if parameters:
    try:
      results = [callGData(auditObject, u'getAccountInformationRequestStatus',
                           throw_errors=[GDATA_INVALID_DOMAIN, GDATA_DOES_NOT_EXIST, GDATA_INVALID_VALUE],
                           user=parameters[u'auditUserName'], request_id=parameters[u'requestId'])]
      jcount = 1 if (results) else 0
      entityPerformActionNumItems([Entity.USER, parameters[u'auditUser']], jcount, Entity.AUDIT_ACTIVITY_REQUEST)
    except (GData_invalidDomain, GData_doesNotExist):
      entityUnknownWarning(Entity.USER, parameters[u'auditUser'])
      return
    except GData_invalidValue:
      entityActionFailedWarning([Entity.USER, parameters[u'auditUser'], Entity.AUDIT_ACTIVITY_REQUEST, parameters[u'requestId']], PHRASE_INVALID_REQUEST)
      return
  else:
    results = callGData(auditObject, u'getAllAccountInformationRequestsStatus')
    jcount = len(results) if (results) else 0
    entityPerformActionNumItems([Entity.DOMAIN, GC_Values[GC_DOMAIN]], jcount, Entity.AUDIT_ACTIVITY_REQUEST)
  if jcount == 0:
    setSysExitRC(NO_ENTITIES_FOUND)
    return
  Indent.Increment()
  j = 0
  for request in results:
    j += 1
    _showMailboxActivityRequestStatus(request, j, jcount, showFiles=True)
  Indent.Decrement()

# Audit export command utilities
def _showMailboxExportRequestStatus(request, i, count, showFilter=False, showDates=False, showFiles=False):
  printEntity([Entity.REQUEST_ID, request[u'requestId']], i, count)
  Indent.Increment()
  printEntity([Entity.USER, request[u'userEmailAddress']])
  printKeyValueList([u'Status', request[u'status']])
  printKeyValueList([u'Request Date', request[u'requestDate']])
  printKeyValueList([u'Requested By', request[u'adminEmailAddress']])
  printKeyValueList([u'Requested Parts', request[u'packageContent']])
  if showFilter:
    printKeyValueList([u'Request Filter', request.get(u'searchQuery', u'None')])
  printKeyValueList([u'Include Deleted', request[u'includeDeleted']])
  if showDates:
    printKeyValueList([u'Begin', request.get(u'beginDate', u'Account creation date')])
    printKeyValueList([u'End', request.get(u'endDate', u'Export request date')])
  if showFiles:
    _showFileURLs(request)
  Indent.Decrement()

# gam audit export request <EmailAddress> [begin <DateTime>] [end <DateTime>] [search <QueryGmail>] [headersonly] [includedeleted]
def doSubmitExportRequest():
  auditObject, parameters = getAuditParameters(emailAddressRequired=True, requestIdRequired=False, destUserRequired=False)
  begin_date = end_date = search_query = None
  headers_only = include_deleted = False
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'begin':
      begin_date = getYYYYMMDD_HHMM()
    elif myarg == u'end':
      end_date = getYYYYMMDD_HHMM()
    elif myarg == u'search':
      search_query = getString(OB_QUERY)
    elif myarg == u'headersonly':
      headers_only = True
    elif myarg == u'includedeleted':
      include_deleted = True
    else:
      unknownArgumentExit()
  try:
    request = callGData(auditObject, u'createMailboxExportRequest',
                        throw_errors=[GDATA_INVALID_DOMAIN, GDATA_DOES_NOT_EXIST],
                        user=parameters[u'auditUserName'], begin_date=begin_date, end_date=end_date, include_deleted=include_deleted,
                        search_query=search_query, headers_only=headers_only)
    entityActionPerformed([Entity.USER, parameters[u'auditUser'], Entity.AUDIT_EXPORT_REQUEST, None])
    Indent.Increment()
    _showMailboxExportRequestStatus(request, 0, 0, showFilter=False, showDates=True, showFiles=False)
    Indent.Decrement()
  except (GData_invalidDomain, GData_doesNotExist):
    entityUnknownWarning(Entity.USER, parameters[u'auditUser'])

# gam audit export delete <EmailAddress> <RequestID>
def doDeleteExportRequest():
  auditObject, parameters = getAuditParameters(emailAddressRequired=True, requestIdRequired=True, destUserRequired=False)
  checkForExtraneousArguments()
  try:
    callGData(auditObject, u'deleteMailboxExportRequest',
              throw_errors=[GDATA_INVALID_DOMAIN, GDATA_DOES_NOT_EXIST, GDATA_INVALID_VALUE],
              user=parameters[u'auditUserName'], request_id=parameters[u'requestId'])
    entityActionPerformed([Entity.USER, parameters[u'auditUser'], Entity.AUDIT_EXPORT_REQUEST, parameters[u'requestId']])
  except (GData_invalidDomain, GData_doesNotExist):
    entityUnknownWarning(Entity.USER, parameters[u'auditUser'])
  except GData_invalidValue:
    entityActionFailedWarning([Entity.USER, parameters[u'auditUser'], Entity.AUDIT_EXPORT_REQUEST, parameters[u'requestId']], PHRASE_INVALID_REQUEST)

# gam audit export download <EmailAddress> <RequestID>
def doDownloadExportRequest():
  auditObject, parameters = getAuditParameters(emailAddressRequired=True, requestIdRequired=True, destUserRequired=False)
  checkForExtraneousArguments()
  try:
    results = callGData(auditObject, u'getMailboxExportRequestStatus',
                        throw_errors=[GDATA_INVALID_DOMAIN, GDATA_DOES_NOT_EXIST, GDATA_INVALID_VALUE],
                        user=parameters[u'auditUserName'], request_id=parameters[u'requestId'])
    if not checkDownloadResults(results):
      return
    count = int(results[u'numberOfFiles'])
    for i in range(count):
      filename = u'export-{0}-{1}-{2}.mbox.gpg'.format(parameters[u'auditUserName'], parameters[u'requestId'], i)
      #don't download existing files. This does not check validity of existing local
      #file so partial/corrupt downloads will need to be deleted manually.
      if not os.path.isfile(filename):
        entityPerformActionInfo([Entity.USER, parameters[u'auditUser'], Entity.AUDIT_EXPORT_REQUEST, parameters[u'requestId']], filename, i+1, count)
        _, data = httplib2.Http(disable_ssl_certificate_validation=GC_Values[GC_NO_VERIFY_SSL]).request(results[u'fileUrl'+str(i)], u'GET')
        writeFile(filename, data)
  except (GData_invalidDomain, GData_doesNotExist):
    entityUnknownWarning(Entity.USER, parameters[u'auditUser'])
  except GData_invalidValue:
    entityActionFailedWarning([Entity.USER, parameters[u'auditUser'], Entity.AUDIT_EXPORT_REQUEST, parameters[u'requestId']], PHRASE_INVALID_REQUEST)

# gam audit export status [<EmailAddress> <RequestID>]
def doStatusExportRequests():
  auditObject, parameters = getAuditParameters(emailAddressRequired=False, requestIdRequired=True, destUserRequired=False)
  checkForExtraneousArguments()
  if parameters:
    try:
      results = [callGData(auditObject, u'getMailboxExportRequestStatus',
                           throw_errors=[GDATA_INVALID_DOMAIN, GDATA_DOES_NOT_EXIST, GDATA_INVALID_VALUE],
                           user=parameters[u'auditUserName'], request_id=parameters[u'requestId'])]
      jcount = 1 if (results) else 0
      entityPerformActionNumItems([Entity.USER, parameters[u'auditUser']], jcount, Entity.AUDIT_EXPORT_REQUEST)
    except (GData_invalidDomain, GData_doesNotExist):
      entityUnknownWarning(Entity.USER, parameters[u'auditUser'])
      return
    except GData_invalidValue:
      entityActionFailedWarning([Entity.USER, parameters[u'auditUser'], Entity.AUDIT_EXPORT_REQUEST, parameters[u'requestId']], PHRASE_INVALID_REQUEST)
      return
  else:
    results = callGData(auditObject, u'getAllMailboxExportRequestsStatus')
    jcount = len(results) if (results) else 0
    entityPerformActionNumItems([Entity.DOMAIN, GC_Values[GC_DOMAIN]], jcount, Entity.AUDIT_EXPORT_REQUEST)
  if jcount == 0:
    setSysExitRC(NO_ENTITIES_FOUND)
    return
  Indent.Increment()
  j = 0
  for request in results:
    j += 1
    _showMailboxExportRequestStatus(request, j, jcount, showFilter=True, showDates=False, showFiles=True)
  Indent.Decrement()

# gam audit export watch <EmailAddress> <RequestID>
def doWatchExportRequest():
  auditObject, parameters = getAuditParameters(emailAddressRequired=True, requestIdRequired=True, destUserRequired=False)
  checkForExtraneousArguments()
  while True:
    try:
      results = callGData(auditObject, u'getMailboxExportRequestStatus',
                          throw_errors=[GDATA_INVALID_DOMAIN, GDATA_DOES_NOT_EXIST, GDATA_INVALID_VALUE],
                          user=parameters[u'auditUserName'], request_id=parameters[u'requestId'])
    except (GData_invalidDomain, GData_doesNotExist):
      entityUnknownWarning(Entity.USER, parameters[u'auditUser'])
      break
    except GData_invalidValue:
      entityActionFailedWarning([Entity.USER, parameters[u'auditUser'], Entity.AUDIT_EXPORT_REQUEST, parameters[u'requestId']], PHRASE_INVALID_REQUEST)
      break
    if results[u'status'] != u'PENDING':
      printKeyValueList([u'Status is', results[u'status'], u'Sending email.'])
      msg_txt = u'\n'
      msg_txt += u'  {0}: {1}\n'.format(Entity.Singular(Entity.REQUEST_ID), results[u'requestId'])
      msg_txt += u'  {0}: {1}\n'.format(Entity.Singular(Entity.USER), results[u'userEmailAddress'])
      msg_txt += u'  Status: {0}\n'.format(results[u'status'])
      msg_txt += u'  Request Date: {0}\n'.format(results[u'requestDate'])
      msg_txt += u'  Requested By: {0}\n'.format(results[u'adminEmailAddress'])
      msg_txt += u'  Requested Parts: {0}\n'.format(results[u'packageContent'])
      msg_txt += u'  Request Filter: {0}\n'.format(results.get(u'searchQuery', u'None'))
      msg_txt += u'  Include Deleted: {0}\n'.format(results[u'includeDeleted'])
      if u'numberOfFiles' in results:
        msg_txt += u'  Number Of Files: {0}\n'.format(results[u'numberOfFiles'])
        for i in range(int(results[u'numberOfFiles'])):
          msg_txt += u'  Url{0}: {1}\n'.format(i, results[u'fileUrl'+str(i)])
      msg_subj = u'Export #{0} for {1} status is {2}'.format(results[u'requestId'], results[u'userEmailAddress'], results[u'status'])
      send_email(msg_subj, msg_txt)
      break
    else:
      printKeyValueList([u'Status still PENDING, will check again in 5 minutes...'])
      time.sleep(300)

# Audit monitor command utilities
def _showMailboxMonitorRequestStatus(request, i=0, count=0):
  printKeyValueListWithCount([u'Destination', normalizeEmailAddressOrUID(request[u'destUserName'])], i, count)
  Indent.Increment()
  printKeyValueList([u'Begin', request.get(u'beginDate', u'immediately')])
  printKeyValueList([u'End', request[u'endDate']])
  printKeyValueList([u'Monitor Incoming', request[u'outgoingEmailMonitorLevel']])
  printKeyValueList([u'Monitor Outgoing', request[u'incomingEmailMonitorLevel']])
  printKeyValueList([u'Monitor Chats', request[u'chatMonitorLevel']])
  printKeyValueList([u'Monitor Drafts', request[u'draftMonitorLevel']])
  Indent.Decrement()

# gam audit monitor create <EmailAddress> <DestEmailAddress> [begin <DateTime>] [end <DateTime>] [incoming_headers] [outgoing_headers] [nochats] [nodrafts] [chat_headers] [draft_headers]
def doCreateMonitor():
  auditObject, parameters = getAuditParameters(emailAddressRequired=True, requestIdRequired=False, destUserRequired=True)
  #end_date defaults to 30 days in the future...
  end_date = (datetime.datetime.now()+datetime.timedelta(days=30)).strftime(u'%Y-%m-%d %H:%M')
  begin_date = None
  incoming_headers_only = outgoing_headers_only = drafts_headers_only = chats_headers_only = False
  drafts = chats = True
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'begin':
      begin_date = getYYYYMMDD_HHMM()
    elif myarg == u'end':
      end_date = getYYYYMMDD_HHMM()
    elif myarg == u'incomingheaders':
      incoming_headers_only = True
    elif myarg == u'outgoingheaders':
      outgoing_headers_only = True
    elif myarg == u'nochats':
      chats = False
    elif myarg == u'nodrafts':
      drafts = False
    elif myarg == u'chatheaders':
      chats_headers_only = True
    elif myarg == u'draftheaders':
      drafts_headers_only = True
    else:
      unknownArgumentExit()
  try:
    request = callGData(auditObject, u'createEmailMonitor',
                        throw_errors=[GDATA_INVALID_VALUE, GDATA_INVALID_DOMAIN, GDATA_DOES_NOT_EXIST],
                        source_user=parameters[u'auditUserName'], destination_user=parameters[u'auditDestUserName'], end_date=end_date, begin_date=begin_date,
                        incoming_headers_only=incoming_headers_only, outgoing_headers_only=outgoing_headers_only,
                        drafts=drafts, drafts_headers_only=drafts_headers_only, chats=chats, chats_headers_only=chats_headers_only)
    entityActionPerformed([Entity.USER, parameters[u'auditUser'], Entity.AUDIT_MONITOR_REQUEST, None])
    Indent.Increment()
    _showMailboxMonitorRequestStatus(request)
    Indent.Decrement()
  except GData_invalidValue as e:
    entityActionFailedWarning([Entity.USER, parameters[u'auditUser'], Entity.AUDIT_MONITOR_REQUEST, None], e.message)
  except (GData_invalidDomain, GData_doesNotExist):
    entityUnknownWarning(Entity.USER, parameters[u'auditUser'])

# gam audit monitor delete <EmailAddress> <DestEmailAddress>
def doDeleteMonitor():
  auditObject, parameters = getAuditParameters(emailAddressRequired=True, requestIdRequired=False, destUserRequired=True)
  checkForExtraneousArguments()
  try:
    callGData(auditObject, u'deleteEmailMonitor',
              throw_errors=[GDATA_INVALID_DOMAIN, GDATA_DOES_NOT_EXIST],
              source_user=parameters[u'auditUserName'], destination_user=parameters[u'auditDestUserName'])
    entityActionPerformed([Entity.USER, parameters[u'auditUser'], Entity.AUDIT_MONITOR_REQUEST, parameters[u'auditDestUser']])
  except (GData_invalidDomain, GData_doesNotExist):
    entityUnknownWarning(Entity.USER, parameters[u'auditUser'])

# gam audit monitor list <EmailAddress>
def doShowMonitors():
  auditObject, parameters = getAuditParameters(emailAddressRequired=True, requestIdRequired=False, destUserRequired=False)
  checkForExtraneousArguments()
  try:
    results = callGData(auditObject, u'getEmailMonitors',
                        throw_errors=[GDATA_INVALID_DOMAIN, GDATA_DOES_NOT_EXIST],
                        user=parameters[u'auditUserName'])
    jcount = len(results) if (results) else 0
    entityPerformActionNumItems([Entity.USER, parameters[u'auditUser']], jcount, Entity.AUDIT_MONITOR_REQUEST)
    if jcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
      return
    Indent.Increment()
    j = 0
    for request in results:
      j += 1
      _showMailboxMonitorRequestStatus(request, j, jcount)
    Indent.Decrement()
  except (GData_invalidDomain, GData_doesNotExist):
    entityUnknownWarning(Entity.USER, parameters[u'auditUser'])

# Contact commands utilities
#
CONTACT_ID = u'ContactID'
CONTACT_UPDATED = u'Updated'
CONTACT_NAME_PREFIX = u'Name Prefix'
CONTACT_GIVEN_NAME = u'Given Name'
CONTACT_ADDITIONAL_NAME = u'Additional Name'
CONTACT_FAMILY_NAME = u'Family Name'
CONTACT_NAME_SUFFIX = u'Name Suffix'
CONTACT_NAME = u'Name'
CONTACT_NICKNAME = u'Nickname'
CONTACT_MAIDENNAME = u'Maiden Name'
CONTACT_SHORTNAME = u'Short Name'
CONTACT_INITIALS = u'Initials'
CONTACT_BIRTHDAY = u'Birthday'
CONTACT_GENDER = u'Gender'
CONTACT_LOCATION = u'Location'
CONTACT_PRIORITY = u'Priority'
CONTACT_SENSITIVITY = u'Sensitivity'
CONTACT_SUBJECT = u'Subject'
CONTACT_LANGUAGE = u'Language'
CONTACT_NOTES = u'Notes'
CONTACT_OCCUPATION = u'Occupation'
CONTACT_BILLING_INFORMATION = u'Billing Information'
CONTACT_MILEAGE = u'Mileage'
CONTACT_DIRECTORY_SERVER = u'Directory Server'
CONTACT_ADDRESSES = u'Addresses'
CONTACT_CALENDARS = u'Calendars'
CONTACT_EMAILS = u'Emails'
CONTACT_EXTERNALIDS = u'External IDs'
CONTACT_EVENTS = u'Events'
CONTACT_HOBBIES = u'Hobbies'
CONTACT_IMS = u'IMs'
CONTACT_JOTS = u'Jots'
CONTACT_ORGANIZATIONS = u'Organizations'
CONTACT_PHONES = u'Phones'
CONTACT_RELATIONS = u'Relations'
CONTACT_USER_DEFINED_FIELDS = u'User Defined Fields'
CONTACT_WEBSITES = u'Websites'
CONTACT_GROUPS = u'ContactGroups'
CONTACT_GROUPS_LIST = u'ContactGroupsList'
#
CONTACT_GROUP_ID = u'ContactGroupID'
CONTACT_GROUP_UPDATED = u'Updated'
CONTACT_GROUP_NAME = u'ContactGroupName'
#
class ContactsManager(object):
  import gdata.apps.contacts

  CONTACT_ARGUMENT_TO_PROPERTY_MAP = {
    u'name': CONTACT_NAME,
    u'prefix': CONTACT_NAME_PREFIX,
    u'givenname': CONTACT_GIVEN_NAME,
    u'additionalname': CONTACT_ADDITIONAL_NAME,
    u'familyname': CONTACT_FAMILY_NAME,
    u'firstname': CONTACT_GIVEN_NAME,
    u'middlename': CONTACT_ADDITIONAL_NAME,
    u'lastname': CONTACT_FAMILY_NAME,
    u'suffix': CONTACT_NAME_SUFFIX,
    u'nickname': CONTACT_NICKNAME,
    u'maidenname': CONTACT_MAIDENNAME,
    u'shortname': CONTACT_SHORTNAME,
    u'initials': CONTACT_INITIALS,
    u'birthday': CONTACT_BIRTHDAY,
    u'gender': CONTACT_GENDER,
    u'location': CONTACT_LOCATION,
    u'priority': CONTACT_PRIORITY,
    u'sensitivity': CONTACT_SENSITIVITY,
    u'subject': CONTACT_SUBJECT,
    u'language': CONTACT_LANGUAGE,
    u'note': CONTACT_NOTES,
    u'notes': CONTACT_NOTES,
    u'occupation': CONTACT_OCCUPATION,
    u'billinginfo': CONTACT_BILLING_INFORMATION,
    u'mileage': CONTACT_MILEAGE,
    u'directoryserver': CONTACT_DIRECTORY_SERVER,
    u'address': CONTACT_ADDRESSES,
    u'addresses': CONTACT_ADDRESSES,
    u'calendar': CONTACT_CALENDARS,
    u'calendars': CONTACT_CALENDARS,
    u'email': CONTACT_EMAILS,
    u'emails': CONTACT_EMAILS,
    u'externalid': CONTACT_EXTERNALIDS,
    u'externalids': CONTACT_EXTERNALIDS,
    u'event': CONTACT_EVENTS,
    u'events': CONTACT_EVENTS,
    u'hobby': CONTACT_HOBBIES,
    u'hobbies': CONTACT_HOBBIES,
    u'im': CONTACT_IMS,
    u'ims': CONTACT_IMS,
    u'jot': CONTACT_JOTS,
    u'jots': CONTACT_JOTS,
    u'organization': CONTACT_ORGANIZATIONS,
    u'organizations': CONTACT_ORGANIZATIONS,
    u'phone': CONTACT_PHONES,
    u'phones': CONTACT_PHONES,
    u'relation': CONTACT_RELATIONS,
    u'relations': CONTACT_RELATIONS,
    u'userdefinedfield': CONTACT_USER_DEFINED_FIELDS,
    u'userdefinedfields': CONTACT_USER_DEFINED_FIELDS,
    u'website': CONTACT_WEBSITES,
    u'websites': CONTACT_WEBSITES,
    u'contactgroup': CONTACT_GROUPS,
    u'contactgroups': CONTACT_GROUPS,
    u'updated': CONTACT_UPDATED,
    }

  GENDER_CHOICE_MAP = {u'male': u'male', u'female': u'female',}

  PRIORITY_CHOICE_MAP = {u'low': u'low', u'normal': u'normal', u'high': u'high',}

  SENSITIVITY_CHOICE_MAP = {
    u'confidential': u'confidential',
    u'normal': u'normal',
    u'personal': u'personal',
    u'private': u'private',
    }

  PRIMARY_NOTPRIMARY_CHOICE_MAP = {u'primary': u'true', u'notprimary': u'false',}

  CONTACT_NAME_FIELDS = (
    CONTACT_NAME_PREFIX,
    CONTACT_GIVEN_NAME,
    CONTACT_ADDITIONAL_NAME,
    CONTACT_FAMILY_NAME,
    CONTACT_NAME_SUFFIX,
    )

  ADDRESS_TYPE_ARGUMENT_TO_REL = {
    u'work': gdata.apps.contacts.REL_WORK,
    u'home': gdata.apps.contacts.REL_HOME,
    u'other': gdata.apps.contacts.REL_OTHER,
    }

  ADDRESS_REL_TO_TYPE_ARGUMENT = {
    gdata.apps.contacts.REL_WORK: u'work',
    gdata.apps.contacts.REL_HOME: u'home',
    gdata.apps.contacts.REL_OTHER: u'other',
    }

  ADDRESS_ARGUMENT_TO_FIELD_MAP = {
    u'streetaddress': u'street',
    u'pobox': u'pobox',
    u'neighborhood': u'neighborhood',
    u'locality': u'city',
    u'region': u'region',
    u'postalcode': u'postcode',
    u'country': u'country',
    u'formatted': u'value', u'unstructured': u'value',
    }

  ADDRESS_FIELD_TO_ARGUMENT_MAP = {
    u'street': u'streetaddress',
    u'pobox': u'pobox',
    u'neighborhood': u'neighborhood',
    u'city': u'locality',
    u'region': u'region',
    u'postcode': u'postalcode',
    u'country': u'country',
    }

  ADDRESS_FIELD_PRINT_ORDER = [
    u'street',
    u'pobox',
    u'neighborhood',
    u'city',
    u'region',
    u'postcode',
    u'country',
    ]

  CALENDAR_TYPE_ARGUMENT_TO_REL = {
    u'work': u'work',
    u'home': u'home',
    u'free-busy': u'free-busy',
    }

  CALENDAR_REL_TO_TYPE_ARGUMENT = {
    u'work': u'work',
    u'home': u'home',
    u'free-busy': u'free-busy',
    }

  EMAIL_TYPE_ARGUMENT_TO_REL = {
    u'work': gdata.apps.contacts.REL_WORK,
    u'home': gdata.apps.contacts.REL_HOME,
    u'other': gdata.apps.contacts.REL_OTHER,
    }

  EMAIL_REL_TO_TYPE_ARGUMENT = {
    gdata.apps.contacts.REL_WORK: u'work',
    gdata.apps.contacts.REL_HOME: u'home',
    gdata.apps.contacts.REL_OTHER: u'other',
    }

  EVENT_TYPE_ARGUMENT_TO_REL = {
    u'anniversary': u'anniversary',
    u'other': u'other',
    }

  EVENT_REL_TO_TYPE_ARGUMENT = {
    u'anniversary': u'anniversary',
    u'other': u'other',
    }

  EXTERNALID_TYPE_ARGUMENT_TO_REL = {
    u'account': u'account',
    u'customer': u'customer',
    u'network': u'network',
    u'organization': u'organization',
    }

  EXTERNALID_REL_TO_TYPE_ARGUMENT = {
    u'account': u'account',
    u'customer': u'customer',
    u'network': u'network',
    u'organization': u'organization',
    }

  IM_TYPE_ARGUMENT_TO_REL = {
    u'work': gdata.apps.contacts.REL_WORK,
    u'home': gdata.apps.contacts.REL_HOME,
    u'other': gdata.apps.contacts.REL_OTHER,
    }

  IM_REL_TO_TYPE_ARGUMENT = {
    gdata.apps.contacts.REL_WORK: u'work',
    gdata.apps.contacts.REL_HOME: u'home',
    gdata.apps.contacts.REL_OTHER: u'other',
    }

  IM_PROTOCOL_TO_REL_MAP = {
    u'aim': gdata.apps.contacts.IM_AIM,
    u'gtalk': gdata.apps.contacts.IM_GOOGLE_TALK,
    u'icq': gdata.apps.contacts.IM_ICQ,
    u'jabber': gdata.apps.contacts.IM_JABBER,
    u'msn': gdata.apps.contacts.IM_MSN,
    u'netmeeting': gdata.apps.contacts.IM_NETMEETING,
    u'qq': gdata.apps.contacts.IM_QQ,
    u'skype': gdata.apps.contacts.IM_SKYPE,
    u'xmpp': gdata.apps.contacts.IM_JABBER,
    u'yahoo': gdata.apps.contacts.IM_YAHOO,
    }

  IM_REL_TO_PROTOCOL_MAP = {
    gdata.apps.contacts.IM_AIM: u'aim',
    gdata.apps.contacts.IM_GOOGLE_TALK: u'gtalk',
    gdata.apps.contacts.IM_ICQ: u'icq',
    gdata.apps.contacts.IM_JABBER: u'jabber',
    gdata.apps.contacts.IM_MSN: u'msn',
    gdata.apps.contacts.IM_NETMEETING: u'netmeeting',
    gdata.apps.contacts.IM_QQ: u'qq',
    gdata.apps.contacts.IM_SKYPE: u'skype',
    gdata.apps.contacts.IM_YAHOO: u'yahoo',
    }

  JOT_TYPE_ARGUMENT_TO_REL = {
    u'work': u'work',
    u'home': u'home',
    u'other': u'other',
    u'keywords': u'keywords',
    u'user': u'user',
    }

  JOT_REL_TO_TYPE_ARGUMENT = {
    u'work': u'work',
    u'home': u'home',
    u'other': u'other',
    u'keywords': u'keywords',
    u'user': u'user',
    }

  ORGANIZATION_TYPE_ARGUMENT_TO_REL = {
    u'work': gdata.apps.contacts.REL_WORK,
    u'other': gdata.apps.contacts.REL_OTHER,
    }

  ORGANIZATION_REL_TO_TYPE_ARGUMENT = {
    gdata.apps.contacts.REL_WORK: u'work',
    gdata.apps.contacts.REL_OTHER: u'other',
    }

  ORGANIZATION_ARGUMENT_TO_FIELD_MAP = {
    u'location': u'where',
    u'department': u'department',
    u'title': u'title',
    u'jobdescription': u'jobdescription',
    u'symbol': u'symbol',
    }

  ORGANIZATION_FIELD_TO_ARGUMENT_MAP = {
    u'where': u'location',
    u'department': u'department',
    u'title': u'title',
    u'jobdescription': u'jobdescription',
    u'symbol': u'symbol',
    }

  ORGANIZATION_FIELD_PRINT_ORDER = [
    u'where',
    u'department',
    u'title',
    u'jobdescription',
    u'symbol',
    ]

  PHONE_TYPE_ARGUMENT_TO_REL = {
    u'work': gdata.apps.contacts.PHONE_WORK,
    u'home': gdata.apps.contacts.PHONE_HOME,
    u'other': gdata.apps.contacts.PHONE_OTHER,
    u'fax': gdata.apps.contacts.PHONE_HOME_FAX,
    u'home_fax': gdata.apps.contacts.PHONE_HOME_FAX,
    u'work_fax': gdata.apps.contacts.PHONE_WORK_FAX,
    u'other_fax': gdata.apps.contacts.PHONE_OTHER_FAX,
    u'main': gdata.apps.contacts.PHONE_MAIN,
    u'company_main': gdata.apps.contacts.PHONE_COMPANY_MAIN,
    u'assistant': gdata.apps.contacts.PHONE_ASSISTANT,
    u'mobile': gdata.apps.contacts.PHONE_MOBILE,
    u'work_mobile': gdata.apps.contacts.PHONE_WORK_MOBILE,
    u'pager': gdata.apps.contacts.PHONE_PAGER,
    u'work_pager': gdata.apps.contacts.PHONE_WORK_PAGER,
    u'car': gdata.apps.contacts.PHONE_CAR,
    u'radio': gdata.apps.contacts.PHONE_RADIO,
    u'callback': gdata.apps.contacts.PHONE_CALLBACK,
    u'isdn': gdata.apps.contacts.PHONE_ISDN,
    u'telex': gdata.apps.contacts.PHONE_TELEX,
    u'tty_tdd': gdata.apps.contacts.PHONE_TTY_TDD,
    }

  PHONE_REL_TO_TYPE_ARGUMENT = {
    gdata.apps.contacts.PHONE_WORK: u'work',
    gdata.apps.contacts.PHONE_HOME: u'home',
    gdata.apps.contacts.PHONE_OTHER: u'other',
    gdata.apps.contacts.PHONE_HOME_FAX: u'fax',
    gdata.apps.contacts.PHONE_HOME_FAX: u'home_fax',
    gdata.apps.contacts.PHONE_WORK_FAX: u'work_fax',
    gdata.apps.contacts.PHONE_OTHER_FAX: u'other_fax',
    gdata.apps.contacts.PHONE_MAIN: u'main',
    gdata.apps.contacts.PHONE_COMPANY_MAIN: u'company_main',
    gdata.apps.contacts.PHONE_ASSISTANT: u'assistant',
    gdata.apps.contacts.PHONE_MOBILE: u'mobile',
    gdata.apps.contacts.PHONE_WORK_MOBILE: u'work_mobile',
    gdata.apps.contacts.PHONE_PAGER: u'pager',
    gdata.apps.contacts.PHONE_WORK_PAGER: u'work_pager',
    gdata.apps.contacts.PHONE_CAR: u'car',
    gdata.apps.contacts.PHONE_RADIO: u'radio',
    gdata.apps.contacts.PHONE_CALLBACK: u'callback',
    gdata.apps.contacts.PHONE_ISDN: u'isdn',
    gdata.apps.contacts.PHONE_TELEX: u'telex',
    gdata.apps.contacts.PHONE_TTY_TDD: u'tty_tdd',
    }

  RELATION_TYPE_ARGUMENT_TO_REL = {
    u'spouse': u'spouse',
    u'child': u'child',
    u'mother': u'mother',
    u'father': u'father',
    u'parent': u'parent',
    u'brother': u'brother',
    u'sister': u'sister',
    u'friend': u'friend',
    u'relative': u'relative',
    u'manager': u'manager',
    u'assistant': u'assistant',
    u'referredby': u'referred-by',
    u'partner': u'partner',
    u'domesticpartner': u'domestic-partner',
    }

  RELATION_REL_TO_TYPE_ARGUMENT = {
    u'spouse' : u'spouse',
    u'child' : u'child',
    u'mother' : u'mother',
    u'father' : u'father',
    u'parent' : u'parent',
    u'brother' : u'brother',
    u'sister' : u'sister',
    u'friend' : u'friend',
    u'relative' : u'relative',
    u'manager' : u'manager',
    u'assistant' : u'assistant',
    u'referred-by' : u'referred_by',
    u'partner' : u'partner',
    u'domestic-partner' : u'domestic_partner',
    }

  WEBSITE_TYPE_ARGUMENT_TO_REL = {
    u'home-page': u'home-page',
    u'blog': u'blog',
    u'profile': u'profile',
    u'work': u'work',
    u'home': u'home',
    u'other': u'other',
    u'ftp': u'ftp',
    u'reservations': u'reservations',
    u'app-install-page': u'app-install-page',
    }

  WEBSITE_REL_TO_TYPE_ARGUMENT = {
    u'home-page': u'home-page',
    u'blog': u'blog',
    u'profile': u'profile',
    u'work': u'work',
    u'home': u'home',
    u'other': u'other',
    u'ftp': u'ftp',
    u'reservations': u'reservations',
    u'app-install-page': u'app-install-page',
    }

  CONTACT_NAME_PROPERTY_PRINT_ORDER = [
    CONTACT_UPDATED,
    CONTACT_NAME,
    CONTACT_NAME_PREFIX,
    CONTACT_GIVEN_NAME,
    CONTACT_ADDITIONAL_NAME,
    CONTACT_FAMILY_NAME,
    CONTACT_NAME_SUFFIX,
    CONTACT_NICKNAME,
    CONTACT_MAIDENNAME,
    CONTACT_SHORTNAME,
    CONTACT_INITIALS,
    CONTACT_BIRTHDAY,
    CONTACT_GENDER,
    CONTACT_LOCATION,
    CONTACT_PRIORITY,
    CONTACT_SENSITIVITY,
    CONTACT_SUBJECT,
    CONTACT_LANGUAGE,
    CONTACT_NOTES,
    CONTACT_OCCUPATION,
    CONTACT_BILLING_INFORMATION,
    CONTACT_MILEAGE,
    CONTACT_DIRECTORY_SERVER,
    ]

  CONTACT_ARRAY_PROPERTY_PRINT_ORDER = [
    CONTACT_ADDRESSES,
    CONTACT_EMAILS,
    CONTACT_IMS,
    CONTACT_PHONES,
    CONTACT_CALENDARS,
    CONTACT_ORGANIZATIONS,
    CONTACT_EXTERNALIDS,
    CONTACT_EVENTS,
    CONTACT_HOBBIES,
    CONTACT_JOTS,
    CONTACT_RELATIONS,
    CONTACT_WEBSITES,
    CONTACT_USER_DEFINED_FIELDS,
    ]

  CONTACT_ARRAY_PROPERTIES = {
    CONTACT_ADDRESSES: {u'relMap': ADDRESS_REL_TO_TYPE_ARGUMENT, u'infoTitle': u'formatted', u'primary': True},
    CONTACT_EMAILS: {u'relMap': EMAIL_REL_TO_TYPE_ARGUMENT, u'infoTitle': u'address', u'primary': True},
    CONTACT_IMS: {u'relMap': IM_REL_TO_TYPE_ARGUMENT, u'infoTitle': u'address', u'primary': True},
    CONTACT_PHONES: {u'relMap': PHONE_REL_TO_TYPE_ARGUMENT, u'infoTitle': u'value', u'primary': True},
    CONTACT_CALENDARS: {u'relMap': CALENDAR_REL_TO_TYPE_ARGUMENT, u'infoTitle': u'address', u'primary': True},
    CONTACT_ORGANIZATIONS: {u'relMap': ORGANIZATION_REL_TO_TYPE_ARGUMENT, u'infoTitle': u'name', u'primary': True},
    CONTACT_EXTERNALIDS: {u'relMap': EXTERNALID_REL_TO_TYPE_ARGUMENT, u'infoTitle': u'value', u'primary': False},
    CONTACT_EVENTS: {u'relMap': EVENT_REL_TO_TYPE_ARGUMENT, u'infoTitle': u'date', u'primary': False},
    CONTACT_HOBBIES: {u'relMap': None, u'infoTitle': u'value', u'primary': False},
    CONTACT_JOTS: {u'relMap': JOT_REL_TO_TYPE_ARGUMENT, u'infoTitle': u'value', u'primary': False},
    CONTACT_RELATIONS: {u'relMap': RELATION_REL_TO_TYPE_ARGUMENT, u'infoTitle': u'value', u'primary': False},
    CONTACT_USER_DEFINED_FIELDS: {u'relMap': None, u'infoTitle': u'value', u'primary': False},
    CONTACT_WEBSITES: {u'relMap': WEBSITE_REL_TO_TYPE_ARGUMENT, u'infoTitle': u'value', u'primary': True},
    }

  CONTACT_GROUP_ARGUMENT_TO_PROPERTY_MAP = {
    u'name': CONTACT_GROUP_NAME,
    }

  @staticmethod
  def GetContactShortId(contactEntry):
    full_id = contactEntry.id.text
    return full_id[full_id.rfind(u'/')+1:]

  @staticmethod
  def GetContactFields(entityType):

    fields = {}

    def ClearFieldsList(fieldName):
      if fieldName in fields:
        del fields[fieldName]
      fields.setdefault(fieldName, [])

    def InitArrayItem(choices):
      item = {}
      rel = getChoice(choices, mapChoice=True, defaultChoice=None)
      if rel:
        item[u'rel'] = rel
        item[u'label'] = None
      else:
        item[u'rel'] = None
        item[u'label'] = getString(OB_STRING)
      return item

    def AppendItemToFieldsList(fieldName, fieldValue, checkBlankField=None):
      fields.setdefault(fieldName, [])
      if checkBlankField is None or fieldValue[checkBlankField]:
        fields[fieldName].append(fieldValue)

    while CLArgs.ArgumentsRemaining():
      fieldName = getChoice(ContactsManager.CONTACT_ARGUMENT_TO_PROPERTY_MAP, mapChoice=True)
      if fieldName == CONTACT_BIRTHDAY:
        fields[fieldName] = getYYYYMMDD(minLen=0)
      elif fieldName == CONTACT_GENDER:
        fields[fieldName] = getChoice(ContactsManager.GENDER_CHOICE_MAP, mapChoice=True)
      elif fieldName == CONTACT_PRIORITY:
        fields[fieldName] = getChoice(ContactsManager.PRIORITY_CHOICE_MAP, mapChoice=True)
      elif fieldName == CONTACT_SENSITIVITY:
        fields[fieldName] = getChoice(ContactsManager.SENSITIVITY_CHOICE_MAP, mapChoice=True)
      elif fieldName == CONTACT_LANGUAGE:
        fields[fieldName] = getChoice(LANGUAGE_CODES_MAP, mapChoice=True)
      elif fieldName == CONTACT_NOTES:
        if checkArgumentPresent(FILE_ARGUMENT):
          fields[fieldName] = readFile(getString(OB_FILE_NAME), encoding=GM_Globals[GM_SYS_ENCODING])
        else:
          fields[fieldName] = getString(OB_STRING, minLen=0)
      elif fieldName == CONTACT_ADDRESSES:
        if checkArgumentPresent(CLEAR_NONE_ARGUMENT):
          ClearFieldsList(fieldName)
          continue
        entry = InitArrayItem(ContactsManager.ADDRESS_TYPE_ARGUMENT_TO_REL)
        entry[u'primary'] = u'false'
        while CLArgs.ArgumentsRemaining():
          argument = getArgument()
          if argument in ContactsManager.ADDRESS_ARGUMENT_TO_FIELD_MAP:
            value = getString(OB_STRING, minLen=0)
            if value:
              entry[ContactsManager.ADDRESS_ARGUMENT_TO_FIELD_MAP[argument]] = value.replace(u'\\n', u'\n')
          elif argument in ContactsManager.PRIMARY_NOTPRIMARY_CHOICE_MAP:
            entry[u'primary'] = ContactsManager.PRIMARY_NOTPRIMARY_CHOICE_MAP[argument]
            break
          else:
            unknownArgumentExit()
        AppendItemToFieldsList(fieldName, entry)
      elif fieldName == CONTACT_CALENDARS:
        if checkArgumentPresent(CLEAR_NONE_ARGUMENT):
          ClearFieldsList(fieldName)
          continue
        entry = InitArrayItem(ContactsManager.CALENDAR_TYPE_ARGUMENT_TO_REL)
        entry[u'value'] = getString(OB_STRING, minLen=0)
        entry[u'primary'] = getChoice(ContactsManager.PRIMARY_NOTPRIMARY_CHOICE_MAP, mapChoice=True)
        AppendItemToFieldsList(fieldName, entry, u'value')
      elif fieldName == CONTACT_EMAILS:
        if checkArgumentPresent(CLEAR_NONE_ARGUMENT):
          ClearFieldsList(fieldName)
          continue
        entry = InitArrayItem(ContactsManager.EMAIL_TYPE_ARGUMENT_TO_REL)
        entry[u'value'] = getEmailAddress(noUid=True, minLen=0)
        entry[u'primary'] = getChoice(ContactsManager.PRIMARY_NOTPRIMARY_CHOICE_MAP, mapChoice=True)
        AppendItemToFieldsList(fieldName, entry, u'value')
      elif fieldName == CONTACT_EVENTS:
        if checkArgumentPresent(CLEAR_NONE_ARGUMENT):
          ClearFieldsList(fieldName)
          continue
        entry = InitArrayItem(ContactsManager.EVENT_TYPE_ARGUMENT_TO_REL)
        entry[u'value'] = getYYYYMMDD(minLen=0)
        AppendItemToFieldsList(fieldName, entry, u'value')
      elif fieldName == CONTACT_EXTERNALIDS:
        if checkArgumentPresent(CLEAR_NONE_ARGUMENT):
          ClearFieldsList(fieldName)
          continue
        entry = InitArrayItem(ContactsManager.EXTERNALID_TYPE_ARGUMENT_TO_REL)
        entry[u'value'] = getString(OB_STRING, minLen=0)
        AppendItemToFieldsList(fieldName, entry, u'value')
      elif fieldName == CONTACT_HOBBIES:
        if checkArgumentPresent(CLEAR_NONE_ARGUMENT):
          ClearFieldsList(fieldName)
          continue
        entry = {u'value': getString(OB_STRING, minLen=0)}
        AppendItemToFieldsList(fieldName, entry, u'value')
      elif fieldName == CONTACT_IMS:
        if checkArgumentPresent(CLEAR_NONE_ARGUMENT):
          ClearFieldsList(fieldName)
          continue
        entry = InitArrayItem(ContactsManager.IM_TYPE_ARGUMENT_TO_REL)
        entry[u'protocol'] = getChoice(ContactsManager.IM_PROTOCOL_TO_REL_MAP, mapChoice=True)
        entry[u'value'] = getString(OB_STRING, minLen=0)
        entry[u'primary'] = getChoice(ContactsManager.PRIMARY_NOTPRIMARY_CHOICE_MAP, mapChoice=True)
        AppendItemToFieldsList(fieldName, entry, u'value')
      elif fieldName == CONTACT_JOTS:
        if checkArgumentPresent(CLEAR_NONE_ARGUMENT):
          ClearFieldsList(fieldName)
          continue
        entry = {u'rel': getChoice(ContactsManager.JOT_TYPE_ARGUMENT_TO_REL, mapChoice=True)}
        entry[u'value'] = getString(OB_STRING, minLen=0)
        AppendItemToFieldsList(fieldName, entry, u'value')
      elif fieldName == CONTACT_ORGANIZATIONS:
        if checkArgumentPresent(CLEAR_NONE_ARGUMENT):
          ClearFieldsList(fieldName)
          continue
        entry = InitArrayItem(ContactsManager.ORGANIZATION_TYPE_ARGUMENT_TO_REL)
        entry[u'primary'] = u'false'
        entry[u'value'] = getString(OB_STRING, minLen=0)
        while CLArgs.ArgumentsRemaining():
          argument = getArgument()
          if argument in ContactsManager.ORGANIZATION_ARGUMENT_TO_FIELD_MAP:
            value = getString(OB_STRING, minLen=0)
            if value:
              entry[ContactsManager.ORGANIZATION_ARGUMENT_TO_FIELD_MAP[argument]] = value
          elif argument in ContactsManager.PRIMARY_NOTPRIMARY_CHOICE_MAP:
            entry[u'primary'] = ContactsManager.PRIMARY_NOTPRIMARY_CHOICE_MAP[argument]
            break
          else:
            unknownArgumentExit()
        AppendItemToFieldsList(fieldName, entry, u'value')
      elif fieldName == CONTACT_PHONES:
        if checkArgumentPresent(CLEAR_NONE_ARGUMENT):
          ClearFieldsList(fieldName)
          continue
        entry = InitArrayItem(ContactsManager.PHONE_TYPE_ARGUMENT_TO_REL)
        entry[u'value'] = getString(OB_STRING, minLen=0)
        entry[u'primary'] = getChoice(ContactsManager.PRIMARY_NOTPRIMARY_CHOICE_MAP, mapChoice=True)
        AppendItemToFieldsList(fieldName, entry, u'value')
      elif fieldName == CONTACT_RELATIONS:
        if checkArgumentPresent(CLEAR_NONE_ARGUMENT):
          ClearFieldsList(fieldName)
          continue
        entry = InitArrayItem(ContactsManager.RELATION_TYPE_ARGUMENT_TO_REL)
        entry[u'value'] = getString(OB_STRING, minLen=0)
        AppendItemToFieldsList(fieldName, entry, u'value')
      elif fieldName == CONTACT_USER_DEFINED_FIELDS:
        if checkArgumentPresent(CLEAR_NONE_ARGUMENT):
          ClearFieldsList(fieldName)
          continue
        entry = {u'rel': getString(OB_STRING, minLen=0), u'value': getString(OB_STRING, minLen=0)}
        if not entry[u'rel'] or entry[u'rel'].lower() == u'none':
          entry[u'rel'] = None
        AppendItemToFieldsList(fieldName, entry, u'value')
      elif fieldName == CONTACT_WEBSITES:
        if checkArgumentPresent(CLEAR_NONE_ARGUMENT):
          ClearFieldsList(fieldName)
          continue
        entry = InitArrayItem(ContactsManager.WEBSITE_TYPE_ARGUMENT_TO_REL)
        entry[u'value'] = getString(OB_STRING, minLen=0)
        entry[u'primary'] = getChoice(ContactsManager.PRIMARY_NOTPRIMARY_CHOICE_MAP, mapChoice=True)
        AppendItemToFieldsList(fieldName, entry, u'value')
      elif fieldName == CONTACT_GROUPS:
        if entityType != Entity.USER:
          CLArgs.Backup()
          unknownArgumentExit()
        AppendItemToFieldsList(CONTACT_GROUPS_LIST, getString(OB_STRING))
      else:
        fields[fieldName] = getString(OB_STRING, minLen=0)
    return fields

  @staticmethod
  def FieldsToContact(fields):
    import gdata.apps.contacts

    def GetField(fieldName):
      return fields.get(fieldName)

    def SetClassAttribute(value, fieldClass, processNLs, attr):
      if value:
        if processNLs:
          value = value.replace(u'\\n', u'\n')
        if attr == u'text':
          return fieldClass(text=value)
        if attr == u'code':
          return fieldClass(code=value)
        if attr == u'rel':
          return fieldClass(rel=value)
        if attr == u'value':
          return fieldClass(value=value)
        if attr == u'value_string':
          return fieldClass(value_string=value)
        if attr == u'when':
          return fieldClass(when=value)
      return None

    def GetContactField(fieldName, fieldClass, processNLs=False, attr=u'text'):
      return SetClassAttribute(fields.get(fieldName), fieldClass, processNLs, attr)

    def GetListEntryField(entry, fieldName, fieldClass, processNLs=False, attr=u'text'):
      return SetClassAttribute(entry.get(fieldName), fieldClass, processNLs, attr)

    contactEntry = gdata.apps.contacts.ContactEntry()
    value = GetField(CONTACT_NAME)
    if not value:
      value = u' '.join([fields[fieldName] for fieldName in ContactsManager.CONTACT_NAME_FIELDS if fieldName in fields])
    contactEntry.name = gdata.apps.contacts.Name(full_name=gdata.apps.contacts.FullName(text=value))
    contactEntry.name.name_prefix = GetContactField(CONTACT_NAME_PREFIX, gdata.apps.contacts.NamePrefix)
    contactEntry.name.given_name = GetContactField(CONTACT_GIVEN_NAME, gdata.apps.contacts.GivenName)
    contactEntry.name.additional_name = GetContactField(CONTACT_ADDITIONAL_NAME, gdata.apps.contacts.AdditionalName)
    contactEntry.name.family_name = GetContactField(CONTACT_FAMILY_NAME, gdata.apps.contacts.FamilyName)
    contactEntry.name.name_suffix = GetContactField(CONTACT_NAME_SUFFIX, gdata.apps.contacts.NameSuffix)
    contactEntry.nickname = GetContactField(CONTACT_NICKNAME, gdata.apps.contacts.Nickname)
    contactEntry.maidenName = GetContactField(CONTACT_MAIDENNAME, gdata.apps.contacts.MaidenName)
    contactEntry.shortName = GetContactField(CONTACT_SHORTNAME, gdata.apps.contacts.ShortName)
    contactEntry.initials = GetContactField(CONTACT_INITIALS, gdata.apps.contacts.Initials)
    contactEntry.birthday = GetContactField(CONTACT_BIRTHDAY, gdata.apps.contacts.Birthday, attr=u'when')
    contactEntry.gender = GetContactField(CONTACT_GENDER, gdata.apps.contacts.Gender, attr=u'value')
    contactEntry.where = GetContactField(CONTACT_LOCATION, gdata.apps.contacts.Where, attr=u'value_string')
    contactEntry.priority = GetContactField(CONTACT_PRIORITY, gdata.apps.contacts.Priority, attr=u'rel')
    contactEntry.sensitivity = GetContactField(CONTACT_SENSITIVITY, gdata.apps.contacts.Sensitivity, attr=u'rel')
    contactEntry.subject = GetContactField(CONTACT_SUBJECT, gdata.apps.contacts.Subject)
    contactEntry.language = GetContactField(CONTACT_LANGUAGE, gdata.apps.contacts.Language, attr=u'code')
    contactEntry.content = GetContactField(CONTACT_NOTES, gdata.apps.contacts.Content, processNLs=True)
    contactEntry.occupation = GetContactField(CONTACT_OCCUPATION, gdata.apps.contacts.Occupation)
    contactEntry.billingInformation = GetContactField(CONTACT_BILLING_INFORMATION, gdata.apps.contacts.BillingInformation, processNLs=True)
    contactEntry.mileage = GetContactField(CONTACT_MILEAGE, gdata.apps.contacts.Mileage)
    contactEntry.directoryServer = GetContactField(CONTACT_DIRECTORY_SERVER, gdata.apps.contacts.DirectoryServer)
    value = GetField(CONTACT_ADDRESSES)
    if value:
      for address in value:
        street = GetListEntryField(address, u'street', gdata.apps.contacts.Street)
        pobox = GetListEntryField(address, u'pobox', gdata.apps.contacts.PoBox)
        neighborhood = GetListEntryField(address, u'neighborhood', gdata.apps.contacts.Neighborhood)
        city = GetListEntryField(address, u'city', gdata.apps.contacts.City)
        region = GetListEntryField(address, u'region', gdata.apps.contacts.Region)
        postcode = GetListEntryField(address, u'postcode', gdata.apps.contacts.Postcode)
        country = GetListEntryField(address, u'country', gdata.apps.contacts.Country)
        formatted_address = GetListEntryField(address, u'value', gdata.apps.contacts.FormattedAddress, processNLs=True)
        contactEntry.structuredPostalAddress.append(gdata.apps.contacts.StructuredPostalAddress(street=street, pobox=pobox, neighborhood=neighborhood,
                                                                                                city=city, region=region,
                                                                                                postcode=postcode, country=country,
                                                                                                formatted_address=formatted_address,
                                                                                                rel=address[u'rel'], label=address[u'label'], primary=address[u'primary']))
    value = GetField(CONTACT_CALENDARS)
    if value:
      for calendarLink in value:
        contactEntry.calendarLink.append(gdata.apps.contacts.CalendarLink(href=calendarLink[u'value'], rel=calendarLink[u'rel'], label=calendarLink[u'label'], primary=calendarLink[u'primary']))
    value = GetField(CONTACT_EMAILS)
    if value:
      for emailaddr in value:
        contactEntry.email.append(gdata.apps.contacts.Email(address=emailaddr[u'value'], rel=emailaddr[u'rel'], label=emailaddr[u'label'], primary=emailaddr[u'primary']))
    value = GetField(CONTACT_EXTERNALIDS)
    if value:
      for externalid in value:
        contactEntry.externalId.append(gdata.apps.contacts.ExternalId(value=externalid[u'value'], rel=externalid[u'rel'], label=externalid[u'label']))
    value = GetField(CONTACT_EVENTS)
    if value:
      for event in value:
        contactEntry.event.append(gdata.apps.contacts.Event(rel=event[u'rel'], label=event[u'label'],
                                                            when=gdata.apps.contacts.When(startTime=event[u'value'])))
    value = GetField(CONTACT_HOBBIES)
    if value:
      for hobby in value:
        contactEntry.hobby.append(gdata.apps.contacts.Hobby(text=hobby[u'value']))
    value = GetField(CONTACT_IMS)
    if value:
      for im in value:
        contactEntry.im.append(gdata.apps.contacts.IM(address=im[u'value'], protocol=im[u'protocol'], rel=im[u'rel'], label=im[u'label'], primary=im[u'primary']))
    value = GetField(CONTACT_JOTS)
    if value:
      for jot in value:
        contactEntry.jot.append(gdata.apps.contacts.Jot(text=jot[u'value'], rel=jot[u'rel']))
    value = GetField(CONTACT_ORGANIZATIONS)
    if value:
      for organization in value:
        org_name = gdata.apps.contacts.OrgName(text=organization[u'value'])
        department = GetListEntryField(organization, u'department', gdata.apps.contacts.OrgDepartment)
        title = GetListEntryField(organization, u'title', gdata.apps.contacts.OrgTitle)
        job_description = GetListEntryField(organization, u'jobdescription', gdata.apps.contacts.OrgJobDescription)
        symbol = GetListEntryField(organization, u'symbol', gdata.apps.contacts.OrgSymbol)
        where = GetListEntryField(organization, u'where', gdata.apps.contacts.Where, attr=u'value_string')
        contactEntry.organization.append(gdata.apps.contacts.Organization(name=org_name, department=department,
                                                                          title=title, job_description=job_description,
                                                                          symbol=symbol, where=where,
                                                                          rel=organization[u'rel'], label=organization[u'label'], primary=organization[u'primary']))
    value = GetField(CONTACT_PHONES)
    if value:
      for phone in value:
        contactEntry.phoneNumber.append(gdata.apps.contacts.PhoneNumber(text=phone[u'value'], rel=phone[u'rel'], label=phone[u'label'], primary=phone[u'primary']))
    value = GetField(CONTACT_RELATIONS)
    if value:
      for relation in value:
        contactEntry.relation.append(gdata.apps.contacts.Relation(text=relation[u'value'], rel=relation[u'rel'], label=relation[u'label']))
    value = GetField(CONTACT_USER_DEFINED_FIELDS)
    if value:
      for userdefinedfield in value:
        contactEntry.userDefinedField.append(gdata.apps.contacts.UserDefinedField(key=userdefinedfield[u'rel'], value=userdefinedfield[u'value']))
    value = GetField(CONTACT_WEBSITES)
    if value:
      for website in value:
        contactEntry.website.append(gdata.apps.contacts.Website(href=website[u'value'], rel=website[u'rel'], label=website[u'label'], primary=website[u'primary']))
    return contactEntry

  @staticmethod
  def AddContactGroupsToContact(contactsObject, contactEntry, contactGroupsList, user):
    import gdata.apps.contacts

    contactEntry.groupMembershipInfo = []
    for groupId in contactGroupsList:
      if groupId != u'clear':
        contactEntry.groupMembershipInfo.append(gdata.apps.contacts.GroupMembershipInfo(deleted=u'false',
                                                                                        href=contactsObject.GetContactGroupFeedUri(contact_list=user, projection=u'base', groupId=groupId)))
      else:
        contactEntry.groupMembershipInfo = []

  @staticmethod
  def ContactToFields(contactEntry):
    fields = {}

    def GetContactField(fieldName, attrlist):
      objAttr = contactEntry
      for attr in attrlist:
        objAttr = getattr(objAttr, attr)
        if not objAttr:
          return
      fields[fieldName] = objAttr

    def GetListEntryField(entry, attrlist):
      objAttr = entry
      for attr in attrlist:
        objAttr = getattr(objAttr, attr)
        if not objAttr:
          return None
      return objAttr

    def AppendItemToFieldsList(fieldName, fieldValue):
      fields.setdefault(fieldName, [])
      fields[fieldName].append(fieldValue)

    fields[CONTACT_ID] = ContactsManager.GetContactShortId(contactEntry)
    GetContactField(CONTACT_UPDATED, [u'updated', u'text'])
    if not contactEntry.deleted:
      GetContactField(CONTACT_NAME, [u'title', u'text'])
    else:
      fields[CONTACT_NAME] = u'Deleted'
    GetContactField(CONTACT_NAME_PREFIX, [u'name', u'name_prefix', u'text'])
    GetContactField(CONTACT_GIVEN_NAME, [u'name', u'given_name', u'text'])
    GetContactField(CONTACT_ADDITIONAL_NAME, [u'name', u'additional_name', u'text'])
    GetContactField(CONTACT_FAMILY_NAME, [u'name', u'family_name', u'text'])
    GetContactField(CONTACT_NAME_SUFFIX, [u'name', u'name_suffix', u'text'])
    GetContactField(CONTACT_NICKNAME, [u'nickname', u'text'])
    GetContactField(CONTACT_MAIDENNAME, [u'maidenName', u'text'])
    GetContactField(CONTACT_SHORTNAME, [u'shortName', u'text'])
    GetContactField(CONTACT_INITIALS, [u'initials', u'text'])
    GetContactField(CONTACT_BIRTHDAY, [u'birthday', u'when'])
    GetContactField(CONTACT_GENDER, [u'gender', u'value'])
    GetContactField(CONTACT_SUBJECT, [u'subject', u'text'])
    GetContactField(CONTACT_LANGUAGE, [u'language', u'code'])
    GetContactField(CONTACT_PRIORITY, [u'priority', u'rel'])
    GetContactField(CONTACT_SENSITIVITY, [u'sensitivity', u'rel'])
    GetContactField(CONTACT_NOTES, [u'content', u'text'])
    GetContactField(CONTACT_LOCATION, [u'where', u'value_string'])
    GetContactField(CONTACT_OCCUPATION, [u'occupation', u'text'])
    GetContactField(CONTACT_BILLING_INFORMATION, [u'billingInformation', u'text'])
    GetContactField(CONTACT_MILEAGE, [u'mileage', u'text'])
    GetContactField(CONTACT_DIRECTORY_SERVER, [u'directoryServer', u'text'])
    for address in contactEntry.structuredPostalAddress:
      AppendItemToFieldsList(CONTACT_ADDRESSES,
                             {u'rel': address.rel,
                              u'label': address.label,
                              u'value': GetListEntryField(address, [u'formatted_address', u'text']),
                              u'street': GetListEntryField(address, [u'street', u'text']),
                              u'pobox': GetListEntryField(address, [u'pobox', u'text']),
                              u'neighborhood': GetListEntryField(address, [u'neighborhood', u'text']),
                              u'city': GetListEntryField(address, [u'city', u'text']),
                              u'region': GetListEntryField(address, [u'region', u'text']),
                              u'postcode': GetListEntryField(address, [u'postcode', u'text']),
                              u'country': GetListEntryField(address, [u'country', u'text']),
                              u'primary': address.primary})
    for calendarLink in contactEntry.calendarLink:
      AppendItemToFieldsList(CONTACT_CALENDARS,
                             {u'rel': calendarLink.rel,
                              u'label': calendarLink.label,
                              u'value': calendarLink.href,
                              u'primary': calendarLink.primary})
    for emailaddr in contactEntry.email:
      AppendItemToFieldsList(CONTACT_EMAILS,
                             {u'rel': emailaddr.rel,
                              u'label': emailaddr.label,
                              u'value': emailaddr.address,
                              u'primary': emailaddr.primary})
    for externalid in contactEntry.externalId:
      AppendItemToFieldsList(CONTACT_EXTERNALIDS,
                             {u'rel': externalid.rel,
                              u'label': externalid.label,
                              u'value': externalid.value})
    for event in contactEntry.event:
      AppendItemToFieldsList(CONTACT_EVENTS,
                             {u'rel': event.rel,
                              u'label': event.label,
                              u'value': GetListEntryField(event, [u'when', u'startTime'])})
    for hobby in contactEntry.hobby:
      AppendItemToFieldsList(CONTACT_HOBBIES,
                             {u'value': hobby.text})
    for im in contactEntry.im:
      AppendItemToFieldsList(CONTACT_IMS,
                             {u'rel': im.rel,
                              u'label': im.label,
                              u'value': im.address,
                              u'protocol': im.protocol,
                              u'primary': im.primary})
    for jot in contactEntry.jot:
      AppendItemToFieldsList(CONTACT_JOTS,
                             {u'rel': jot.rel,
                              u'value': jot.text})
    for organization in contactEntry.organization:
      AppendItemToFieldsList(CONTACT_ORGANIZATIONS,
                             {u'rel': organization.rel,
                              u'label': organization.label,
                              u'value': GetListEntryField(organization, [u'name', u'text']),
                              u'department': GetListEntryField(organization, [u'department', u'text']),
                              u'title': GetListEntryField(organization, [u'title', u'text']),
                              u'symbol': GetListEntryField(organization, [u'symbol', u'text']),
                              u'jobdescription': GetListEntryField(organization, [u'job_description', u'text']),
                              u'where': GetListEntryField(organization, [u'where', u'value_string']),
                              u'primary': organization.primary})
    for phone in contactEntry.phoneNumber:
      AppendItemToFieldsList(CONTACT_PHONES,
                             {u'rel': phone.rel,
                              u'label': phone.label,
                              u'value': phone.text,
                              u'primary': phone.primary})
    for relation in contactEntry.relation:
      AppendItemToFieldsList(CONTACT_RELATIONS,
                             {u'rel': relation.rel,
                              u'label': relation.label,
                              u'value': relation.text})
    for userdefinedfield in contactEntry.userDefinedField:
      AppendItemToFieldsList(CONTACT_USER_DEFINED_FIELDS,
                             {u'rel': userdefinedfield.key,
                              u'value': userdefinedfield.value})
    for website in contactEntry.website:
      AppendItemToFieldsList(CONTACT_WEBSITES,
                             {u'rel': website.rel,
                              u'label': website.label,
                              u'value': website.href,
                              u'primary': website.primary})
    for group in contactEntry.groupMembershipInfo:
      AppendItemToFieldsList(CONTACT_GROUPS, group.href[group.href.rfind(u'/')+1:])
    return fields

  @staticmethod
  def GetContactGroupFields():

    fields = {}
    while CLArgs.ArgumentsRemaining():
      fieldName = getChoice(ContactsManager.CONTACT_GROUP_ARGUMENT_TO_PROPERTY_MAP, mapChoice=True)
      if fieldName == CONTACT_GROUP_NAME:
        fields[fieldName] = getString(OB_STRING)
      else:
        fields[fieldName] = getString(OB_STRING, minLen=0)
    if not fields.get(CONTACT_GROUP_NAME):
      missingArgumentExit(u'name')
    return fields

  @staticmethod
  def FieldsToContactGroup(fields):
    import atom
    import gdata.apps.contacts

    groupEntry = gdata.apps.contacts.GroupEntry(title=atom.Title(text=fields[CONTACT_GROUP_NAME]))
    return groupEntry

  @staticmethod
  def ContactGroupToFields(groupEntry):
    fields = {}

    def GetGroupField(fieldName, attrlist):
      objAttr = groupEntry
      for attr in attrlist:
        objAttr = getattr(objAttr, attr)
        if not objAttr:
          return
      fields[fieldName] = objAttr

    fields[CONTACT_GROUP_ID] = ContactsManager.GetContactShortId(groupEntry)
    GetGroupField(CONTACT_GROUP_UPDATED, [u'updated', u'text'])
    if not groupEntry.deleted:
      GetGroupField(CONTACT_GROUP_NAME, [u'title', u'text'])
    else:
      fields[CONTACT_GROUP_NAME] = u'Deleted'
    return fields

CONTACTS_PROJECTION_CHOICES_MAP = {u'basic': u'thin', u'thin': u'thin', u'full': u'full',}
CONTACTS_ORDERBY_CHOICES_MAP = {u'lastmodified': u'lastmodified',}

def normalizeContactId(contactId):
  if contactId.startswith(u'id:'):
    return contactId[3:]
  return contactId

def _initContactQueryAttributes():
  return {u'query': None, u'projection': u'full', u'url_params': {u'max-results': str(GC_Values[GC_CONTACT_MAX_RESULTS])},
          u'contactGroup': None, u'group': None, u'emailMatchPattern': None, u'emailMatchType': None}

def _getContactQueryAttributes(contactQuery, myarg, entityType, allowOutputAttributes):
  if myarg == u'query':
    contactQuery[u'query'] = getString(OB_QUERY)
  elif myarg == u'contactgroup':
    if entityType == Entity.USER:
      contactQuery[u'contactGroup'] = getString(OB_CONTACT_GROUP_ITEM)
    else:
      unknownArgumentExit()
  elif myarg == u'emailmatchpattern':
    contactQuery[u'emailMatchPattern'] = getREPattern()
  elif myarg == u'emailmatchtype':
    contactQuery[u'emailMatchType'] = getString(OB_CONTACT_EMAIL_TYPE)
  elif myarg == u'updatedmin':
    contactQuery[u'url_params'][u'updated-min'] = getYYYYMMDD()
  elif not allowOutputAttributes:
    unknownArgumentExit()
  elif myarg == u'orderby':
    contactQuery[u'url_params'][u'orderby'] = getChoice(CONTACTS_ORDERBY_CHOICES_MAP, mapChoice=True)
    contactQuery[u'url_params'][u'sortorder'] = getChoice(SORTORDER_CHOICES_MAP, defaultChoice=u'ascending')
  elif myarg in CONTACTS_PROJECTION_CHOICES_MAP:
    contactQuery[u'projection'] = CONTACTS_PROJECTION_CHOICES_MAP[myarg]
  elif myarg == u'showdeleted':
    contactQuery[u'url_params'][u'showdeleted'] = u'true'
  else:
    unknownArgumentExit()

def queryContacts(contactsObject, contactQuery, entityType, user, i=0, count=0):
  if contactQuery[u'query'] or contactQuery[u'group']:
    uri = getContactsQuery(feed=contactsObject.GetContactFeedUri(contact_list=user, projection=contactQuery[u'projection']),
                           text_query=contactQuery[u'query'], group=contactQuery[u'group']).ToUri()
  else:
    uri = contactsObject.GetContactFeedUri(contact_list=user, projection=contactQuery[u'projection'])
  printGettingAllEntityItemsForWhom(Entity.CONTACT, user, i, count, qualifier=queryQualifier(contactQuery[u'query']))
  page_message = getPageMessage()
  try:
    entityList = callGDataPages(contactsObject, u'GetContactsFeed',
                                page_message=page_message,
                                throw_errors=[GDATA_BAD_REQUEST, GDATA_SERVICE_NOT_APPLICABLE, GDATA_FORBIDDEN],
                                retry_errors=[GDATA_INTERNAL_SERVER_ERROR],
                                uri=uri, url_params=contactQuery[u'url_params'])
    return entityList
  except GData_badRequest as e:
    entityActionFailedWarning([entityType, user, Entity.CONTACT, u''], e.message, i, count)
  except GData_forbidden:
    entityServiceNotApplicableWarning(entityType, user, i, count)
  except GData_serviceNotApplicable:
    entityUnknownWarning(entityType, user, i, count)
  return None

def contactEmailAddressMatches(contactsManager, contactQuery, fields):
  emailMatchType = contactQuery[u'emailMatchType']
  for item in fields.get(CONTACT_EMAILS, []):
    if contactQuery[u'emailMatchPattern'].match(item[u'value']):
      if not emailMatchType or emailMatchType == item.get(u'label') or emailMatchType == contactsManager.CONTACT_ARRAY_PROPERTIES[CONTACT_EMAILS][u'relMap'].get(item[u'rel'], u'custom'):
        return True
  return False

def getContactGroupsInfo(contactsManager, contactsObject, entityType, entityName, i, count):
  uri = contactsObject.GetContactGroupFeedUri(contact_list=entityName)
  contactGroupIDs = {}
  contactGroupNames = {}
  try:
    groups = callGDataPages(contactsObject, u'GetGroupsFeed',
                            throw_errors=[GDATA_SERVICE_NOT_APPLICABLE, GDATA_FORBIDDEN],
                            retry_errors=[GDATA_INTERNAL_SERVER_ERROR],
                            uri=uri)
    if groups:
      for group in groups:
        fields = contactsManager.ContactGroupToFields(group)
        contactGroupIDs[fields[CONTACT_GROUP_ID]] = fields[CONTACT_GROUP_NAME]
        contactGroupNames.setdefault(fields[CONTACT_GROUP_NAME], [])
        contactGroupNames[fields[CONTACT_GROUP_NAME]].append(fields[CONTACT_GROUP_ID])
  except GData_forbidden:
    entityServiceNotApplicableWarning(entityType, entityName, i, count)
    return (contactGroupIDs, False)
  except GData_serviceNotApplicable:
    entityUnknownWarning(entityType, entityName, i, count)
    return (contactGroupIDs, False)
  return (contactGroupIDs, contactGroupNames)

def validateContactGroup(contactsManager, contactsObject, contactGroupName, contactGroupIDs, contactGroupNames, entityType, entityName, i, count):
  if not contactGroupNames:
    contactGroupIDs, contactGroupNames = getContactGroupsInfo(contactsManager, contactsObject, entityType, entityName, i, count)
    if contactGroupNames is False:
      return (None, contactGroupIDs, contactGroupNames)
  if contactGroupName == u'clear':
    return (contactGroupName, contactGroupIDs, contactGroupNames)
  cg = UID_PATTERN.match(contactGroupName)
  if cg:
    if cg.group(1) in contactGroupIDs:
      return (cg.group(1), contactGroupIDs, contactGroupNames)
  else:
    if contactGroupName in contactGroupNames:
      return (contactGroupNames[contactGroupName][0], contactGroupIDs, contactGroupNames)
  return (None, contactGroupIDs, contactGroupNames)

def validateContactGroupsList(contactsManager, contactsObject, contactId, fields, entityType, entityName, i, count):
  result = True
  contactGroupIDs = contactGroupNames = None
  contactGroupsList = []
  for contactGroup in fields[CONTACT_GROUPS_LIST]:
    groupId, contactGroupIDs, contactGroupNames = validateContactGroup(contactsManager, contactsObject, contactGroup, contactGroupIDs, contactGroupNames, entityType, entityName, i, count)
    if groupId:
      contactGroupsList.append(groupId)
    else:
      if contactGroupNames:
        entityActionNotPerformedWarning([entityType, entityName, Entity.CONTACT, contactId],
                                        entityTypeNameMessage(Entity.CONTACT_GROUP, contactGroup, PHRASE_DOES_NOT_EXIST))
      result = False
  return (result, contactGroupsList)

def _createContact(users, entityType):
  contactsManager = ContactsManager()
  fields = contactsManager.GetContactFields(entityType)
  contactEntry = contactsManager.FieldsToContact(fields)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, contactsObject = getContactsObject(entityType, user, i, count)
    if not contactsObject:
      continue
    if fields.get(CONTACT_GROUPS_LIST):
      result, contactGroupsList = validateContactGroupsList(contactsManager, contactsObject, u'', fields, entityType, user, i, count)
      if not result:
        continue
      contactsManager.AddContactGroupsToContact(contactsObject, contactEntry, contactGroupsList, user)
    try:
      contact = callGData(contactsObject, u'CreateContact',
                          throw_errors=[GDATA_BAD_REQUEST, GDATA_SERVICE_NOT_APPLICABLE, GDATA_FORBIDDEN],
                          retry_errors=[GDATA_INTERNAL_SERVER_ERROR],
                          new_contact=contactEntry, insert_uri=contactsObject.GetContactFeedUri(contact_list=user))
      entityActionPerformed([entityType, user, Entity.CONTACT, contactsManager.GetContactShortId(contact)], i, count)
    except GData_badRequest as e:
      entityActionFailedWarning([entityType, user, Entity.CONTACT, u''], e.message, i, count)
    except GData_forbidden:
      entityServiceNotApplicableWarning(entityType, user, i, count)
    except GData_serviceNotApplicable:
      entityUnknownWarning(entityType, user, i, count)

# gam <UserTypeEntity> create contact <ContactAttributes>+
def createUserContact(users):
  _createContact(users, Entity.USER)

# gam create contact <ContactAttributes>+
def doCreateDomainContact():
  _createContact([GC_Values[GC_DOMAIN],], Entity.DOMAIN)

def _uppdateContacts(users, entityType):
  contactsManager = ContactsManager()
  entityList = getEntityList(OB_CONTACT_ENTITY)
  update_fields = contactsManager.GetContactFields(entityType)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, contactsObject = getContactsObject(entityType, user, i, count)
    if not contactsObject:
      continue
    j = 0
    jcount = len(entityList)
    entityPerformActionNumItems([entityType, user], jcount, Entity.CONTACT, i, count)
    if jcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
      continue
    contactGroupsList = None
    Indent.Increment()
    for contactId in entityList:
      j += 1
      contactId = normalizeContactId(contactId)
      if update_fields.get(CONTACT_GROUPS_LIST) and not contactGroupsList:
        result, contactGroupsList = validateContactGroupsList(contactsManager, contactsObject, contactId, update_fields, entityType, user, i, count)
        if not result:
          break
      try:
        contact = callGData(contactsObject, u'GetContact',
                            throw_errors=[GDATA_NOT_FOUND, GDATA_BAD_REQUEST, GDATA_SERVICE_NOT_APPLICABLE, GDATA_FORBIDDEN, GDATA_NOT_IMPLEMENTED],
                            retry_errors=[GDATA_INTERNAL_SERVER_ERROR],
                            uri=contactsObject.GetContactFeedUri(contact_list=user, contactId=contactId))
        fields = contactsManager.ContactToFields(contact)
        for field in update_fields:
          fields[field] = update_fields[field]
        contactEntry = contactsManager.FieldsToContact(fields)
        if contactGroupsList:
          contactsManager.AddContactGroupsToContact(contactsObject, contactEntry, contactGroupsList, user)
        elif fields.get(CONTACT_GROUPS):
          contactsManager.AddContactGroupsToContact(contactsObject, contactEntry, fields[CONTACT_GROUPS], user)
        contactEntry.category = contact.category
        contactEntry.link = contact.link
        contactEntry.etag = contact.etag
        contactEntry.id = contact.id
        callGData(contactsObject, u'UpdateContact',
                  throw_errors=[GDATA_NOT_FOUND, GDATA_BAD_REQUEST, GDATA_PRECONDITION_FAILED, GDATA_SERVICE_NOT_APPLICABLE, GDATA_FORBIDDEN],
                  edit_uri=contactsObject.GetContactFeedUri(contact_list=user, contactId=contactId), updated_contact=contactEntry, extra_headers={u'If-Match': contact.etag})
        entityActionPerformed([entityType, user, Entity.CONTACT, contactId], j, jcount)
      except (GData_notFound, GData_badRequest, GData_preconditionFailed) as e:
        entityActionFailedWarning([entityType, user, Entity.CONTACT, contactId], e.message, j, jcount)
      except (GData_forbidden, GData_notImplemented):
        entityServiceNotApplicableWarning(entityType, user, i, count)
        break
      except GData_serviceNotApplicable:
        entityUnknownWarning(entityType, user, i, count)
        break
    Indent.Decrement()

# gam <UserTypeEntity> update contacts <ContactEntity> [contactgroup <ContactGroupItem>] <ContactAttributes>+
def updateUserContacts(users):
  _uppdateContacts(users, Entity.USER)

# gam update contacts <ContactEntity> <ContactAttributes>+
def doUpdateDomainContacts():
  _uppdateContacts([GC_Values[GC_DOMAIN],], Entity.DOMAIN)

def _deleteContacts(users, entityType):
  contactsManager = ContactsManager()
  contactQuery = _initContactQueryAttributes()
  if peekArgumentPresent([u'query', u'contactgroup', u'emailmatchpattern', u'updated_min']):
    entityList = None
    while CLArgs.ArgumentsRemaining():
      myarg = getArgument()
      _getContactQueryAttributes(contactQuery, myarg, entityType, False)
  else:
    entityList = getEntityList(OB_CONTACT_ENTITY)
  contactIdLists = entityList if isinstance(entityList, dict) else None
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    if contactIdLists:
      entityList = contactIdLists[user]
    user, contactsObject = getContactsObject(entityType, user, i, count)
    if not contactsObject:
      continue
    if contactQuery[u'contactGroup']:
      groupId, _, contactGroupNames = validateContactGroup(contactsManager, contactsObject, contactQuery[u'contactGroup'], None, None, entityType, user, i, count)
      if not groupId:
        if contactGroupNames:
          entityActionFailedWarning([entityType, user, Entity.CONTACT_GROUP, contactQuery[u'contactGroup']], PHRASE_DOES_NOT_EXIST, i, count)
        continue
      contactQuery[u'group'] = contactsObject.GetContactGroupFeedUri(contact_list=user, projection=u'base', groupId=groupId)
    if contactQuery[u'query'] or contactQuery[u'group']:
      entityList = queryContacts(contactsObject, contactQuery, entityType, user, i, count)
      if entityList is None:
        continue
    j = 0
    jcount = len(entityList)
    entityPerformActionModifierNumItems([entityType, user], PHRASE_MAXIMUM_OF, jcount, Entity.CONTACT, i, count)
    if jcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
      continue
    Indent.Increment()
    for contact in entityList:
      j += 1
      try:
        if not contactQuery[u'query'] and not contactQuery[u'group']:
          contactId = normalizeContactId(contact)
          contact = callGData(contactsObject, u'GetContact',
                              throw_errors=[GDATA_NOT_FOUND, GDATA_BAD_REQUEST, GDATA_SERVICE_NOT_APPLICABLE, GDATA_FORBIDDEN, GDATA_NOT_IMPLEMENTED],
                              retry_errors=[GDATA_INTERNAL_SERVER_ERROR],
                              uri=contactsObject.GetContactFeedUri(contact_list=user, contactId=contactId))
        else:
          contactId = contactsManager.GetContactShortId(contact)
          fields = contactsManager.ContactToFields(contact)
          if contactQuery[u'emailMatchPattern'] and not contactEmailAddressMatches(contactsManager, contactQuery, fields):
            continue
        callGData(contactsObject, u'DeleteContact',
                  throw_errors=[GDATA_NOT_FOUND, GDATA_SERVICE_NOT_APPLICABLE, GDATA_FORBIDDEN],
                  edit_uri=contactsObject.GetContactFeedUri(contact_list=user, contactId=contactId), extra_headers={u'If-Match': contact.etag})
        entityActionPerformed([entityType, user, Entity.CONTACT, contactId], j, jcount)
      except (GData_notFound, GData_badRequest) as e:
        entityActionFailedWarning([entityType, user, Entity.CONTACT, contactId], e.message, j, jcount)
      except (GData_forbidden, GData_notImplemented):
        entityServiceNotApplicableWarning(entityType, user, i, count)
        break
      except GData_serviceNotApplicable:
        entityUnknownWarning(entityType, user, i, count)
        break
    Indent.Decrement()

# gam <UserTypeEntity> delete contacts <ContactEntity>|([query <QueryContact>] [contactgroup <ContactGroupItem>] [emailmatchpattern <RegularExpression>] [updated_min <Date>])
def deleteUserContacts(users):
  _deleteContacts(users, Entity.USER)

# gam delete contacts <ContactEntity>|([query <QueryContact>] [emailmatchpattern <RegularExpression>] [updated_min <Date>])
def doDeleteDomainContacts():
  _deleteContacts([GC_Values[GC_DOMAIN],], Entity.DOMAIN)

def _showContact(contactsManager, fields, displayFieldsList, contactGroupIDs, j, jcount):
  printEntity([Entity.CONTACT, fields[CONTACT_ID]], j, jcount)
  Indent.Increment()
  for key in contactsManager.CONTACT_NAME_PROPERTY_PRINT_ORDER:
    if displayFieldsList and key not in displayFieldsList:
      continue
    if key in fields:
      if key == CONTACT_UPDATED:
        printKeyValueList([key, formatLocalTime(fields[key])])
      elif (key != CONTACT_NOTES) and (key != CONTACT_BILLING_INFORMATION):
        printKeyValueList([key, fields[key]])
      else:
        printKeyValueList([key, None])
        Indent.Increment()
        printKeyValueList([Indent.MultiLineText(fields[key])])
        Indent.Decrement()
  for key in contactsManager.CONTACT_ARRAY_PROPERTY_PRINT_ORDER:
    if displayFieldsList and key not in displayFieldsList:
      continue
    if key in fields:
      keymap = contactsManager.CONTACT_ARRAY_PROPERTIES[key]
      printKeyValueList([key, None])
      Indent.Increment()
      for item in fields[key]:
        fn = item.get(u'label')
        if keymap[u'relMap']:
          if not fn:
            fn = keymap[u'relMap'].get(item[u'rel'], u'custom')
          printKeyValueList([u'type', fn])
          Indent.Increment()
        if keymap[u'primary']:
          printKeyValueList([u'rank', [u'notprimary', u'primary'][item[u'primary'] == u'true']])
        value = item[u'value']
        if value is None:
          value = u''
        if key == CONTACT_IMS:
          printKeyValueList([u'protocol', contactsManager.IM_REL_TO_PROTOCOL_MAP.get(item[u'protocol'], item[u'protocol'])])
          printKeyValueList([keymap[u'infoTitle'], value])
        elif key == CONTACT_ADDRESSES:
          printKeyValueList([keymap[u'infoTitle'], None])
          Indent.Increment()
          printKeyValueList([Indent.MultiLineText(value)])
          Indent.Decrement()
          for org_key in contactsManager.ADDRESS_FIELD_PRINT_ORDER:
            if item[org_key]:
              printKeyValueList([contactsManager.ADDRESS_FIELD_TO_ARGUMENT_MAP[org_key], convertCRsNLs(item[org_key])])
        elif key == CONTACT_ORGANIZATIONS:
          printKeyValueList([keymap[u'infoTitle'], value])
          for org_key in contactsManager.ORGANIZATION_FIELD_PRINT_ORDER:
            if item[org_key]:
              printKeyValueList([contactsManager.ORGANIZATION_FIELD_TO_ARGUMENT_MAP[org_key], item[org_key]])
        elif key == CONTACT_USER_DEFINED_FIELDS:
          printKeyValueList([item.get(u'rel') or u'None', value])
        else:
          printKeyValueList([keymap[u'infoTitle'], value])
        if keymap[u'relMap']:
          Indent.Decrement()
      Indent.Decrement()
  if contactGroupIDs is not None and CONTACT_GROUPS in fields:
    printEntitiesCount(Entity.CONTACT_GROUP, None)
    Indent.Increment()
    for group in fields[CONTACT_GROUPS]:
      if group in contactGroupIDs:
        printKeyValueList([contactGroupIDs[group]])
        Indent.Increment()
        printKeyValueList([u'id', group])
        Indent.Decrement()
      else:
        printKeyValueList([u'id', group])
    Indent.Decrement()
  Indent.Decrement()

def _getContactFieldsList(contactsManager, displayFieldsList):
  fieldNameList = getString(OB_FIELD_NAME_LIST)
  for field in fieldNameList.lower().replace(u',', u' ').split():
    if field in contactsManager.CONTACT_ARGUMENT_TO_PROPERTY_MAP:
      displayFieldsList.append(contactsManager.CONTACT_ARGUMENT_TO_PROPERTY_MAP[field])
    else:
      CLArgs.Backup()
      invalidChoiceExit(contactsManager.CONTACT_ARGUMENT_TO_PROPERTY_MAP)

def _infoContacts(users, entityType, contactFeed=True):
  contactsManager = ContactsManager()
  entityList = getEntityList(OB_CONTACT_ENTITY)
  contactIdLists = entityList if isinstance(entityList, dict) else None
  contactQuery = _initContactQueryAttributes()
  showContactGroups = False
  displayFieldsList = []
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in CONTACTS_PROJECTION_CHOICES_MAP:
      contactQuery[u'projection'] = CONTACTS_PROJECTION_CHOICES_MAP[myarg]
    elif myarg == u'showgroups':
      showContactGroups = True
    elif myarg == u'fields':
      _getContactFieldsList(contactsManager, displayFieldsList)
      if CONTACT_GROUPS in displayFieldsList:
        showContactGroups = True
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    if contactIdLists:
      entityList = contactIdLists[user]
    user, contactsObject = getContactsObject(entityType, user, i, count, contactFeed=contactFeed)
    if not contactsObject:
      continue
    contactGroupIDs = None
    j = 0
    jcount = len(entityList)
    entityPerformActionNumItems([entityType, user], jcount, Entity.CONTACT, i, count)
    if jcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
      continue
    Indent.Increment()
    for contact in entityList:
      j += 1
      try:
        contactId = normalizeContactId(contact)
        contact = callGData(contactsObject, u'GetContact',
                            throw_errors=[GDATA_NOT_FOUND, GDATA_BAD_REQUEST, GDATA_SERVICE_NOT_APPLICABLE, GDATA_FORBIDDEN, GDATA_NOT_IMPLEMENTED],
                            retry_errors=[GDATA_INTERNAL_SERVER_ERROR],
                            uri=contactsObject.GetContactFeedUri(contact_list=user, contactId=contactId, projection=contactQuery[u'projection']))
        fields = contactsManager.ContactToFields(contact)
        if showContactGroups and CONTACT_GROUPS in fields and not contactGroupIDs:
          contactGroupIDs, _ = getContactGroupsInfo(contactsManager, contactsObject, entityType, user, i, count)
        _showContact(contactsManager, fields, displayFieldsList, [None, contactGroupIDs][showContactGroups], j, jcount)
      except (GData_notFound, GData_badRequest) as e:
        entityActionFailedWarning([entityType, user, Entity.CONTACT, contactId], e.message, j, jcount)
      except (GData_forbidden, GData_notImplemented):
        entityServiceNotApplicableWarning(entityType, user, i, count)
        break
      except GData_serviceNotApplicable:
        entityUnknownWarning(entityType, user, i, count)
        break
    Indent.Decrement()

# gam <UserTypeEntity> info contacts <ContactEntity> [basic|full] [showgroups] [fields <ContactFieldNameList>]
def infoUserContacts(users):
  _infoContacts(users, Entity.USER)

# gam info contacts <ContactEntity> [basic|full] [showgroups] [fields <ContactFieldNameList>]
def doInfoDomainContacts():
  _infoContacts([GC_Values[GC_DOMAIN],], Entity.DOMAIN)

# gam info gal <GalEntity> [basic|full] [fields <ContactFieldNameList>]
def doInfoGAL():
  _infoContacts([GC_Values[GC_DOMAIN],], Entity.DOMAIN, False)

def _printShowContacts(users, entityType, csvFormat, contactFeed=True):
  contactsManager = ContactsManager()
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile([Entity.Singular(entityType), CONTACT_ID, CONTACT_NAME])
  contactQuery = _initContactQueryAttributes()
  showContactGroups = False
  displayFieldsList = []
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif contactFeed and myarg == u'showgroups':
      showContactGroups = True
    elif myarg == u'fields':
      _getContactFieldsList(contactsManager, displayFieldsList)
      if contactFeed and CONTACT_GROUPS in displayFieldsList:
        showContactGroups = True
    else:
      _getContactQueryAttributes(contactQuery, myarg, entityType, True)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, contactsObject = getContactsObject(entityType, user, i, count, contactFeed=contactFeed)
    if not contactsObject:
      continue
    contactGroupIDs = contactGroupNames = None
    if contactQuery[u'contactGroup']:
      groupId, contactGroupIDs, contactGroupNames = validateContactGroup(contactsManager, contactsObject, contactQuery[u'contactGroup'], contactGroupIDs, contactGroupNames, entityType, user, i, count)
      if not groupId:
        if contactGroupNames:
          entityActionFailedWarning([entityType, user, Entity.CONTACT_GROUP, contactQuery[u'contactGroup']], PHRASE_DOES_NOT_EXIST, i, count)
        continue
      contactQuery[u'group'] = contactsObject.GetContactGroupFeedUri(contact_list=user, projection=u'base', groupId=groupId)
    contacts = queryContacts(contactsObject, contactQuery, entityType, user, i, count)
    jcount = len(contacts) if (contacts) else 0
    if not csvFormat:
      entityPerformActionModifierNumItems([entityType, user], PHRASE_MAXIMUM_OF, jcount, Entity.CONTACT, i, count)
    if jcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
      continue
    if not csvFormat:
      Indent.Increment()
      j = 0
      for contact in contacts:
        j += 1
        fields = contactsManager.ContactToFields(contact)
        if contactQuery[u'emailMatchPattern'] and not contactEmailAddressMatches(contactsManager, contactQuery, fields):
          continue
        if showContactGroups and CONTACT_GROUPS in fields and not contactGroupIDs:
          contactGroupIDs, _ = getContactGroupsInfo(contactsManager, contactsObject, entityType, user, i, count)
        _showContact(contactsManager, fields, displayFieldsList, [None, contactGroupIDs][showContactGroups], j, jcount)
      Indent.Decrement()
    else:
      for contact in contacts:
        fields = contactsManager.ContactToFields(contact)
        if contactQuery[u'emailMatchPattern'] and not contactEmailAddressMatches(contactsManager, contactQuery, fields):
          continue
        if showContactGroups and CONTACT_GROUPS in fields and not contactGroupIDs:
          contactGroupIDs, _ = getContactGroupsInfo(contactsManager, contactsObject, entityType, user, i, count)
        contactRow = {Entity.Singular(entityType): user, CONTACT_ID: fields[CONTACT_ID]}
        for key in contactsManager.CONTACT_NAME_PROPERTY_PRINT_ORDER:
          if displayFieldsList and key not in displayFieldsList:
            continue
          if key in fields:
            if key == CONTACT_UPDATED:
              contactRow[key] = formatLocalTime(fields[key])
            elif (key != CONTACT_NOTES) and (key != CONTACT_BILLING_INFORMATION):
              contactRow[key] = fields[key]
            else:
              contactRow[key] = convertCRsNLs(fields[key])
        for key in contactsManager.CONTACT_ARRAY_PROPERTY_PRINT_ORDER:
          if displayFieldsList and key not in displayFieldsList:
            continue
          if key in fields:
            keymap = contactsManager.CONTACT_ARRAY_PROPERTIES[key]
            contactRow[u'{0}.0.count'.format(key)] = len(fields[key])
            j = 0
            for item in fields[key]:
              j += 1
              fn = u'{0}.{1}.'.format(key, j)
              fnt = item.get(u'label')
              if fnt:
                contactRow[fn+u'type'] = fnt
              elif keymap[u'relMap']:
                contactRow[fn+u'type'] = keymap[u'relMap'].get(item[u'rel'], u'custom')
              if keymap[u'primary']:
                contactRow[fn+u'rank'] = [u'notprimary', u'primary'][item[u'primary'] == u'true']
              value = item[u'value']
              if value is None:
                value = u''
              if key == CONTACT_IMS:
                contactRow[fn+u'protocol'] = contactsManager.IM_REL_TO_PROTOCOL_MAP.get(item[u'protocol'], item[u'protocol'])
                contactRow[fn+keymap[u'infoTitle']] = value
              elif key == CONTACT_ADDRESSES:
                contactRow[fn+keymap[u'infoTitle']] = convertCRsNLs(value)
                for org_key in contactsManager.ADDRESS_FIELD_PRINT_ORDER:
                  if item[org_key]:
                    contactRow[fn+contactsManager.ADDRESS_FIELD_TO_ARGUMENT_MAP[org_key]] = convertCRsNLs(item[org_key])
              elif key == CONTACT_ORGANIZATIONS:
                contactRow[fn+keymap[u'infoTitle']] = value
                for org_key in contactsManager.ORGANIZATION_FIELD_PRINT_ORDER:
                  if item[org_key]:
                    contactRow[fn+contactsManager.ORGANIZATION_FIELD_TO_ARGUMENT_MAP[org_key]] = item[org_key]
              elif key == CONTACT_USER_DEFINED_FIELDS:
                contactRow[fn+u'type'] = item.get(u'rel') or u'None'
                contactRow[fn+keymap[u'infoTitle']] = value
              else:
                contactRow[fn+keymap[u'infoTitle']] = value
        if showContactGroups and CONTACT_GROUPS in fields:
          contactRow[u'{0}.0.Count'.format(CONTACT_GROUPS)] = len(fields[CONTACT_GROUPS])
          j = 0
          for group in fields[CONTACT_GROUPS]:
            j += 1
            fn = u'{0}.{1}.'.format(CONTACT_GROUPS, j)
            contactRow[fn+CONTACT_GROUP_ID] = u'id:{0}'.format(group)
            if group in contactGroupIDs:
              contactRow[fn+CONTACT_GROUP_NAME] = contactGroupIDs[group]
        addRowTitlesToCSVfile(contactRow, csvRows, titles)
  if csvFormat:
    sortCSVTitles([Entity.Singular(entityType), CONTACT_ID, CONTACT_NAME], titles)
    writeCSVfile(csvRows, titles, u'Contacts', todrive)

# gam <UserTypeEntity> print contacts [todrive [<ToDriveAttributes>]] [query <QueryContact>] [contactgroup <ContactGroupItem>] [emailmatchpattern <RegularExpression>] [updated_min <Date>]
#	[basic|full] [showgroups] [showdeleted] [orderby <ContactOrderByFieldName> [ascending|descending]] [fields <ContactFieldNameList>]
def printUserContacts(users):
  _printShowContacts(users, Entity.USER, True)

# gam <UserTypeEntity> show contacts [query <QueryContact>] [contactgroup <ContactGroupItem>] [emailmatchpattern <RegularExpression>] [updated_min <Date>]
#	[basic|full] [showgroups] [showdeleted] [orderby <ContactOrderByFieldName> [ascending|descending]] [fields <ContactFieldNameList>]
def showUserContacts(users):
  _printShowContacts(users, Entity.USER, False)

# gam print contacts [todrive [<ToDriveAttributes>]] [query <QueryContact>] [emailmatchpattern <RegularExpression>] [updated_min <Date>]
#	[basic|full] [showgroups] [showdeleted] [orderby <ContactOrderByFieldName> [ascending|descending]] [fields <ContactFieldNameList>]
def doPrintDomainContacts():
  _printShowContacts([GC_Values[GC_DOMAIN]], Entity.DOMAIN, True)

# gam show contacts [query <QueryContact>] [emailmatchpattern <RegularExpression>] [updated_min <Date>]
#	[basic|full] [showgroups] [showdeleted] [orderby <ContactOrderByFieldName> [ascending|descending]] [fields <ContactFieldNameList>]
def doShowDomainContacts():
  _printShowContacts([GC_Values[GC_DOMAIN]], Entity.DOMAIN, False)

# gam print [todrive [<ToDriveAttributes>]] [query <QueryContact>] [emailmatchpattern <RegularExpression>] [updated_min <Date>]
#	[basic|full] [showdeleted] [orderby <ContactOrderByFieldName> [ascending|descending]] [fields <ContactFieldNameList>]
def doPrintGAL():
  _printShowContacts([GC_Values[GC_DOMAIN]], Entity.DOMAIN, True, False)

# gam show gal [query <QueryContact>] [emailmatchpattern <RegularExpression>] [updated_min <Date>]
#	[basic|full] [showdeleted] [orderby <ContactOrderByFieldName> [ascending|descending]] [fields <ContactFieldNameList>]
def doShowGAL():
  _printShowContacts([GC_Values[GC_DOMAIN]], Entity.DOMAIN, False, False)

# gam <UserTypeEntity> create contactgroup <ContactGroupAttributes>+
def createUserContactGroup(users):
  contactsManager = ContactsManager()
  entityType = Entity.USER
  fields = contactsManager.GetContactGroupFields()
  contactGroup = contactsManager.FieldsToContactGroup(fields)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, contactsObject = getContactsObject(entityType, user, i, count)
    if not contactsObject:
      continue
    _, contactGroupNames = getContactGroupsInfo(contactsManager, contactsObject, entityType, user, i, count)
    if contactGroupNames is False:
      continue
    if fields[CONTACT_GROUP_NAME] in contactGroupNames:
      entityActionFailedWarning([entityType, user], entityTypeNameMessage(Entity.CONTACT_GROUP_NAME, fields[CONTACT_GROUP_NAME], PHRASE_DUPLICATE), i, count)
      continue
    try:
      group = callGData(contactsObject, u'CreateGroup',
                        throw_errors=[GDATA_BAD_REQUEST, GDATA_SERVICE_NOT_APPLICABLE, GDATA_FORBIDDEN],
                        retry_errors=[GDATA_INTERNAL_SERVER_ERROR],
                        new_group=contactGroup, insert_uri=contactsObject.GetContactGroupFeedUri(contact_list=user))
      entityActionPerformed([entityType, user, Entity.CONTACT_GROUP, contactsManager.GetContactShortId(group)], i, count)
    except GData_badRequest as e:
      entityActionFailedWarning([entityType, user, Entity.CONTACT_GROUP, u''], e.message, i, count)
    except GData_forbidden:
      entityServiceNotApplicableWarning(entityType, user, i, count)
    except GData_serviceNotApplicable:
      entityUnknownWarning(entityType, user, i, count)

# gam <UserTypeEntity> update contactgroups <ContactGroupItem> <ContactAttributes>+
def updateUserContactGroup(users):
  contactsManager = ContactsManager()
  entityType = Entity.USER
  entityList = getStringReturnInList(OB_CONTACT_GROUP_ITEM)
  update_fields = contactsManager.GetContactGroupFields()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, contactsObject = getContactsObject(entityType, user, i, count)
    if not contactsObject:
      continue
    contactGroupIDs = contactGroupNames = None
    j = 0
    jcount = len(entityList)
    entityPerformActionNumItems([entityType, user], jcount, Entity.CONTACT_GROUP, i, count)
    if jcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
      continue
    Indent.Increment()
    for contactGroup in entityList:
      j += 1
      groupId, contactGroupIDs, contactGroupNames = validateContactGroup(contactsManager, contactsObject, contactGroup, contactGroupIDs, contactGroupNames, entityType, user, i, count)
      if not groupId:
        if contactGroupNames:
          entityActionFailedWarning([entityType, user, Entity.CONTACT_GROUP, contactGroup], PHRASE_DOES_NOT_EXIST, j, jcount)
          continue
        break
      if update_fields[CONTACT_GROUP_NAME] in contactGroupNames and groupId not in contactGroupNames[update_fields[CONTACT_GROUP_NAME]]:
        entityActionFailedWarning([entityType, user, Entity.CONTACT_GROUP, contactGroup], entityTypeNameMessage(Entity.CONTACT_GROUP_NAME, update_fields[CONTACT_GROUP_NAME], PHRASE_DUPLICATE), i, count)
        continue
      contactGroup = contactGroupIDs.get(groupId, contactGroup)
      try:
        group = callGData(contactsObject, u'GetGroup',
                          throw_errors=[GDATA_NOT_FOUND, GDATA_BAD_REQUEST, GDATA_SERVICE_NOT_APPLICABLE, GDATA_FORBIDDEN],
                          retry_errors=[GDATA_INTERNAL_SERVER_ERROR],
                          uri=contactsObject.GetContactGroupFeedUri(contact_list=user, groupId=groupId))
        fields = contactsManager.ContactGroupToFields(group)
        for field in update_fields:
          fields[field] = update_fields[field]
        groupEntry = contactsManager.FieldsToContactGroup(fields)
        groupEntry.category = group.category
        groupEntry.link = group.link
        groupEntry.etag = group.etag
        groupEntry.id = group.id
        callGData(contactsObject, u'UpdateGroup',
                  throw_errors=[GDATA_NOT_FOUND, GDATA_BAD_REQUEST, GDATA_SERVICE_NOT_APPLICABLE, GDATA_FORBIDDEN],
                  edit_uri=contactsObject.GetContactGroupFeedUri(contact_list=user, groupId=groupId), updated_group=groupEntry, extra_headers={u'If-Match': group.etag})
        entityActionPerformed([entityType, user, Entity.CONTACT_GROUP, contactGroup], j, jcount)
      except (GData_notFound, GData_badRequest) as e:
        entityActionFailedWarning([entityType, user, Entity.CONTACT_GROUP, contactGroup], e.message, j, jcount)
      except GData_forbidden:
        entityServiceNotApplicableWarning(entityType, user, i, count)
        break
      except GData_serviceNotApplicable:
        entityUnknownWarning(entityType, user, i, count)
        break
    Indent.Decrement()

# gam <UserTypeEntity> delete contactgroups <ContactGroupEntity>
def deleteUserContactGroups(users):
  contactsManager = ContactsManager()
  entityType = Entity.USER
  entityList = getEntityList(OB_CONTACT_GROUP_ENTITY, shlexSplit=True)
  contactGroupIdLists = entityList if isinstance(entityList, dict) else None
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    if contactGroupIdLists:
      entityList = contactGroupIdLists[user]
    user, contactsObject = getContactsObject(entityType, user, i, count)
    if not contactsObject:
      continue
    contactGroupIDs = contactGroupNames = None
    j = 0
    jcount = len(entityList)
    entityPerformActionNumItems([entityType, user], jcount, Entity.CONTACT_GROUP, i, count)
    if jcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
      continue
    Indent.Increment()
    for contactGroup in entityList:
      j += 1
      try:
        groupId, contactGroupIDs, contactGroupNames = validateContactGroup(contactsManager, contactsObject, contactGroup, contactGroupIDs, contactGroupNames, entityType, user, i, count)
        if not groupId:
          if contactGroupNames:
            entityActionFailedWarning([entityType, user, Entity.CONTACT_GROUP, contactGroup], PHRASE_DOES_NOT_EXIST, j, jcount)
            continue
          break
        contactGroup = contactGroupIDs.get(groupId, contactGroup)
        group = callGData(contactsObject, u'GetGroup',
                          throw_errors=[GDATA_NOT_FOUND, GDATA_SERVICE_NOT_APPLICABLE, GDATA_FORBIDDEN],
                          retry_errors=[GDATA_INTERNAL_SERVER_ERROR],
                          uri=contactsObject.GetContactGroupFeedUri(contact_list=user, groupId=groupId))
        callGData(contactsObject, u'DeleteGroup',
                  throw_errors=[GDATA_NOT_FOUND, GDATA_SERVICE_NOT_APPLICABLE, GDATA_FORBIDDEN],
                  edit_uri=contactsObject.GetContactGroupFeedUri(contact_list=user, groupId=groupId), extra_headers={u'If-Match': group.etag})
        entityActionPerformed([entityType, user, Entity.CONTACT_GROUP, contactGroup], j, jcount)
      except GData_notFound as e:
        entityActionFailedWarning([entityType, user, Entity.CONTACT_GROUP, contactGroup], e.message, j, jcount)
      except GData_forbidden:
        entityServiceNotApplicableWarning(entityType, user, i, count)
        break
      except GData_serviceNotApplicable:
        entityUnknownWarning(entityType, user, i, count)
        break
    Indent.Decrement()

def _showContactGroup(contactsManager, group, j, jcount):
  fields = contactsManager.ContactGroupToFields(group)
  printEntity([Entity.CONTACT_GROUP, fields[CONTACT_GROUP_NAME]], j, jcount)
  Indent.Increment()
  printKeyValueList([u'updated', formatLocalTime(fields[CONTACT_GROUP_UPDATED])])
  printKeyValueList([u'id', fields[CONTACT_GROUP_ID]])
  Indent.Decrement()

# gam <UserTypeEntity> info contactgroups <ContactGroupEntity>
def infoUserContactGroups(users):
  contactsManager = ContactsManager()
  entityType = Entity.USER
  entityList = getEntityList(OB_CONTACT_GROUP_ENTITY, shlexSplit=True)
  contactGroupIdLists = entityList if isinstance(entityList, dict) else None
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    if contactGroupIdLists:
      entityList = contactGroupIdLists[user]
    user, contactsObject = getContactsObject(entityType, user, i, count)
    if not contactsObject:
      continue
    contactGroupIDs = contactGroupNames = None
    j = 0
    jcount = len(entityList)
    entityPerformActionNumItems([entityType, user], jcount, Entity.CONTACT_GROUP, i, count)
    if jcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
      continue
    Indent.Increment()
    for contactGroup in entityList:
      j += 1
      try:
        groupId, contactGroupIDs, contactGroupNames = validateContactGroup(contactsManager, contactsObject, contactGroup, contactGroupIDs, contactGroupNames, entityType, user, i, count)
        if not groupId:
          if contactGroupNames:
            entityActionFailedWarning([entityType, user, Entity.CONTACT_GROUP, contactGroup], PHRASE_DOES_NOT_EXIST, j, jcount)
            continue
          break
        contactGroup = contactGroupIDs.get(groupId, contactGroup)
        group = callGData(contactsObject, u'GetGroup',
                          throw_errors=[GDATA_NOT_FOUND, GDATA_SERVICE_NOT_APPLICABLE, GDATA_FORBIDDEN],
                          retry_errors=[GDATA_INTERNAL_SERVER_ERROR],
                          uri=contactsObject.GetContactGroupFeedUri(contact_list=user, groupId=groupId))
        _showContactGroup(contactsManager, group, j, jcount)
      except GData_notFound as e:
        entityActionFailedWarning([entityType, user, Entity.CONTACT_GROUP, contactGroup], e.message, j, jcount)
      except GData_forbidden:
        entityServiceNotApplicableWarning(entityType, user, i, count)
        break
      except GData_serviceNotApplicable:
        entityUnknownWarning(entityType, user, i, count)
        break
    Indent.Decrement()

def _printShowContactGroups(users, csvFormat):
  entityType = Entity.USER
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile([Entity.Singular(entityType), CONTACT_GROUP_ID, CONTACT_GROUP_NAME])
  projection = u'full'
  url_params = {u'max-results': str(GC_Values[GC_CONTACT_MAX_RESULTS])}
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'orderby':
      url_params[u'orderby'] = getChoice(CONTACTS_ORDERBY_CHOICES_MAP, mapChoice=True)
      url_params[u'sortorder'] = getChoice(SORTORDER_CHOICES_MAP, defaultChoice=u'ascending')
    elif myarg in CONTACTS_PROJECTION_CHOICES_MAP:
      projection = CONTACTS_PROJECTION_CHOICES_MAP[myarg]
    elif myarg == u'showdeleted':
      url_params[u'showdeleted'] = u'true'
    elif myarg == u'updatedmin':
      url_params[u'updated-min'] = getYYYYMMDD()
    else:
      unknownArgumentExit()
  contactsManager = ContactsManager()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, contactsObject = getContactsObject(entityType, user, i, count)
    if not contactsObject:
      continue
    printGettingAllEntityItemsForWhom(Entity.CONTACT_GROUP, user, i, count)
    uri = contactsObject.GetContactGroupFeedUri(contact_list=user, projection=projection)
    try:
      page_message = getPageMessage()
      groups = callGDataPages(contactsObject, u'GetGroupsFeed',
                              page_message=page_message,
                              throw_errors=[GDATA_SERVICE_NOT_APPLICABLE, GDATA_FORBIDDEN],
                              retry_errors=[GDATA_INTERNAL_SERVER_ERROR],
                              uri=uri, url_params=url_params)
      jcount = len(groups)
      if not csvFormat:
        entityPerformActionNumItems([Entity.USER, user], jcount, Entity.CONTACT_GROUP, i, count)
      if jcount == 0:
        setSysExitRC(NO_ENTITIES_FOUND)
        continue
      if not csvFormat:
        Indent.Increment()
        j = 0
        for group in groups:
          j += 1
          _showContactGroup(contactsManager, group, j, jcount)
        Indent.Decrement()
      else:
        for group in groups:
          fields = contactsManager.ContactGroupToFields(group)
          groupRow = {Entity.Singular(entityType): user, CONTACT_GROUP_ID: u'id:{0}'.format(fields[CONTACT_GROUP_ID]),
                      CONTACT_GROUP_NAME: fields[CONTACT_GROUP_NAME], CONTACT_GROUP_UPDATED: formatLocalTime(fields[CONTACT_GROUP_UPDATED])}
          addRowTitlesToCSVfile(groupRow, csvRows, titles)
    except GData_forbidden:
      entityServiceNotApplicableWarning(entityType, user, i, count)
    except GData_serviceNotApplicable:
      entityUnknownWarning(entityType, user, i, count)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Contact Groups', todrive)

# gam <UserTypeEntity> print contactgroups [todrive [<ToDriveAttributes>]] [updated_min <Date>]
#	[basic|full] [showdeleted] [orderby <ContactOrderByFieldName> [ascending|descending]]
def printUserContactGroups(users):
  _printShowContactGroups(users, True)

# gam <UserTypeEntity> show contactgroups [updated_min <Date>]
#	[basic|full] [showdeleted] [orderby <ContactOrderByFieldName> [ascending|descending]]
def showUserContactGroups(users):
  _printShowContactGroups(users, False)

# CrOS commands utilities
def getCrOSDeviceEntity():
  cd = buildGAPIObject(DIRECTORY_API)
  if checkArgumentPresent(QUERY_ARGUMENT):
    query = getString(OB_QUERY)
  else:
    deviceId = getString(OB_CROS_DEVICE_ENTITY)
    if deviceId[:6].lower() == u'query:':
      query = deviceId[6:]
    else:
      CLArgs.Backup()
      query = None
  if not query:
    return (getEntityList(OB_CROS_ENTITY), cd)
  try:
    devices = callGAPIpages(cd.chromeosdevices(), u'list', u'chromeosdevices',
                            throw_reasons=[GAPI_INVALID_INPUT, GAPI_BAD_REQUEST, GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN],
                            customerId=GC_Values[GC_CUSTOMER_ID], query=query,
                            fields=u'nextPageToken,chromeosdevices(deviceId)')
    return ([cros[u'deviceId'] for cros in devices], cd)
  except GAPI_invalidInput:
    CLArgs.Backup()
    usageErrorExit(PHRASE_INVALID_QUERY)
  except (GAPI_badRequest, GAPI_resourceNotFound, GAPI_forbidden):
    accessErrorExit(cd)

UPDATE_CROS_ARGUMENT_TO_PROPERTY_MAP = {
  u'annotatedassetid': u'annotatedAssetId',
  u'annotatedlocation': u'annotatedLocation',
  u'annotateduser': u'annotatedUser',
  u'asset': u'annotatedAssetId',
  u'assetid': u'annotatedAssetId',
  u'location': u'annotatedLocation',
  u'notes': u'notes',
  u'org': u'orgUnitPath',
  u'orgunitpath': u'orgUnitPath',
  u'ou': u'orgUnitPath',
  u'tag': u'annotatedAssetId',
  u'user': u'annotatedUser',
  }

CROS_ACTION_CHOICES_MAP = {
  u'deprovisionsamemodelreplace': (u'deprovision', u'same_model_replacement'),
  u'deprovisionsamemodelreplacement': (u'deprovision', u'same_model_replacement'),
  u'deprovisiondifferentmodelreplace': (u'deprovision', u'different_model_replacement'),
  u'deprovisiondifferentmodelreplacement': (u'deprovision', u'different_model_replacement'),
  u'deprovisionretiringdevice': (u'deprovision', u'retiring_device'),
  u'disable': (u'disable', None),
  u'reenable': (u'reenable', None)
  }

CROS_ACTION_NAME_MAP = {
  u'deprovision': Action.DEPROVISION,
  u'disable': Action.DISABLE,
  u'reenable': Action.REENABLE,
  }

# gam <CrOSTypeEntity> update <CrOSAttributes>
def updateCrOSDevices(entityList, cd=None):
  if not cd:
    cd = buildGAPIObject(DIRECTORY_API)
  update_body = {}
  action_body = {}
  ack_wipe = False
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in UPDATE_CROS_ARGUMENT_TO_PROPERTY_MAP:
      up = UPDATE_CROS_ARGUMENT_TO_PROPERTY_MAP[myarg]
      if up == u'orgUnitPath':
        update_body[up] = getOrgUnitItem(pathOnly=True)
      elif up == u'notes':
        update_body[up] = getString(OB_STRING, minLen=0).replace(u'\\n', u'\n')
      else:
        update_body[up] = getString(OB_STRING, minLen=[0, 1][up == u'annotatedAssetId'])
    elif myarg == u'action':
      action_body[u'action'], deprovisionReason = getChoice(CROS_ACTION_CHOICES_MAP, mapChoice=True)
      if deprovisionReason:
        action_body[u'deprovisionReason'] = deprovisionReason
      Action.Set(CROS_ACTION_NAME_MAP[action_body[u'action']])
    elif myarg == u'acknowledgedevicetouchrequirement':
      ack_wipe = True
    else:
      unknownArgumentExit()
  i, count, entityList = getEntityArgument(entityList)
  if action_body:
    if action_body[u'action'] == u'deprovision' and not ack_wipe:
      stderrWarningMsg(MESSAGE_REFUSING_TO_DEPROVISION_DEVICES.format(count))
      systemErrorExit(AC_NOT_PERFORMED_RC, None)
    function = u'action'
    parmId = u'resourceId'
    kwargs = {parmId: None, u'body': action_body}
  elif update_body:
    function = u'patch'
    parmId = u'deviceId'
    kwargs = {parmId: None, u'body': update_body, u'fields': u''}
  else:
    return
  for deviceId in entityList:
    i += 1
    kwargs[parmId] = deviceId
    try:
      callGAPI(cd.chromeosdevices(), function,
               throw_reasons=[GAPI_INVALID, GAPI_INVALID_ORGUNIT, GAPI_BAD_REQUEST, GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN],
               customerId=GC_Values[GC_CUSTOMER_ID], **kwargs)
      entityActionPerformed([Entity.CROS_DEVICE, deviceId], i, count)
    except GAPI_invalid as e:
      entityActionFailedWarning([Entity.CROS_DEVICE, deviceId], e.message, i, count)
    except GAPI_invalidOrgunit:
      entityActionFailedWarning([Entity.CROS_DEVICE, deviceId], PHRASE_INVALID_ORGUNIT, i, count)
    except (GAPI_badRequest, GAPI_resourceNotFound, GAPI_forbidden):
      checkEntityAFDNEorAccessErrorExit(cd, Entity.CROS_DEVICE, deviceId, i, count)

# gam update cros|croses <CrOSEntity> <CrOSAttributes>
def doUpdateCrOSDevices():
  updateCrOSDevices(*getCrOSDeviceEntity())

CROS_ARGUMENT_TO_PROPERTY_MAP = {
  u'activetimeranges': [u'activeTimeRanges.activeTime', u'activeTimeRanges.date'],
  u'annotatedassetid': [u'annotatedAssetId',],
  u'annotatedlocation': [u'annotatedLocation',],
  u'annotateduser': [u'annotatedUser',],
  u'asset': [u'annotatedAssetId',],
  u'assetid': [u'annotatedAssetId',],
  u'bootmode': [u'bootMode',],
  u'deviceid': [u'deviceId',],
  u'ethernetmacaddress': [u'ethernetMacAddress',],
  u'firmwareversion': [u'firmwareVersion',],
  u'lastenrollmenttime': [u'lastEnrollmentTime',],
  u'lastsync': [u'lastSync',],
  u'location': [u'annotatedLocation',],
  u'macaddress': [u'macAddress',],
  u'meid': [u'meid',],
  u'model': [u'model',],
  u'notes': [u'notes',],
  u'ordernumber': [u'orderNumber',],
  u'org': [u'orgUnitPath',],
  u'orgunitpath': [u'orgUnitPath',],
  u'osversion': [u'osVersion',],
  u'ou': [u'orgUnitPath',],
  u'platformversion': [u'platformVersion',],
  u'recentusers': [u'recentUsers.email', u'recentUsers.type'],
  u'serialnumber': [u'serialNumber',],
  u'status': [u'status',],
  u'supportenddate': [u'supportEndDate',],
  u'tag': [u'annotatedAssetId',],
  u'timeranges': [u'activeTimeRanges.activeTime', u'activeTimeRanges.date'],
  u'user': [u'annotatedUser',],
  u'willautorenew': [u'willAutoRenew',],
  }

CROS_BASIC_FIELDS_LIST = [u'deviceId', u'annotatedAssetId', u'annotatedLocation', u'annotatedUser', u'lastSync', u'notes', u'serialNumber', u'status']

CROS_SCALAR_PROPERTY_PRINT_ORDER = [
  u'orgUnitPath',
  u'annotatedAssetId',
  u'annotatedLocation',
  u'annotatedUser',
  u'lastSync',
  u'notes',
  u'serialNumber',
  u'status',
  u'model',
  u'firmwareVersion',
  u'platformVersion',
  u'osVersion',
  u'bootMode',
  u'meid',
  u'ethernetMacAddress',
  u'macAddress',
  u'lastEnrollmentTime',
  u'orderNumber',
  u'supportEndDate',
  u'willAutoRenew',
  ]

CROS_TIME_OBJECTS = [u'lastSync', u'lastEnrollmentTime', u'supportEndDate']

# gam <CrOSTypeEntity> info [nolists] [listlimit <Number>]
#	[basic|full|allfields] <CrOSFieldName>* [fields <CrOSFieldNameList>]
def infoCrOSDevices(entityList, cd=None):
  if not cd:
    cd = buildGAPIObject(DIRECTORY_API)
  projection = None
  fieldsList = []
  noLists = False
  listLimit = 0
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'nolists':
      noLists = True
    elif myarg == u'listlimit':
      listLimit = getInteger(minVal=0)
    elif myarg == u'allfields':
      projection = u'FULL'
      fieldsList = []
    elif myarg in PROJECTION_CHOICES_MAP:
      projection = PROJECTION_CHOICES_MAP[myarg]
      if projection == u'FULL':
        fieldsList = []
      else:
        fieldsList = CROS_BASIC_FIELDS_LIST[:]
    elif myarg in CROS_ARGUMENT_TO_PROPERTY_MAP:
      if not fieldsList:
        fieldsList = [u'deviceId',]
      fieldsList.extend(CROS_ARGUMENT_TO_PROPERTY_MAP[myarg])
    elif myarg == u'fields':
      if not fieldsList:
        fieldsList = [u'deviceId',]
      fieldNameList = getString(OB_FIELD_NAME_LIST)
      for field in fieldNameList.lower().replace(u',', u' ').split():
        if field in CROS_ARGUMENT_TO_PROPERTY_MAP:
          fieldsList.extend(CROS_ARGUMENT_TO_PROPERTY_MAP[field])
          if field in [u'recentusers', u'timeranges', u'activetimeranges']:
            projection = u'FULL'
            noLists = False
        else:
          CLArgs.Backup()
          invalidChoiceExit(CROS_ARGUMENT_TO_PROPERTY_MAP)
    else:
      unknownArgumentExit()
  fields = u','.join(set(fieldsList)).replace(u'.', u'/') if fieldsList else None
  i, count, entityList = getEntityArgument(entityList)
  for deviceId in entityList:
    i += 1
    try:
      cros = callGAPI(cd.chromeosdevices(), u'get',
                      throw_reasons=[GAPI_BAD_REQUEST, GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN],
                      customerId=GC_Values[GC_CUSTOMER_ID], deviceId=deviceId, projection=projection, fields=fields)
      printEntity([Entity.CROS_DEVICE, deviceId], i, count)
      Indent.Increment()
      if u'notes' in cros:
        cros[u'notes'] = convertCRsNLs(cros[u'notes'])
      for up in CROS_SCALAR_PROPERTY_PRINT_ORDER:
        if up in cros:
          if up not in CROS_TIME_OBJECTS:
            printKeyValueList([up, cros[up]])
          else:
            printKeyValueList([up, formatLocalTime(cros[up])])
      if not noLists:
        activeTimeRanges = cros.get(u'activeTimeRanges', [])
        lenATR = len(activeTimeRanges)
        if lenATR:
          printKeyValueList([u'activeTimeRanges'])
          Indent.Increment()
          for i in xrange(min(lenATR, listLimit or lenATR)):
            printKeyValueList([u'date', activeTimeRanges[i][u'date']])
            Indent.Increment()
            printKeyValueList([u'activeTime', str(activeTimeRanges[i][u'activeTime'])])
            printKeyValueList([u'duration', formatMilliSeconds(activeTimeRanges[i][u'activeTime'])])
            Indent.Decrement()
          Indent.Decrement()
        recentUsers = cros.get(u'recentUsers', [])
        lenRU = len(recentUsers)
        if lenRU:
          printKeyValueList([u'recentUsers'])
          Indent.Increment()
          for i in xrange(min(lenRU, listLimit or lenRU)):
            printKeyValueList([u'type', recentUsers[i][u'type']])
            Indent.Increment()
            printKeyValueList([u'email', recentUsers[i].get(u'email', u'')])
            Indent.Decrement()
          Indent.Decrement()
      Indent.Decrement()
    except (GAPI_badRequest, GAPI_resourceNotFound, GAPI_forbidden):
      checkEntityAFDNEorAccessErrorExit(cd, Entity.CROS_DEVICE, deviceId, i, count)

# gam info cros|croses <CrOSEntity> [nolists] [listlimit <Number>]
#	[basic|full|allfields] <CrOSFieldName>* [fields <CrOSFieldNameList>]
def doInfoCrOSDevices():
  infoCrOSDevices(*getCrOSDeviceEntity())

CROS_ORDERBY_CHOICES_MAP = {
  u'lastsync': u'lastSync',
  u'location': u'annotatedLocation',
  u'notes': u'notes',
  u'serialnumber': u'serialNumber',
  u'status': u'status',
  u'supportenddate': u'supportEndDate',
  u'user': u'annotatedUser',
  }

# gam <CrOSTypeEntity> print
def doPrintCrOSEntity(entityList):
  getChoice([CL_OB_CROS, CL_OB_CROSES], defaultChoice=None)
  if not CLArgs.ArgumentsRemaining():
    _, _, entityList = getEntityArgument(entityList)
    for entity in entityList:
      printLine(entity)
    return
  doPrintCrOSDevices(entityList)

# gam [<CrOSTypeEntity>] print cros [todrive [<ToDriveAttributes>]] [query <QueryCrOS>]|[select <CrOSTypeEntity>]
#	[orderby <CrOSOrderByFieldName> [ascending|descending]] [nolists|recentusers|timeranges] [listlimit <Number>]
#	[basic|full|allfields] <CrOSFieldName>* [fields <CrOSFieldNameList>]
def doPrintCrOSDevices(entityList=None):
  def _printCrOS(cros):
    if u'notes' in cros:
      cros[u'notes'] = convertCRsNLs(cros[u'notes'])
    if (not noLists) and (not selectActiveTimeRanges) and (not selectRecentUsers):
      addRowTitlesToCSVfile(flattenJSON(cros, listLimit=listLimit, time_objects=CROS_TIME_OBJECTS), csvRows, titles)
      return
    row = {}
    for attrib in cros:
      if attrib in [u'kind', u'etag', u'recentUsers', u'activeTimeRanges']:
        continue
      if attrib not in titles[u'set']:
        addTitleToCSVfile(attrib, titles)
      if attrib not in CROS_TIME_OBJECTS:
        row[attrib] = cros[attrib]
      else:
        row[attrib] = formatLocalTime(cros[attrib])
    activeTimeRanges = cros.get(selectActiveTimeRanges, []) if selectActiveTimeRanges else []
    recentUsers = cros.get(selectRecentUsers, []) if selectRecentUsers else []
    if noLists or (not activeTimeRanges and not recentUsers):
      csvRows.append(row)
      return
    lenATR = len(activeTimeRanges)
    lenRU = len(recentUsers)
    for i in xrange(min(max(lenATR, lenRU), listLimit or max(lenATR, lenRU))):
      new_row = row.copy()
      if i < lenATR:
        new_row[u'activeTimeRanges.activeTime'] = str(activeTimeRanges[i][u'activeTime'])
        new_row[u'activeTimeRanges.duration'] = formatMilliSeconds(activeTimeRanges[i][u'activeTime'])
        new_row[u'activeTimeRanges.date'] = activeTimeRanges[i][u'date']
      if i < lenRU:
        new_row[u'recentUsers.email'] = recentUsers[i].get(u'email', u'')
        new_row[u'recentUsers.type'] = recentUsers[i][u'type']
      csvRows.append(new_row)

  def _callbackPrintCrOS(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      _printCrOS(response)
    else:
      http_status, reason, message = checkGAPIError(exception)
      if reason in [GAPI_BAD_REQUEST, GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN]:
        checkEntityAFDNEorAccessErrorExit(cd, Entity.CROS_DEVICE, ri[RI_ITEM], int(ri[RI_J]), int(ri[RI_JCOUNT]))
      else:
        errMsg = getHTTPError({}, http_status, reason, message)
        entityActionFailedWarning([Entity.CROS_DEVICE, ri[RI_ITEM]], errMsg, int(ri[RI_J]), int(ri[RI_JCOUNT]))

  cd = buildGAPIObject(DIRECTORY_API)
  todrive = {}
  fieldsList = []
  fieldsTitles = {}
  titles, csvRows = initializeTitlesCSVfile(None)
  addFieldToCSVfile(u'deviceid', CROS_ARGUMENT_TO_PROPERTY_MAP, fieldsList, fieldsTitles, titles)
  sortHeaders = False
  query = projection = orderBy = sortOrder = None
  noLists = False
  listLimit = 0
  selectActiveTimeRanges = selectRecentUsers = None
  select = selectLookup = False
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'query':
      query = getString(OB_QUERY)
    elif myarg == u'select':
      _, entityList = getEntityToModify(defaultEntityType=CL_ENTITY_CROS, crosAllowed=True, userAllowed=False)
      select = True
    elif myarg == u'nolists':
      noLists = True
      selectActiveTimeRanges = selectRecentUsers = None
    elif myarg == u'listlimit':
      listLimit = getInteger(minVal=0)
    elif myarg == u'recentusers':
      projection = u'FULL'
      selectRecentUsers = u'recentUsers'
      addFieldToCSVfile(myarg, CROS_ARGUMENT_TO_PROPERTY_MAP, fieldsList, fieldsTitles, titles)
      noLists = False
    elif myarg in [u'timeranges', u'activetimeranges']:
      projection = u'FULL'
      selectActiveTimeRanges = u'activeTimeRanges'
      addFieldToCSVfile(myarg, CROS_ARGUMENT_TO_PROPERTY_MAP, fieldsList, fieldsTitles, titles)
      addTitlesToCSVfile([u'activeTimeRanges.duration'], titles)
      noLists = False
    elif myarg == u'orderby':
      orderBy = getChoice(CROS_ORDERBY_CHOICES_MAP, mapChoice=True)
      sortOrder = getChoice(SORTORDER_CHOICES_MAP, defaultChoice=u'ascending', mapChoice=True)
    elif myarg in PROJECTION_CHOICES_MAP:
      projection = PROJECTION_CHOICES_MAP[myarg]
      sortHeaders = True
      if projection == u'FULL':
        fieldsList = []
      else:
        fieldsList = CROS_BASIC_FIELDS_LIST[:]
    elif myarg == u'allfields':
      projection = u'FULL'
      sortHeaders = True
      fieldsList = []
    elif myarg in CROS_ARGUMENT_TO_PROPERTY_MAP:
      if not fieldsList:
        fieldsList = [u'deviceId',]
      addFieldToCSVfile(myarg, CROS_ARGUMENT_TO_PROPERTY_MAP, fieldsList, fieldsTitles, titles)
    elif myarg == u'fields':
      if not fieldsList:
        fieldsList = [u'deviceId',]
      fieldNameList = getString(OB_FIELD_NAME_LIST)
      for field in fieldNameList.lower().replace(u',', u' ').split():
        if field in CROS_ARGUMENT_TO_PROPERTY_MAP:
          addFieldToCSVfile(field, CROS_ARGUMENT_TO_PROPERTY_MAP, fieldsList, fieldsTitles, titles)
          if field == u'recentusers':
            projection = u'FULL'
            selectRecentUsers = u'recentUsers'
            noLists = False
          elif field in [u'timeranges', u'activetimeranges']:
            projection = u'FULL'
            selectActiveTimeRanges = u'activeTimeRanges'
            noLists = False
        else:
          CLArgs.Backup()
          invalidChoiceExit(CROS_ARGUMENT_TO_PROPERTY_MAP)
    else:
      unknownArgumentExit()
  _, _, entityList = getEntityArgument(entityList)
  if entityList is None:
    fields = u'nextPageToken,chromeosdevices({0})'.format(u','.join(fieldsList)).replace(u'.', u'/') if fieldsList else None
    printGettingAccountEntitiesInfo(Entity.CROS_DEVICE, qualifier=queryQualifier(query))
    page_message = getPageMessage()
    try:
      feed = callGAPIpages(cd.chromeosdevices(), u'list', u'chromeosdevices',
                           page_message=page_message,
                           throw_reasons=[GAPI_INVALID_INPUT, GAPI_BAD_REQUEST, GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN],
                           customerId=GC_Values[GC_CUSTOMER_ID], query=query, projection=projection,
                           orderBy=orderBy, sortOrder=sortOrder, fields=fields, maxResults=GC_Values[GC_DEVICE_MAX_RESULTS])
      while feed:
        _printCrOS(feed.popleft())
    except GAPI_invalidInput:
      entityActionFailedWarning([Entity.CROS_DEVICE, PHRASE_LIST], invalidQuery(query))
      return
    except (GAPI_badRequest, GAPI_resourceNotFound, GAPI_forbidden):
      accessErrorExit(cd)
  else:
    if fieldsList:
      fields = u','.join(set(fieldsList)).replace(u'.', u'/')
      selectLookup = len(fieldsList) > 1
    else:
      fields = None
      selectLookup = True
    if selectLookup:
      jcount = len(entityList)
      svcargs = dict([(u'customerId', GC_Values[GC_CUSTOMER_ID]), (u'deviceId', None), (u'projection', projection), (u'fields', fields)]+GM_Globals[GM_EXTRA_ARGS_LIST])
      dbatch = googleapiclient.http.BatchHttpRequest(callback=_callbackPrintCrOS)
      bcount = 0
      j = 0
      for deviceId in entityList:
        j += 1
        svcparms = svcargs.copy()
        svcparms[u'deviceId'] = deviceId
        dbatch.add(cd.chromeosdevices().get(**svcparms), request_id=batchRequestID(u'', 0, 0, j, jcount, deviceId))
        bcount += 1
        if bcount >= GC_Values[GC_BATCH_SIZE]:
          dbatch.execute()
          dbatch = googleapiclient.http.BatchHttpRequest(callback=_callbackPrintCrOS)
          bcount = 0
      if bcount > 0:
        dbatch.execute()
    else:
      for cros in entityList:
        _printCrOS({u'deviceId': cros})
  if sortHeaders:
    sortCSVTitles([u'deviceId',], titles)
  if select and orderBy:
    import operator
    csvRows.sort(key=operator.itemgetter(orderBy), reverse=sortOrder == u'DESCENDING')
  writeCSVfile(csvRows, titles, u'CrOS', todrive)

# Mobile command utilities
MOBILE_ACTION_CHOICE_MAP = {
  u'accountwipe': u'admin_account_wipe',
  u'adminaccountwipe': u'admin_account_wipe',
  u'wipeaccount': u'admin_account_wipe',
  u'adminremotewipe': u'admin_remote_wipe',
  u'wipe': u'admin_remote_wipe',
  u'approve': u'approve',
  u'block': u'action_block',
  u'cancelremotewipethenactivate': u'cancel_remote_wipe_then_activate',
  u'cancelremotewipethenblock': u'cancel_remote_wipe_then_block',
  }

def getMobileDeviceEntity():
  cd = buildGAPIObject(DIRECTORY_API)
  if checkArgumentPresent(QUERY_ARGUMENT):
    query = getString(OB_QUERY)
  else:
    resourceId = getString(OB_MOBILE_DEVICE_ENTITY)
    if resourceId[:6].lower() == u'query:':
      query = resourceId[6:]
    else:
      CLArgs.Backup()
      query = None
  if not query:
    return (getEntityList(OB_MOBILE_ENTITY), cd)
  try:
    devices = callGAPIpages(cd.mobiledevices(), u'list', u'mobiledevices',
                            throw_reasons=[GAPI_INVALID_INPUT, GAPI_BAD_REQUEST, GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN],
                            customerId=GC_Values[GC_CUSTOMER_ID], query=query,
                            fields=u'nextPageToken,mobiledevices(resourceId)')
    return ([mobile[u'resourceId'] for mobile in devices], cd)
  except GAPI_invalidInput:
    CLArgs.Backup()
    usageErrorExit(PHRASE_INVALID_QUERY)
  except (GAPI_badRequest, GAPI_resourceNotFound, GAPI_forbidden):
    accessErrorExit(cd)

# gam update mobile|mobiles <MobileDeviceEntity> <MobileAttributes>
def doUpdateMobileDevices():
  entityList, cd = getMobileDeviceEntity()
  action_body = {}
  patch_body = {}
  doPatch = doAction = False
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'action':
      action_body[u'action'] = getChoice(MOBILE_ACTION_CHOICE_MAP, mapChoice=True)
      doAction = True
    elif myarg == u'model':
      patch_body[u'model'] = getString(OB_STRING)
      doPatch = True
    elif myarg == u'os':
      patch_body[u'os'] = getString(OB_STRING)
      doPatch = True
    elif myarg == u'useragent':
      patch_body[u'userAgent'] = getString(OB_STRING)
      doPatch = True
    else:
      unknownArgumentExit()
  i = 0
  count = len(entityList)
  for resourceId in entityList:
    i += 1
    try:
      if doPatch:
        callGAPI(cd.mobiledevices(), u'patch',
                 throw_reasons=[GAPI_RESOURCE_ID_NOT_FOUND, GAPI_INTERNAL_ERROR, GAPI_BAD_REQUEST, GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN],
                 customerId=GC_Values[GC_CUSTOMER_ID], resourceId=resourceId, body=patch_body, fields=u'')
        entityActionPerformed([Entity.MOBILE_DEVICE, resourceId], i, count)
      if doAction:
        callGAPI(cd.mobiledevices(), u'action',
                 throw_reasons=[GAPI_RESOURCE_ID_NOT_FOUND, GAPI_INTERNAL_ERROR, GAPI_BAD_REQUEST, GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN],
                 customerId=GC_Values[GC_CUSTOMER_ID], resourceId=resourceId, body=action_body)
        printEntityKVList([Entity.MOBILE_DEVICE, resourceId],
                          [PHRASE_ACTION_APPLIED, action_body[u'action']],
                          i, count)
    except GAPI_resourceIdNotFound:
      entityActionFailedWarning([Entity.MOBILE_DEVICE, resourceId], PHRASE_DOES_NOT_EXIST, i, count)
    except (GAPI_internalError, GAPI_badRequest, GAPI_resourceNotFound, GAPI_forbidden):
      accessErrorExit(cd)

# gam delete mobile|mobiles <MobileDeviceEntity>
def doDeleteMobileDevices():
  entityList, cd = getMobileDeviceEntity()
  checkForExtraneousArguments()
  i = 0
  count = len(entityList)
  for resourceId in entityList:
    i += 1
    try:
      callGAPI(cd.mobiledevices(), u'delete',
               throw_reasons=[GAPI_RESOURCE_ID_NOT_FOUND, GAPI_INTERNAL_ERROR, GAPI_BAD_REQUEST, GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN],
               customerId=GC_Values[GC_CUSTOMER_ID], resourceId=resourceId)
      entityActionPerformed([Entity.MOBILE_DEVICE, resourceId], i, count)
    except GAPI_resourceIdNotFound:
      entityActionFailedWarning([Entity.MOBILE_DEVICE, resourceId], PHRASE_DOES_NOT_EXIST, i, count)
    except (GAPI_internalError, GAPI_badRequest, GAPI_resourceNotFound, GAPI_forbidden):
      accessErrorExit(cd)

MOBILE_TIME_OBJECTS = [u'firstSync', u'lastSync']

# gam info mobile|mobiles <MobileDeviceEntity>
def doInfoMobileDevices():
  entityList, cd = getMobileDeviceEntity()
  checkForExtraneousArguments()
  i = 0
  count = len(entityList)
  for resourceId in entityList:
    i += 1
    try:
      info = callGAPI(cd.mobiledevices(), u'get',
                      throw_reasons=[GAPI_RESOURCE_ID_NOT_FOUND, GAPI_INTERNAL_ERROR, GAPI_BAD_REQUEST, GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN],
                      customerId=GC_Values[GC_CUSTOMER_ID], resourceId=resourceId)
      printEntity([Entity.MOBILE_DEVICE, resourceId], i, count)
      Indent.Increment()
      showJSON(None, info, time_objects=MOBILE_TIME_OBJECTS)
      Indent.Decrement()
    except GAPI_resourceIdNotFound:
      entityActionFailedWarning([Entity.MOBILE_DEVICE, resourceId], PHRASE_DOES_NOT_EXIST, i, count)
    except (GAPI_internalError, GAPI_badRequest, GAPI_resourceNotFound, GAPI_forbidden):
      accessErrorExit(cd)
    printBlankLine()

MOBILE_ORDERBY_CHOICES_MAP = {
  u'deviceid': u'deviceId',
  u'email': u'email',
  u'lastsync': u'lastSync',
  u'model': u'model',
  u'name': u'name',
  u'os': u'os',
  u'status': u'status',
  u'type': u'type',
  }

# gam print mobile [todrive [<ToDriveAttributes>]] [query <QueryMobile>] [basic|full]
#	[orderby <MobileOrderByFieldName> [ascending|descending]]
def doPrintMobileDevices():
  cd = buildGAPIObject(DIRECTORY_API)
  todrive = {}
  titles, csvRows = initializeTitlesCSVfile([u'resourceId',])
  query = projection = orderBy = sortOrder = None
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'query':
      query = getString(OB_QUERY)
    elif myarg == u'orderby':
      orderBy = getChoice(MOBILE_ORDERBY_CHOICES_MAP, mapChoice=True)
      sortOrder = getChoice(SORTORDER_CHOICES_MAP, defaultChoice=u'ascending', mapChoice=True)
    elif myarg in PROJECTION_CHOICES_MAP:
      projection = PROJECTION_CHOICES_MAP[myarg]
    else:
      unknownArgumentExit()
  try:
    printGettingAccountEntitiesInfo(Entity.MOBILE_DEVICE, qualifier=queryQualifier(query))
    page_message = getPageMessage()
    feed = callGAPIpages(cd.mobiledevices(), u'list', u'mobiledevices',
                         page_message=page_message,
                         throw_reasons=[GAPI_INVALID_INPUT, GAPI_BAD_REQUEST, GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN],
                         customerId=GC_Values[GC_CUSTOMER_ID], query=query, projection=projection,
                         orderBy=orderBy, sortOrder=sortOrder, maxResults=GC_Values[GC_DEVICE_MAX_RESULTS])
    while feed:
      mobile = feed.popleft()
      row = {}
      for attrib in mobile:
        if attrib in [u'kind', u'etag', u'applications']:
          continue
        if attrib not in titles[u'set']:
          addTitleToCSVfile(attrib, titles)
        if attrib in [u'name', u'email']:
          if mobile[attrib]:
            row[attrib] = mobile[attrib][0]
        elif attrib not in MOBILE_TIME_OBJECTS:
          row[attrib] = mobile[attrib]
        else:
          row[attrib] = formatLocalTime(mobile[attrib])
      csvRows.append(row)
  except GAPI_invalidInput:
    entityActionFailedWarning([Entity.MOBILE_DEVICE, PHRASE_LIST], invalidQuery(query))
  except (GAPI_badRequest, GAPI_resourceNotFound, GAPI_forbidden):
    accessErrorExit(cd)
  writeCSVfile(csvRows, titles, u'Mobile', todrive)

GROUP_ATTRIBUTES = {
  u'allowexternalmembers': [u'allowExternalMembers', {GC_VAR_TYPE: GC_TYPE_BOOLEAN}],
  u'allowgooglecommunication': [u'allowGoogleCommunication', {GC_VAR_TYPE: GC_TYPE_BOOLEAN}],
  u'allowwebposting': [u'allowWebPosting', {GC_VAR_TYPE: GC_TYPE_BOOLEAN}],
  u'archiveonly': [u'archiveOnly', {GC_VAR_TYPE: GC_TYPE_BOOLEAN}],
  u'customfootertext': [u'customFooterText', {GC_VAR_TYPE: GC_TYPE_STRING}],
  u'customreplyto': [u'customReplyTo', {GC_VAR_TYPE: GC_TYPE_EMAIL}],
  u'defaultmessagedenynotificationtext': [u'defaultMessageDenyNotificationText', {GC_VAR_TYPE: GC_TYPE_STRING}],
  u'description': [u'description', {GC_VAR_TYPE: GC_TYPE_STRING}],
  u'gal': [u'includeInGlobalAddressList', {GC_VAR_TYPE: GC_TYPE_BOOLEAN}],
  u'includecustomfooter': [u'includeCustomFooter', {GC_VAR_TYPE: GC_TYPE_BOOLEAN}],
  u'includeinglobaladdresslist': [u'includeInGlobalAddressList', {GC_VAR_TYPE: GC_TYPE_BOOLEAN}],
  u'isarchived': [u'isArchived', {GC_VAR_TYPE: GC_TYPE_BOOLEAN}],
  u'maxmessagebytes': [u'maxMessageBytes', {GC_VAR_TYPE: GC_TYPE_INTEGER}],
  u'memberscanpostasthegroup': [u'membersCanPostAsTheGroup', {GC_VAR_TYPE: GC_TYPE_BOOLEAN}],
  u'messagedisplayfont': [u'messageDisplayFont', {GC_VAR_TYPE: GC_TYPE_CHOICE,
                                                  u'choices': {u'defaultfont': u'DEFAULT_FONT', u'fixedwidthfont': u'FIXED_WIDTH_FONT',}}],
  u'messagemoderationlevel': [u'messageModerationLevel', {GC_VAR_TYPE: GC_TYPE_CHOICE,
                                                          u'choices': {u'moderateallmessages': u'MODERATE_ALL_MESSAGES', u'moderatenonmembers': u'MODERATE_NON_MEMBERS',
                                                                       u'moderatenewmembers': u'MODERATE_NEW_MEMBERS', u'moderatenone': u'MODERATE_NONE',}}],
  u'name': [u'name', {GC_VAR_TYPE: GC_TYPE_STRING}],
  u'primarylanguage': [u'primaryLanguage', {GC_VAR_TYPE: GC_TYPE_LANGUAGE}],
  u'replyto': [u'replyTo', {GC_VAR_TYPE: GC_TYPE_CHOICE,
                            u'choices': {u'replytocustom': u'REPLY_TO_CUSTOM', u'replytosender': u'REPLY_TO_SENDER', u'replytolist': u'REPLY_TO_LIST',
                                         u'replytoowner': u'REPLY_TO_OWNER', u'replytoignore': u'REPLY_TO_IGNORE', u'replytomanagers': u'REPLY_TO_MANAGERS',}}],
  u'sendmessagedenynotification': [u'sendMessageDenyNotification', {GC_VAR_TYPE: GC_TYPE_BOOLEAN}],
  u'showingroupdirectory': [u'showInGroupDirectory', {GC_VAR_TYPE: GC_TYPE_BOOLEAN}],
  u'spammoderationlevel': [u'spamModerationLevel', {GC_VAR_TYPE: GC_TYPE_CHOICE,
                                                    u'choices': {u'allow': u'ALLOW', u'moderate': u'MODERATE', u'silentlymoderate': u'SILENTLY_MODERATE', u'reject': u'REJECT',}}],
  u'whocanadd': [u'whoCanAdd', {GC_VAR_TYPE: GC_TYPE_CHOICE,
                                u'choices': {u'allmemberscanadd': u'ALL_MEMBERS_CAN_ADD', u'allmanagerscanadd': u'ALL_MANAGERS_CAN_ADD', u'nonecanadd': u'NONE_CAN_ADD',}}],
  u'whocancontactowner': [u'whoCanContactOwner', {GC_VAR_TYPE: GC_TYPE_CHOICE,
                                                  u'choices': {u'anyonecancontact': u'ANYONE_CAN_CONTACT', u'allindomaincancontact': u'ALL_IN_DOMAIN_CAN_CONTACT',
                                                               u'allmemberscancontact': u'ALL_MEMBERS_CAN_CONTACT', u'allmanagerscancontact': u'ALL_MANAGERS_CAN_CONTACT',}}],
  u'whocaninvite': [u'whoCanInvite', {GC_VAR_TYPE: GC_TYPE_CHOICE,
                                      u'choices': {u'allmemberscaninvite': u'ALL_MEMBERS_CAN_INVITE', u'allmanagerscaninvite': u'ALL_MANAGERS_CAN_INVITE', u'nonecaninvite': u'NONE_CAN_INVITE',}}],
  u'whocanjoin': [u'whoCanJoin', {GC_VAR_TYPE: GC_TYPE_CHOICE,
                                  u'choices': {u'anyonecanjoin': u'ANYONE_CAN_JOIN', u'allindomaincanjoin': u'ALL_IN_DOMAIN_CAN_JOIN',
                                               u'invitedcanjoin': u'INVITED_CAN_JOIN', u'canrequesttojoin': u'CAN_REQUEST_TO_JOIN',}}],
  u'whocanleavegroup': [u'whoCanLeaveGroup', {GC_VAR_TYPE: GC_TYPE_CHOICE,
                                              u'choices': {u'allmanagerscanleave': u'ALL_MANAGERS_CAN_LEAVE', u'allmemberscanleave': u'ALL_MEMBERS_CAN_LEAVE', u'nonecanleave': u'NONE_CAN_LEAVE',}}],
  u'whocanpostmessage': [u'whoCanPostMessage', {GC_VAR_TYPE: GC_TYPE_CHOICE,
                                                u'choices': {u'nonecanpost': u'NONE_CAN_POST', u'allmanagerscanpost': u'ALL_MANAGERS_CAN_POST', u'allmemberscanpost': u'ALL_MEMBERS_CAN_POST',
                                                             u'allindomaincanpost': u'ALL_IN_DOMAIN_CAN_POST', u'anyonecanpost': u'ANYONE_CAN_POST',}}],
  u'whocanviewgroup': [u'whoCanViewGroup', {GC_VAR_TYPE: GC_TYPE_CHOICE,
                                            u'choices': {u'anyonecanview': u'ANYONE_CAN_VIEW', u'allindomaincanview': u'ALL_IN_DOMAIN_CAN_VIEW',
                                                         u'allmemberscanview': u'ALL_MEMBERS_CAN_VIEW', u'allmanagerscanview': u'ALL_MANAGERS_CAN_VIEW',}}],
  u'whocanviewmembership': [u'whoCanViewMembership', {GC_VAR_TYPE: GC_TYPE_CHOICE,
                                                      u'choices': {u'allindomaincanview': u'ALL_IN_DOMAIN_CAN_VIEW', u'allmemberscanview': u'ALL_MEMBERS_CAN_VIEW',
                                                                   u'allmanagerscanview': u'ALL_MANAGERS_CAN_VIEW',}}],
  }

GROUP_FIELDS_WITH_CRS_NLS = [u'customFooterText', u'defaultMessageDenyNotificationText', u'description']

def getGroupAttrValue(argument, gs_body):
  attrProperties = GROUP_ATTRIBUTES.get(argument)
  if not attrProperties:
    unknownArgumentExit()
  attrName = attrProperties[0]
  attribute = attrProperties[1]
  attrType = attribute[GC_VAR_TYPE]
  if attrType == GC_TYPE_BOOLEAN:
    gs_body[attrName] = getBoolean()
  elif attrType == GC_TYPE_STRING:
    if attrName in GROUP_FIELDS_WITH_CRS_NLS:
      gs_body[attrName] = getString(OB_STRING, minLen=0).replace(u'\\n', u'\n')
    else:
      gs_body[attrName] = getString(OB_STRING, minLen=0)
  elif attrType == GC_TYPE_CHOICE:
    gs_body[attrName] = getChoice(attribute[u'choices'], mapChoice=True)
  elif attrType == GC_TYPE_EMAIL:
    gs_body[attrName] = getEmailAddress(noUid=True)
  elif attrType == GC_TYPE_LANGUAGE:
    gs_body[attrName] = getChoice(LANGUAGE_CODES_MAP, mapChoice=True)
  else: # GC_TYPE_INTEGER
    if attrName == u'maxMessageBytes':
      gs_body[attrName] = getMaxMessageBytes()
    else:
      gs_body[attrName] = getInteger()

def GroupIsAbuseOrPostmaster(emailAddr):
  return emailAddr.startswith(u'abuse@') or emailAddr.startswith(u'postmaster@')

# gam create group <EmailAddress> <GroupAttributes>
def doCreateGroup():
  cd = buildGAPIObject(DIRECTORY_API)
  body = {u'email': getEmailAddress(noUid=True)}
  gs_body = {}
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'name':
      body[u'name'] = getString(OB_STRING)
    elif myarg == u'description':
      body[u'description'] = getString(OB_STRING, minLen=0).replace(u'\\n', u'\n')
    else:
      getGroupAttrValue(myarg, gs_body)
  body.setdefault(u'name', body[u'email'])
  try:
    callGAPI(cd.groups(), u'insert',
             throw_reasons=[GAPI_DUPLICATE, GAPI_DOMAIN_NOT_FOUND, GAPI_FORBIDDEN, GAPI_INVALID, GAPI_INVALID_INPUT],
             body=body, fields=u'')
    errMsg = u''
    if gs_body and not GroupIsAbuseOrPostmaster(body[u'email']):
      gs = buildGAPIObject(GROUPSSETTINGS_API)
      result = callGAPI(gs.groups(), u'patch',
                        soft_errors=True, throw_reasons=GAPI_GROUP_SETTINGS_THROW_REASONS, retry_reasons=GAPI_GROUP_SETTINGS_RETRY_REASONS,
                        groupUniqueId=body[u'email'], body=gs_body, fields=u'')
      if result is None:
        errMsg = PHRASE_API_ERROR_SETTINGS
    entityActionPerformedMessage([Entity.GROUP, body[u'email']], errMsg)
  except GAPI_duplicate:
    entityDuplicateWarning(Entity.GROUP, body[u'email'])
  except (GAPI_groupNotFound, GAPI_domainNotFound, GAPI_forbidden, GAPI_backendError, GAPI_systemError, GAPI_invalid, GAPI_invalidInput) as e:
    entityActionFailedWarning([Entity.GROUP, body[u'email']], e.message)

def checkGroupExists(cd, group, i=0, count=0):
  group = normalizeEmailAddressOrUID(group)
  try:
    return callGAPI(cd.groups(), u'get',
                    throw_reasons=GAPI_GROUP_GET_THROW_REASONS, retry_reasons=GAPI_GROUP_GET_RETRY_REASONS,
                    groupKey=group, fields=u'email')[u'email']
  except (GAPI_groupNotFound, GAPI_domainNotFound, GAPI_forbidden, GAPI_badRequest):
    entityUnknownWarning(Entity.GROUP, group, i, count)
    return None

UPDATE_GROUP_SUBCMDS = [u'add', u'clear', u'delete', u'remove', u'sync', u'update']

# gam update groups <GroupEntity> [admincreated <Boolean>] [email <EmailAddress>] <GroupAttributes>
# gam update groups <GroupEntity> add [member|manager|owner] [notsuspended] <UserTypeEntity>
# gam update groups <GroupEntity> delete|remove [member|manager|owner] <UserTypeEntity>
# gam update groups <GroupEntity> sync [member|manager|owner] [notsuspended] <UserTypeEntity>
# gam update groups <GroupEntity> update [member|manager|owner] <UserTypeEntity>
# gam update groups <GroupEntity> clear [member] [manager] [owner] [suspended]
def doUpdateGroups():

  _ADD_MEMBER_REASON_TO_MESSAGE_MAP = {GAPI_DUPLICATE: PHRASE_DUPLICATE, GAPI_MEMBER_NOT_FOUND: PHRASE_DOES_NOT_EXIST,
                                       GAPI_RESOURCE_NOT_FOUND: PHRASE_DOES_NOT_EXIST, GAPI_INVALID_MEMBER: PHRASE_INVALID_ROLE,
                                       GAPI_CYCLIC_MEMBERSHIPS_NOT_ALLOWED: PHRASE_WOULD_MAKE_MEMBERSHIP_CYCLE}
  def _callbackAddGroupMembers(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      entityActionPerformed([Entity.GROUP, ri[RI_ENTITY], ri[RI_ROLE], ri[RI_ITEM]], int(ri[RI_J]), int(ri[RI_JCOUNT]))
    else:
      http_status, reason, message = checkGAPIError(exception)
      if reason in GAPI_MEMBERS_THROW_REASONS:
        entityUnknownWarning(Entity.GROUP, ri[RI_ENTITY], int(ri[RI_I]), int(ri[RI_COUNT]))
      else:
        errMsg = getHTTPError(_ADD_MEMBER_REASON_TO_MESSAGE_MAP, http_status, reason, message)
        entityActionFailedWarning([Entity.GROUP, ri[RI_ENTITY], ri[RI_ROLE], ri[RI_ITEM]], errMsg, int(ri[RI_J]), int(ri[RI_JCOUNT]))

  def _batchAddGroupMembers(cd, group, i, count, addMembers, role):
    Action.Set(Action.ADD)
    jcount = len(addMembers)
    entityPerformActionNumItems([Entity.GROUP, group], jcount, role, i, count)
    if jcount == 0:
      return
    Indent.Increment()
    svcargs = dict([(u'groupKey', group), (u'body', {u'role': role}), (u'fields', u'')]+GM_Globals[GM_EXTRA_ARGS_LIST])
    dbatch = googleapiclient.http.BatchHttpRequest(callback=_callbackAddGroupMembers)
    bcount = 0
    j = 0
    for member in addMembers:
      j += 1
      svcparms = svcargs.copy()
      member = normalizeEmailAddressOrUID(member, checkForCustomerId=True)
      if member.find(u'@') != -1:
        svcparms[u'body'][u'email'] = member
        svcparms[u'body'].pop(u'id', None)
      else:
        svcparms[u'body'][u'id'] = member
        svcparms[u'body'].pop(u'email', None)
      dbatch.add(cd.members().insert(**svcparms), request_id=batchRequestID(group, i, count, j, jcount, member, role))
      bcount += 1
      if bcount >= GC_Values[GC_BATCH_SIZE]:
        dbatch.execute()
        dbatch = googleapiclient.http.BatchHttpRequest(callback=_callbackAddGroupMembers)
        bcount = 0
    if bcount > 0:
      dbatch.execute()
    Indent.Decrement()

  _REMOVE_UPDATE_MEMBER_REASON_TO_MESSAGE_MAP = {GAPI_MEMBER_NOT_FOUND: u'{0} {1}'.format(PHRASE_NOT_A, Entity.Singular(Entity.MEMBER)), GAPI_INVALID_MEMBER: PHRASE_DOES_NOT_EXIST}
  def _callbackRemoveUpdateGroupMembers(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      entityActionPerformed([Entity.GROUP, ri[RI_ENTITY], ri[RI_ROLE], ri[RI_ITEM]], int(ri[RI_J]), int(ri[RI_JCOUNT]))
    else:
      http_status, reason, message = checkGAPIError(exception)
      if reason in GAPI_MEMBERS_THROW_REASONS:
        entityUnknownWarning(Entity.GROUP, ri[RI_ENTITY], int(ri[RI_I]), int(ri[RI_COUNT]))
      else:
        errMsg = getHTTPError(_REMOVE_UPDATE_MEMBER_REASON_TO_MESSAGE_MAP, http_status, reason, message)
        entityActionFailedWarning([Entity.GROUP, ri[RI_ENTITY], ri[RI_ROLE], ri[RI_ITEM]], errMsg, int(ri[RI_J]), int(ri[RI_JCOUNT]))

  def _batchRemoveUpdateGroupMembers(cd, function, group, i, count, removeUpdateMembers, role):
    if function == u'delete':
      Action.Set(Action.REMOVE)
      svcargs = dict([(u'groupKey', group), (u'memberKey', None), (u'fields', u'')]+GM_Globals[GM_EXTRA_ARGS_LIST])
    else:
      Action.Set(Action.UPDATE)
      svcargs = dict([(u'groupKey', group), (u'memberKey', None), (u'body', {u'role': role}), (u'fields', u'')]+GM_Globals[GM_EXTRA_ARGS_LIST])
    jcount = len(removeUpdateMembers)
    entityPerformActionNumItems([Entity.GROUP, group], jcount, role, i, count)
    if jcount == 0:
      return
    Indent.Increment()
    method = getattr(cd.members(), function)
    dbatch = googleapiclient.http.BatchHttpRequest(callback=_callbackRemoveUpdateGroupMembers)
    bcount = 0
    j = 0
    for member in removeUpdateMembers:
      j += 1
      svcparms = svcargs.copy()
      svcparms[u'memberKey'] = normalizeEmailAddressOrUID(member, checkForCustomerId=True)
      dbatch.add(method(**svcparms), request_id=batchRequestID(group, i, count, j, jcount, svcparms[u'memberKey'], role))
      bcount += 1
      if bcount >= GC_Values[GC_BATCH_SIZE]:
        dbatch.execute()
        dbatch = googleapiclient.http.BatchHttpRequest(callback=_callbackRemoveUpdateGroupMembers)
        bcount = 0
    if bcount > 0:
      dbatch.execute()
    Indent.Decrement()

  cd = buildGAPIObject(DIRECTORY_API)
  entityList = getEntityList(OB_GROUP_ENTITY)
  CL_subCommand = getChoice(UPDATE_GROUP_SUBCMDS, defaultChoice=None)
  if not CL_subCommand:
    body = {}
    gs_body = {}
    while CLArgs.ArgumentsRemaining():
      myarg = getArgument()
      if myarg == u'email':
        body[u'email'] = getEmailAddress(noUid=True)
      elif myarg == u'admincreated':
        body[u'adminCreated'] = getBoolean()
      else:
        getGroupAttrValue(myarg, gs_body)
    if gs_body:
      gs = buildGAPIObject(GROUPSSETTINGS_API)
    Action.Set(Action.UPDATE)
    i = 0
    count = len(entityList)
    for group in entityList:
      i += 1
      group = normalizeEmailAddressOrUID(group)
      if body or (group.find(u'@') == -1): # group settings API won't take uid so we make sure cd API is used so that we can grab real email.
        try:
          group = callGAPI(cd.groups(), u'patch',
                           throw_reasons=GAPI_GROUP_GET_THROW_REASONS, retry_reasons=GAPI_GROUP_GET_RETRY_REASONS,
                           groupKey=group, body=body, fields=u'email')[u'email']
        except (GAPI_groupNotFound, GAPI_domainNotFound, GAPI_backendError, GAPI_badRequest):
          entityUnknownWarning(Entity.GROUP, group, i, count)
          continue
      errMsg = u''
      if gs_body and not GroupIsAbuseOrPostmaster(group):
        try:
          result = callGAPI(gs.groups(), u'patch',
                            soft_errors=True, throw_reasons=GAPI_GROUP_SETTINGS_THROW_REASONS, retry_reasons=GAPI_GROUP_SETTINGS_RETRY_REASONS,
                            groupUniqueId=group, body=gs_body, fields=u'')
          if result is None:
            errMsg = PHRASE_API_ERROR_SETTINGS
        except (GAPI_groupNotFound, GAPI_domainNotFound, GAPI_forbidden, GAPI_backendError, GAPI_systemError):
          entityUnknownWarning(Entity.GROUP, group, i, count)
          continue
      entityActionPerformedMessage([Entity.GROUP, group], errMsg, i, count)
  elif CL_subCommand == u'add':
    role = getChoice(GROUP_ROLES_MAP, defaultChoice=Entity.ROLE_MEMBER, mapChoice=True)
    checkNotSuspended = True if checkArgumentPresent(NOTSUSPENDED_ARGUMENT) else False
    _, addMembers = getEntityToModify(defaultEntityType=CL_ENTITY_USERS, checkNotSuspended=checkNotSuspended, groupUserMembersOnly=False)
    groupMemberLists = addMembers if isinstance(addMembers, dict) else None
    checkForExtraneousArguments()
    i = 0
    count = len(entityList)
    for group in entityList:
      i += 1
      if groupMemberLists:
        addMembers = groupMemberLists[group]
      group = checkGroupExists(cd, group, i, count)
      if group:
        _batchAddGroupMembers(cd, group, i, count, addMembers, role)
  elif CL_subCommand in [u'delete', u'remove']:
    role = getChoice(GROUP_ROLES_MAP, defaultChoice=Entity.ROLE_MEMBER, mapChoice=True) # Argument ignored
    _, removeMembers = getEntityToModify(defaultEntityType=CL_ENTITY_USERS, groupUserMembersOnly=False)
    groupMemberLists = removeMembers if isinstance(removeMembers, dict) else None
    checkForExtraneousArguments()
    i = 0
    count = len(entityList)
    for group in entityList:
      i += 1
      if groupMemberLists:
        removeMembers = groupMemberLists[group]
      group = checkGroupExists(cd, group, i, count)
      if group:
        _batchRemoveUpdateGroupMembers(cd, u'delete', group, i, count, removeMembers, role)
  elif CL_subCommand == u'sync':
    role = getChoice(GROUP_ROLES_MAP, defaultChoice=Entity.ROLE_MEMBER, mapChoice=True)
    checkNotSuspended = checkArgumentPresent(NOTSUSPENDED_ARGUMENT)
    _, syncMembers = getEntityToModify(defaultEntityType=CL_ENTITY_USERS, checkNotSuspended=checkNotSuspended, groupUserMembersOnly=False)
    groupMemberLists = syncMembers if isinstance(syncMembers, dict) else None
    if not groupMemberLists:
      syncMembersSet = set()
      for member in syncMembers:
        syncMembersSet.add(convertUserUIDtoEmailAddress(member, checkForCustomerId=True))
    checkForExtraneousArguments()
    i = 0
    count = len(entityList)
    for group in entityList:
      i += 1
      if groupMemberLists:
        syncMembersSet = set()
        for member in groupMemberLists[group]:
          syncMembersSet.add(convertUserUIDtoEmailAddress(member, checkForCustomerId=True))
      group = checkGroupExists(cd, group, i, count)
      if group:
        currentMembersSet = set(getUsersToModify(CL_ENTITY_GROUP, group, memberRole=role, groupUserMembersOnly=False))
        _batchAddGroupMembers(cd, group, i, count, list(syncMembersSet-currentMembersSet), role)
        _batchRemoveUpdateGroupMembers(cd, u'delete', group, i, count, list(currentMembersSet-syncMembersSet), role)
  elif CL_subCommand == u'update':
    role = getChoice(GROUP_ROLES_MAP, defaultChoice=Entity.ROLE_MEMBER, mapChoice=True)
    _, updateMembers = getEntityToModify(defaultEntityType=CL_ENTITY_USERS, groupUserMembersOnly=False)
    groupMemberLists = updateMembers if isinstance(updateMembers, dict) else None
    checkForExtraneousArguments()
    i = 0
    count = len(entityList)
    for group in entityList:
      i += 1
      if groupMemberLists:
        updateMembers = groupMemberLists[group]
      group = checkGroupExists(cd, group, i, count)
      if group:
        _batchRemoveUpdateGroupMembers(cd, u'update', group, i, count, updateMembers, role)
  else: #clear
    suspended = False
    fields = [u'email', u'id']
    rolesList = []
    while CLArgs.ArgumentsRemaining():
      myarg = getArgument()
      if myarg in GROUP_ROLES_MAP:
        rolesList.append(GROUP_ROLES_MAP[myarg])
      elif myarg == u'suspended':
        suspended = True
        fields.append(u'status')
      else:
        unknownArgumentExit()
    Action.Set(Action.REMOVE)
    if rolesList:
      roles = u','.join(sorted(set(rolesList)))
    else:
      roles = Entity.ROLE_MEMBER
    i = 0
    count = len(entityList)
    for group in entityList:
      i += 1
      group = normalizeEmailAddressOrUID(group)
      printGettingAllEntityItemsForWhom(roles, group, qualifier=[u'', u' (Suspended)'][suspended], entityType=Entity.GROUP)
      page_message = getPageMessageForWhom(noNL=True)
      try:
        result = callGAPIpages(cd.members(), u'list', u'members',
                               page_message=page_message,
                               throw_reasons=GAPI_MEMBERS_THROW_REASONS,
                               groupKey=group, roles=roles, fields=u'nextPageToken,members({0})'.format(u','.join(fields)), maxResults=GC_Values[GC_MEMBER_MAX_RESULTS])
        if not suspended:
          removeMembers = [member.get(u'email', member[u'id']) for member in result]
        else:
          removeMembers = [member.get(u'email', member[u'id']) for member in result if member[u'status'] == u'SUSPENDED']
        _batchRemoveUpdateGroupMembers(cd, u'delete', group, i, count, removeMembers, Entity.ROLE_MEMBER)
      except (GAPI_groupNotFound, GAPI_domainNotFound, GAPI_invalid, GAPI_forbidden):
        entityUnknownWarning(Entity.GROUP, group, i, count)

# gam delete groups <GroupEntity>
def doDeleteGroups():
  cd = buildGAPIObject(DIRECTORY_API)
  entityList = getEntityList(OB_GROUP_ENTITY)
  checkForExtraneousArguments()
  i = 0
  count = len(entityList)
  for group in entityList:
    i += 1
    group = normalizeEmailAddressOrUID(group)
    try:
      callGAPI(cd.groups(), u'delete',
               throw_reasons=[GAPI_GROUP_NOT_FOUND, GAPI_DOMAIN_NOT_FOUND, GAPI_FORBIDDEN, GAPI_INVALID],
               groupKey=group)
      entityActionPerformed([Entity.GROUP, group], i, count)
    except (GAPI_groupNotFound, GAPI_domainNotFound, GAPI_forbidden, GAPI_invalid):
      entityUnknownWarning(Entity.GROUP, group, i, count)
#
# CL argument: [API field name, CSV field title]
GROUP_ARGUMENT_TO_PROPERTY_TITLE_MAP = {
  u'admincreated': [u'adminCreated', u'Admin_Created'],
  u'aliases': [u'aliases', u'Aliases', u'nonEditableAliases', u'NonEditableAliases'],
  u'description': [u'description', u'Description'],
  u'directmemberscount': [u'directMembersCount', u'DirectMembersCount'],
  u'email': [u'email', u'Email'],
  u'id': [u'id', u'ID'],
  u'name': [u'name', u'Name'],
  }

INFO_GROUP_OPTIONS = [u'nousers', u'groups',]

def infoGroups(entityList):
  cd = buildGAPIObject(DIRECTORY_API)
  getAliases = getUsers = True
  getGroups = getSettings = False
  formatJSON = False
  groups = collections.deque()
  members = collections.deque()
  cdfieldsList = gsfieldsList = None
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'nousers':
      getUsers = False
    elif myarg == u'noaliases':
      getAliases = False
    elif myarg == u'groups':
      getGroups = True
    elif myarg in GROUP_ARGUMENT_TO_PROPERTY_TITLE_MAP:
      if not cdfieldsList:
        cdfieldsList = [u'email',]
      cdfieldsList.extend([GROUP_ARGUMENT_TO_PROPERTY_TITLE_MAP[myarg][0],])
    elif myarg in GROUP_ATTRIBUTES:
      if not gsfieldsList:
        gsfieldsList = []
      gsfieldsList.extend([GROUP_ATTRIBUTES[myarg][0],])
    elif myarg == u'fields':
      if not cdfieldsList:
        cdfieldsList = [u'email',]
      if not gsfieldsList:
        gsfieldsList = []
      fieldNameList = getString(OB_FIELD_NAME_LIST)
      for field in fieldNameList.lower().replace(u',', u' ').split():
        if field in GROUP_ARGUMENT_TO_PROPERTY_TITLE_MAP:
          cdfieldsList.extend([GROUP_ARGUMENT_TO_PROPERTY_TITLE_MAP[field][0],])
        elif field in GROUP_ATTRIBUTES:
          gsfieldsList.extend([GROUP_ATTRIBUTES[field][0],])
        else:
          CLArgs.Backup()
          invalidChoiceExit(GROUP_ARGUMENT_TO_PROPERTY_TITLE_MAP.keys()+GROUP_ATTRIBUTES.keys())
# Ignore info user arguments that may have come from whatis
    elif myarg in INFO_USER_OPTIONS:
      if myarg == u'schemas':
        getString(OB_SCHEMA_NAME_LIST)
    elif myarg == "formatjson":
      formatJSON = True
    else:
      unknownArgumentExit()
  cdfields = u','.join(set(cdfieldsList)) if cdfieldsList else None
  if gsfieldsList is None:
    getSettings = True
    gsfields = None
  elif gsfieldsList:
    getSettings = True
    gsfields = u','.join(set(gsfieldsList))
  else:
    gsfields = None
  if getSettings:
    gs = buildGAPIObject(GROUPSSETTINGS_API)
  i = 0
  count = len(entityList)
  for group in entityList:
    i += 1
    group = normalizeEmailAddressOrUID(group)
    try:
      basic_info = callGAPI(cd.groups(), u'get',
                            throw_reasons=GAPI_GROUP_GET_THROW_REASONS, retry_reasons=GAPI_GROUP_GET_RETRY_REASONS,
                            groupKey=group, fields=cdfields)
      group = basic_info[u'email']
      settings = {}
      if getSettings and not GroupIsAbuseOrPostmaster(group):
        settings = callGAPI(gs.groups(), u'get',
                            soft_errors=True, throw_reasons=GAPI_GROUP_SETTINGS_THROW_REASONS, retry_reasons=GAPI_GROUP_SETTINGS_RETRY_REASONS,
                            groupUniqueId=group, fields=gsfields) # Use email address retrieved from cd since GS API doesn't support uid
      if getGroups:
        groups = callGAPIpages(cd.groups(), u'list', u'groups',
                               userKey=group, fields=u'nextPageToken,groups(name,email)')
      if getUsers:
        members = callGAPIpages(cd.members(), u'list', u'members',
                                throw_reasons=GAPI_MEMBERS_THROW_REASONS, retry_reasons=GAPI_MEMBERS_RETRY_REASONS,
                                groupKey=group, fields=u'nextPageToken,members(email,id,role,status,type)', maxResults=GC_Values[GC_MEMBER_MAX_RESULTS])
      if formatJSON:
        basic_info.update(settings)
        if getGroups:
          basic_info[u'groups'] = list(groups)
        if getUsers:
          basic_info[u'members'] = list(members)
        printLine(json.dumps(basic_info, ensure_ascii=False, sort_keys=True))
        continue
      printEntity([Entity.GROUP, group], i, count)
      Indent.Increment()
      printEntity([Entity.GROUP_SETTINGS, None])
      Indent.Increment()
      for key, value in basic_info.items():
        if key in [u'kind', u'etag', u'email', u'aliases']:
          continue
        if isinstance(value, list):
          printKeyValueList([key, None])
          Indent.Increment()
          for val in value:
            printKeyValueList([val])
          Indent.Decrement()
        else:
          if key in GROUP_FIELDS_WITH_CRS_NLS:
            value = convertCRsNLs(value)
          printKeyValueList([key, value])
      if settings:
        for key, value in sorted(settings.items()):
          if key in [u'kind', u'etag', u'email', u'name', u'description']:
            continue
          if key == u'maxMessageBytes':
            value = formatMaxMessageBytes(value)
          elif key in GROUP_FIELDS_WITH_CRS_NLS:
            value = convertCRsNLs(value)
          printKeyValueList([key, value])
      Indent.Decrement()
      if getAliases:
        aliases = basic_info.get(u'aliases', [])
        if aliases:
          printEntitiesCount(Entity.EMAIL_ALIAS, aliases)
          Indent.Increment()
          for alias in aliases:
            printKeyValueList([alias])
          Indent.Decrement()
      if getGroups:
        printEntitiesCount(Entity.GROUP, groups)
        Indent.Increment()
        for groupm in groups:
          printKeyValueList([groupm[u'name'], groupm[u'email']])
        Indent.Decrement()
      if getUsers:
        printEntitiesCount(Entity.MEMBER, members)
        Indent.Increment()
        for member in members:
          printKeyValueList([member.get(u'role', Entity.ROLE_MEMBER).lower(), u'{0} ({1})'.format(member.get(u'email', member[u'id']), member[u'type'].lower())])
        Indent.Decrement()
        printKeyValueList([u'Total users in group', len(members)])
      Indent.Decrement()
    except (GAPI_groupNotFound, GAPI_domainNotFound, GAPI_invalid, GAPI_forbidden, GAPI_badRequest, GAPI_backendError, GAPI_systemError):
      entityUnknownWarning(Entity.GROUP, group, i, count)

# gam info groups <GroupEntity> [noaliases] [nousers] [groups] <GroupFieldName>* [fields <GroupFieldNameList>] [formatjson]
def doInfoGroups():
  infoGroups(getEntityList(OB_GROUP_ENTITY))

def groupQuery(domain, userKey):
  if domain:
    if userKey:
      return'{0}={1}, {2}={3}'.format(Entity.Singular(Entity.DOMAIN), domain, Entity.Singular(Entity.MEMBER), userKey)
    return u'{0}={1}'.format(Entity.Singular(Entity.DOMAIN), domain)
  if userKey:
    return u'{0}={1}'.format(Entity.Singular(Entity.MEMBER), userKey)
  return u''

# gam print groups [todrive [<ToDriveAttributes>]] ([domain <DomainName>] [member <UserItem>])|[select <GroupEntity>]
#         [maxresults <Number>] [allfields|([settings] <GroupFieldName>* [fields <GroupFieldNameList>])] [convertcrnl] [delimiter <String>]
#         [members|memberscount] [managers|managerscount] [owners|ownerscount] [countsonly]
def doPrintGroups():

  def _printGroupRow(groupEntity, groupMembers, groupSettings):
    row = {}
    for field in cdfieldsList:
      if field in groupEntity:
        if isinstance(groupEntity[field], list):
          row[fieldsTitles[field]] = delimiter.join(groupEntity[field])
        elif convertCRNL and field in GROUP_FIELDS_WITH_CRS_NLS:
          row[fieldsTitles[field]] = convertCRsNLs(groupEntity[field])
        else:
          row[fieldsTitles[field]] = groupEntity[field]
    if groupMembers is not None:
      if members:
        membersList = []
        membersCount = 0
      if managers:
        managersList = []
        managersCount = 0
      if owners:
        ownersList = []
        ownersCount = 0
      for member in groupMembers:
        member_email = member.get(u'email', member.get(u'id', None))
        if not member_email:
          writeStderr(u' Not sure what to do with: {0}\n'.format(member))
          continue
        role = member.get(u'role', Entity.ROLE_MEMBER)
        if role == Entity.ROLE_MEMBER:
          if members:
            membersCount += 1
            if not membersCountOnly:
              membersList.append(member_email)
        elif role == Entity.ROLE_MANAGER:
          if managers:
            managersCount += 1
            if not managersCountOnly:
              managersList.append(member_email)
        elif role == Entity.ROLE_OWNER:
          if owners:
            ownersCount += 1
            if not ownersCountOnly:
              ownersList.append(member_email)
        elif members:
          membersCount += 1
          if not membersCountOnly:
            membersList.append(member_email)
      if members:
        row[u'MembersCount'] = membersCount
        if not membersCountOnly:
          row[u'Members'] = delimiter.join(membersList)
      if managers:
        row[u'ManagersCount'] = managersCount
        if not managersCountOnly:
          row[u'Managers'] = delimiter.join(managersList)
      if owners:
        row[u'OwnersCount'] = ownersCount
        if not ownersCountOnly:
          row[u'Owners'] = delimiter.join(ownersList)
    if isinstance(groupSettings, dict):
      for key in groupSettings:
        if key in [u'kind', u'etag', u'email', u'name', u'description']:
          continue
        setting_value = groupSettings[key]
        if setting_value is None:
          setting_value = u''
        if key not in titles[u'set']:
          addTitleToCSVfile(key, titles)
        if convertCRNL and key in GROUP_FIELDS_WITH_CRS_NLS:
          row[key] = convertCRsNLs(setting_value)
        else:
          row[key] = setting_value
    csvRows.append(row)

  def _callbackProcessGroupBasic(request_id, response, exception):
    ri = request_id.splitlines()
    i = int(ri[RI_I])
    if exception is not None:
      http_status, reason, message = checkGAPIError(exception)
      if reason not in GAPI_DEFAULT_RETRY_REASONS+GAPI_GROUP_GET_RETRY_REASONS:
        if reason in GAPI_GROUP_GET_THROW_REASONS:
          entityUnknownWarning(Entity.GROUP, ri[RI_ENTITY], i, int(ri[RI_COUNT]))
        else:
          errMsg = getHTTPError({}, http_status, reason, message)
          entityActionFailedWarning([Entity.GROUP, ri[RI_ENTITY], Entity.GROUP, None], errMsg, i, int(ri[RI_COUNT]))
        return
      waitOnFailure(1, 10, reason, message)
      try:
        response = callGAPI(cd.groups(), u'get',
                            soft_errors=True, throw_reasons=GAPI_GROUP_GET_THROW_REASONS, retry_reasons=GAPI_GROUP_GET_RETRY_REASONS,
                            groupKey=ri[RI_ENTITY], fields=cdfields)
      except (GAPI_groupNotFound, GAPI_domainNotFound, GAPI_forbidden, GAPI_badRequest):
        entityUnknownWarning(Entity.GROUP, ri[RI_ENTITY], i, int(ri[RI_COUNT]))
        return
    entityList.append(response)

  def _callbackProcessGroupMembers(request_id, response, exception):
    def _writeRowIfComplete(i):
      if groupData[i][u'settings'] is False:
        _printGroupRow(groupData[i][u'entity'], groupData[i][u'members'], groupData[i][u'settings'])
        del groupData[i]

    ri = request_id.splitlines()
    i = int(ri[RI_I])
    totalItems = 0
    items = u'members'
    page_message = getPageMessageForWhom(forWhom=ri[RI_ENTITY], showTotal=False, showFirstLastItems=True)
    if exception is not None:
      http_status, reason, message = checkGAPIError(exception)
      if reason not in GAPI_DEFAULT_RETRY_REASONS+GAPI_MEMBERS_RETRY_REASONS:
        errMsg = getHTTPError({}, http_status, reason, message)
        entityActionFailedWarning([Entity.GROUP, ri[RI_ENTITY], ri[RI_ROLE], None], errMsg, i, int(ri[RI_COUNT]))
        _writeRowIfComplete(i)
        return
      waitOnFailure(1, 10, reason, message)
      try:
        response = callGAPI(cd.members(), u'list',
                            throw_reasons=GAPI_MEMBERS_THROW_REASONS, retry_reasons=GAPI_MEMBERS_RETRY_REASONS,
                            groupKey=ri[RI_ENTITY], roles=ri[RI_ROLE], fields=u'nextPageToken,members(email,id,role)', maxResults=GC_Values[GC_MEMBER_MAX_RESULTS])
      except (GAPI_groupNotFound, GAPI_domainNotFound, GAPI_invalid, GAPI_forbidden) as e:
        entityActionFailedWarning([Entity.GROUP, ri[RI_ENTITY], ri[RI_ROLE], None], e.message, i, int(ri[RI_COUNT]))
        _writeRowIfComplete(i)
        return
    while True:
      pageToken, totalItems = _processGAPIpagesResult(response, items, groupData[i][items], totalItems, page_message, u'email', ri[RI_ROLE])
      if not pageToken:
        break
      try:
        response = callGAPI(cd.members(), u'list',
                            throw_reasons=GAPI_MEMBERS_THROW_REASONS, retry_reasons=GAPI_MEMBERS_RETRY_REASONS,
                            pageToken=pageToken,
                            groupKey=ri[RI_ENTITY], roles=ri[RI_ROLE], fields=u'nextPageToken,members(email,id,role)', maxResults=GC_Values[GC_MEMBER_MAX_RESULTS])
      except (GAPI_groupNotFound, GAPI_domainNotFound, GAPI_invalid, GAPI_forbidden) as e:
        entityActionFailedWarning([Entity.GROUP, ri[RI_ENTITY], ri[RI_ROLE], None], e.message, i, int(ri[RI_COUNT]))
        break
    _writeRowIfComplete(i)

  def _callbackProcessGroupSettings(request_id, response, exception):
    def _writeRowIfComplete(i):
      _printGroupRow(groupData[i][u'entity'], groupData[i][u'members'], groupData[i][u'settings'])
      del groupData[i]

    ri = request_id.splitlines()
    i = int(ri[RI_I])
    if exception is not None:
      http_status, reason, message = checkGAPIError(exception)
      if reason not in GAPI_DEFAULT_RETRY_REASONS+GAPI_GROUP_SETTINGS_RETRY_REASONS:
        errMsg = getHTTPError({}, http_status, reason, message)
        entityActionFailedWarning([Entity.GROUP, ri[RI_ENTITY], Entity.GROUP_SETTINGS, None], errMsg, i, int(ri[RI_COUNT]))
        _writeRowIfComplete(i)
        return
      waitOnFailure(1, 10, reason, message)
      try:
        response = callGAPI(gs.groups(), u'get',
                            soft_errors=True, throw_reasons=GAPI_GROUP_SETTINGS_THROW_REASONS, retry_reasons=GAPI_GROUP_SETTINGS_RETRY_REASONS,
                            groupUniqueId=ri[RI_ENTITY], fields=gsfields)
      except (GAPI_groupNotFound, GAPI_domainNotFound, GAPI_forbidden, GAPI_backendError, GAPI_systemError) as e:
        entityActionFailedWarning([Entity.GROUP, ri[RI_ENTITY], Entity.GROUP_SETTINGS, None], e.message, i, int(ri[RI_COUNT]))
    groupData[i][u'settings'] = response
    _writeRowIfComplete(i)

  cd = buildGAPIObject(DIRECTORY_API)
  getSettings = sortHeaders = False
  kwargs = {u'customer': GC_Values[GC_CUSTOMER_ID]}
  convertCRNL = GC_Values[GC_CSV_OUTPUT_CONVERT_CR_NL]
  delimiter = GC_Values[GC_CSV_OUTPUT_FIELD_DELIMITER]
  members = membersCountOnly = managers = managersCountOnly = owners = ownersCountOnly = False
  todrive = {}
  maxResults = None
  cdfieldsList = []
  gsfieldsList = []
  fieldsTitles = {}
  titles, csvRows = initializeTitlesCSVfile(None)
  addFieldTitleToCSVfile(u'email', GROUP_ARGUMENT_TO_PROPERTY_TITLE_MAP, cdfieldsList, fieldsTitles, titles)
  rolesList = []
  entitySelection = None
  groupData = {}
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'domain':
      kwargs[u'domain'] = getString(OB_DOMAIN_NAME).lower()
      kwargs.pop(u'customer', None)
    elif myarg == u'member':
      kwargs[u'userKey'] = getEmailAddress()
      kwargs.pop(u'customer', None)
    elif myarg == u'select':
      entitySelection = getEntityList(OB_GROUP_ENTITY)
    elif myarg == u'maxresults':
      maxResults = getInteger(minVal=1)
    elif myarg in [u'convertcrnl', u'converttextnl', u'convertfooternl']:
      convertCRNL = True
    elif myarg == u'delimiter':
      delimiter = getDelimiter()
    elif myarg == u'settings':
      getSettings = sortHeaders = True
    elif myarg == u'allfields':
      getSettings = sortHeaders = True
      cdfieldsList = []
      gsfieldsList = []
      fieldsTitles = {}
      for field in GROUP_ARGUMENT_TO_PROPERTY_TITLE_MAP:
        addFieldTitleToCSVfile(field, GROUP_ARGUMENT_TO_PROPERTY_TITLE_MAP, cdfieldsList, fieldsTitles, titles)
    elif myarg in GROUP_ARGUMENT_TO_PROPERTY_TITLE_MAP:
      addFieldTitleToCSVfile(myarg, GROUP_ARGUMENT_TO_PROPERTY_TITLE_MAP, cdfieldsList, fieldsTitles, titles)
    elif myarg in GROUP_ATTRIBUTES:
      addFieldToCSVfile(myarg, {myarg: [GROUP_ATTRIBUTES[myarg][0]]}, gsfieldsList, fieldsTitles, titles)
    elif myarg == u'fields':
      fieldNameList = getString(OB_FIELD_NAME_LIST)
      for field in fieldNameList.lower().replace(u',', u' ').split():
        if field in GROUP_ARGUMENT_TO_PROPERTY_TITLE_MAP:
          addFieldTitleToCSVfile(field, GROUP_ARGUMENT_TO_PROPERTY_TITLE_MAP, cdfieldsList, fieldsTitles, titles)
        elif field in GROUP_ATTRIBUTES:
          addFieldToCSVfile(field, {field: [GROUP_ATTRIBUTES[field][0]]}, gsfieldsList, fieldsTitles, titles)
        else:
          CLArgs.Backup()
          invalidChoiceExit(GROUP_ARGUMENT_TO_PROPERTY_TITLE_MAP.keys()+GROUP_ATTRIBUTES.keys())
    elif myarg in [u'members', u'memberscount']:
      rolesList.append(Entity.ROLE_MEMBER)
      members = True
      if myarg == u'memberscount':
        membersCountOnly = True
    elif myarg in [u'managers', u'managerscount']:
      rolesList.append(Entity.ROLE_MANAGER)
      managers = True
      if myarg == u'managerscount':
        managersCountOnly = True
    elif myarg in [u'owners', u'ownerscount']:
      rolesList.append(Entity.ROLE_OWNER)
      owners = True
      if myarg == u'ownerscount':
        ownersCountOnly = True
    elif myarg == u'countsonly':
      membersCountOnly = managersCountOnly = ownersCountOnly = True
    else:
      unknownArgumentExit()
  if cdfieldsList:
    cdfields = u','.join(set(cdfieldsList))
    cdfieldsnp = u'nextPageToken,groups({0})'.format(cdfields)
  else:
    cdfields = cdfieldsnp = None
  if gsfieldsList:
    getSettings = True
    gsfields = u','.join(set(gsfieldsList))
  else:
    gsfields = None
  if getSettings:
    gs = buildGAPIObject(GROUPSSETTINGS_API)
  roles = u','.join(sorted(set(rolesList)))
  rolesOrSettings = roles or getSettings
  if roles:
    if members:
      addTitlesToCSVfile([u'MembersCount',], titles)
      if not membersCountOnly:
        addTitlesToCSVfile([u'Members',], titles)
    if managers:
      addTitlesToCSVfile([u'ManagersCount',], titles)
      if not managersCountOnly:
        addTitlesToCSVfile([u'Managers',], titles)
    if owners:
      addTitlesToCSVfile([u'OwnersCount',], titles)
      if not ownersCountOnly:
        addTitlesToCSVfile([u'Owners',], titles)
  if entitySelection is None:
    printGettingAccountEntitiesInfo(Entity.GROUP, qualifier=queryQualifier(groupQuery(kwargs.get(u'domain'), kwargs.get(u'userKey'))))
    page_message = getPageMessage(showTotal=False, showFirstLastItems=True)
    try:
      entityList = callGAPIpages(cd.groups(), u'list', u'groups',
                                 page_message=page_message, message_attribute=u'email',
                                 throw_reasons=[GAPI_INVALID_MEMBER, GAPI_RESOURCE_NOT_FOUND, GAPI_DOMAIN_NOT_FOUND, GAPI_FORBIDDEN, GAPI_BAD_REQUEST],
                                 fields=cdfieldsnp, maxResults=maxResults, **kwargs)
    except GAPI_invalidMember:
      badRequestWarning(Entity.GROUP, Entity.MEMBER, kwargs[u'userKey'])
      entityList = collections.deque()
    except (GAPI_resourceNotFound, GAPI_domainNotFound, GAPI_forbidden, GAPI_badRequest):
      if kwargs.get(u'domain'):
        badRequestWarning(Entity.GROUP, Entity.DOMAIN, kwargs[u'domain'])
        entityList = collections.deque()
      else:
        accessErrorExit(cd)
  else:
    svcargs = dict([(u'groupKey', None), (u'fields', cdfields)]+GM_Globals[GM_EXTRA_ARGS_LIST])
    dbatch = googleapiclient.http.BatchHttpRequest(callback=_callbackProcessGroupBasic)
    bcount = 0
    entityList = collections.deque()
    i = 0
    count = len(entitySelection)
    for groupEntity in entitySelection:
      i += 1
      svcparms = svcargs.copy()
      svcparms[u'groupKey'] = normalizeEmailAddressOrUID(groupEntity)
      printGettingEntityItem(Entity.GROUP, svcparms[u'groupKey'], i, count)
      dbatch.add(cd.groups().get(**svcparms), request_id=batchRequestID(svcparms[u'groupKey'], i, count, 0, 0, None))
      bcount += 1
      if bcount >= GC_Values[GC_BATCH_SIZE]:
        dbatch.execute()
        dbatch = googleapiclient.http.BatchHttpRequest(callback=_callbackProcessGroupBasic)
        bcount = 0
    if bcount > 0:
      dbatch.execute()
  if roles:
    svcargs = dict([(u'groupKey', None), (u'roles', roles), (u'fields', u'nextPageToken,members(email,id,role)'), (u'maxResults', GC_Values[GC_MEMBER_MAX_RESULTS])]+GM_Globals[GM_EXTRA_ARGS_LIST])
  if getSettings:
    svcargsgs = dict([(u'groupUniqueId', None), (u'fields', gsfields)]+GM_Globals[GM_EXTRA_ARGS_LIST])
  dbatch = googleapiclient.http.BatchHttpRequest()
  bcount = 0
  groupData = {}
  i = 0
  count = len(entityList)
  for groupEntity in entityList:
    i += 1
    groupEmail = groupEntity[u'email']
    if not rolesOrSettings:
      _printGroupRow(groupEntity, None, None)
      continue
    groupData[i] = {u'entity': groupEntity, u'members': [], u'settings': getSettings}
    if roles:
      printGettingEntityItemForWhom(roles, groupEmail, i, count)
      svcparms = svcargs.copy()
      svcparms[u'groupKey'] = groupEmail
      dbatch.add(cd.members().list(**svcparms), callback=_callbackProcessGroupMembers, request_id=batchRequestID(groupEmail, i, count, 0, 0, None, roles))
      bcount += 1
    if getSettings:
      if not GroupIsAbuseOrPostmaster(groupEmail):
        printGettingEntityItemForWhom(Entity.GROUP_SETTINGS, groupEmail, i, count)
        svcparmsgs = svcargsgs.copy()
        svcparmsgs[u'groupUniqueId'] = groupEmail
        dbatch.add(gs.groups().get(**svcparmsgs), callback=_callbackProcessGroupSettings, request_id=batchRequestID(groupEmail, i, count, 0, 0, None))
        bcount += 1
      else:
        groupData[i][u'settings'] = False
    if bcount >= GC_Values[GC_BATCH_SIZE]:
      dbatch.execute()
      dbatch = googleapiclient.http.BatchHttpRequest()
      bcount = 0
  if bcount > 0:
    dbatch.execute()
  if sortHeaders:
    sortCSVTitles([u'Email',], titles)
  writeCSVfile(csvRows, titles, u'Groups', todrive)

def getGroupMembers(cd, groupEmail, membersList, membersSet, i, count, noduplicates, recursive, level):
  try:
    printGettingAllEntityItemsForWhom(Entity.MEMBER, groupEmail, i, count)
    groupMembers = callGAPIpages(cd.members(), u'list', u'members',
                                 throw_reasons=GAPI_MEMBERS_THROW_REASONS, retry_reasons=GAPI_MEMBERS_RETRY_REASONS,
                                 groupKey=groupEmail, fields=u'nextPageToken,members(email,id,role,status,type)', maxResults=GC_Values[GC_MEMBER_MAX_RESULTS])
    if not recursive:
      if noduplicates:
        for member in groupMembers:
          if member[u'id'] in membersSet:
            continue
          membersSet.add(member[u'id'])
          membersList.append(member)
      else:
        membersList.extend(groupMembers)
    else:
      for member in groupMembers:
        if member[u'type'] == u'USER':
          if noduplicates:
            if member[u'id'] in membersSet:
              continue
            membersSet.add(member[u'id'])
          member[u'level'] = level
          member[u'subgroup'] = groupEmail
          membersList.append(member)
        elif member[u'type'] == u'GROUP':
          getGroupMembers(cd, member[u'email'], membersList, membersSet, i, count, noduplicates, recursive, level+1)
  except (GAPI_groupNotFound, GAPI_domainNotFound, GAPI_invalid, GAPI_forbidden):
    entityUnknownWarning(Entity.GROUP, groupEmail, i, count)

GROUPMEMBERS_FIELD_NAMES_MAP = {
  u'email': u'email',
  u'groupemail': u'group',
  u'id': u'id',
  u'name': u'name',
  u'role': u'role',
  u'status': u'status',
  u'type': u'type',
  u'useremail': u'email',
  }

GROUPMEMBERS_DEFAULT_FIELDS = [u'id', u'role', u'group', u'email', u'type', u'status']

# gam print group-members|groups-members [todrive [<ToDriveAttributes>]] ([domain <DomainName>] [member <UserItem>])|[group <GroupItem>]|[select <GroupEntity>]
#	[membernames] <MemberFiledName>* [fields <MembersFieldNameList>] [noduplicates] [recursive]
def doPrintGroupMembers():
  cd = buildGAPIObject(DIRECTORY_API)
  groupname = membernames = noduplicates = recursive = False
  todrive = {}
  kwargs = {u'customer': GC_Values[GC_CUSTOMER_ID]}
  subTitle = u'{0} {1}'.format(PHRASE_ALL, Entity.Plural(Entity.GROUP))
  fieldsList = []
  fieldsTitles = {}
  titles, csvRows = initializeTitlesCSVfile(None)
  entityList = None
  userFieldsList = []
  userFieldsTitles = {}
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'domain':
      kwargs[u'domain'] = getString(OB_DOMAIN_NAME).lower()
      kwargs.pop(u'customer', None)
      subTitle = u'{0}={1}'.format(Entity.Singular(Entity.DOMAIN), kwargs[u'domain'])
    elif myarg == u'member':
      kwargs[u'userKey'] = getEmailAddress()
      kwargs.pop(u'customer', None)
      subTitle = u'{0}={1}'.format(Entity.Singular(Entity.MEMBER), kwargs[u'userKey'])
    elif myarg == u'group':
      entityList = [getEmailAddress()]
      subTitle = u'{0}={1}'.format(Entity.Singular(Entity.GROUP), entityList[0])
    elif myarg == u'select':
      entityList = getEntityList(OB_GROUP_ENTITY)
      subTitle = u'{0} {1}'.format(PHRASE_SELECTED, Entity.Plural(Entity.GROUP))
    elif myarg in GROUPMEMBERS_FIELD_NAMES_MAP:
      myarg = GROUPMEMBERS_FIELD_NAMES_MAP[myarg]
      addFieldToCSVfile(myarg, {myarg: [myarg]}, fieldsList, fieldsTitles, titles)
    elif myarg == u'fields':
      fieldNameList = getString(OB_FIELD_NAME_LIST)
      for field in fieldNameList.lower().replace(u',', u' ').split():
        if field in GROUPMEMBERS_FIELD_NAMES_MAP:
          field = GROUPMEMBERS_FIELD_NAMES_MAP[field]
          addFieldToCSVfile(field, {field: [field]}, fieldsList, fieldsTitles, titles)
        else:
          CLArgs.Backup()
          invalidChoiceExit(GROUPMEMBERS_FIELD_NAMES_MAP)
    elif myarg == u'membernames':
      membernames = True
    elif myarg == u'userfields':
      fieldNameList = getString(OB_FIELD_NAME_LIST)
      for field in fieldNameList.lower().replace(u',', u' ').split():
        if field in USER_ARGUMENT_TO_PROPERTY_MAP:
          addFieldToCSVfile(field, USER_ARGUMENT_TO_PROPERTY_MAP, userFieldsList, userFieldsTitles, titles)
        else:
          CLArgs.Backup()
          invalidChoiceExit(USER_ARGUMENT_TO_PROPERTY_MAP)
    elif myarg == u'noduplicates':
      noduplicates = True
    elif myarg == u'recursive':
      recursive = True
    else:
      unknownArgumentExit()
  if entityList is None:
    printGettingAccountEntitiesInfo(Entity.GROUP, qualifier=queryQualifier(groupQuery(kwargs.get(u'domain'), kwargs.get(u'userKey'))))
    page_message = getPageMessage(showTotal=False, showFirstLastItems=True)
    try:
      entityList = callGAPIpages(cd.groups(), u'list', u'groups',
                                 page_message=page_message, message_attribute=u'email',
                                 throw_reasons=[GAPI_INVALID_MEMBER, GAPI_RESOURCE_NOT_FOUND, GAPI_DOMAIN_NOT_FOUND, GAPI_FORBIDDEN, GAPI_BAD_REQUEST],
                                 fields=u'nextPageToken,groups(email)', **kwargs)
    except GAPI_invalidMember:
      badRequestWarning(Entity.GROUP, Entity.MEMBER, kwargs[u'userKey'])
      entityList = collections.deque()
    except (GAPI_resourceNotFound, GAPI_domainNotFound, GAPI_forbidden, GAPI_badRequest):
      if kwargs.get(u'domain'):
        badRequestWarning(Entity.GROUP, Entity.DOMAIN, kwargs[u'domain'])
        entityList = collections.deque()
      else:
        accessErrorExit(cd)
  if not fieldsList:
    for field in GROUPMEMBERS_DEFAULT_FIELDS:
      addFieldToCSVfile(field, {field: [field]}, fieldsList, fieldsTitles, titles)
  else:
    if u'name'in fieldsList:
      membernames = True
      fieldsList.remove(u'name')
  if u'group' in fieldsList:
    groupname = True
    fieldsList.remove(u'group')
  if userFieldsList:
    if not membernames and u'name.fullName' in userFieldsList:
      membernames = True
  if membernames:
    if u'name.fullName' not in userFieldsList:
      userFieldsList.append(u'name.fullName')
    addTitlesToCSVfile([u'name'], titles)
    removeTitlesFromCSVfile([u'name.fullName'], titles)
  userFields = u','.join(set(userFieldsList)).replace(u'.', u'/') if userFieldsList else None
  membersSet = set()
  level = 0
  i = 0
  count = len(entityList)
  for group in entityList:
    i += 1
    if isinstance(group, dict):
      groupEmail = group[u'email']
    else:
      groupEmail = convertGroupUIDtoEmailAddress(group)
    membersList = []
    getGroupMembers(cd, groupEmail, membersList, membersSet, i, count, noduplicates, recursive, level)
    for member in membersList:
      row = {}
      if groupname:
        row[u'group'] = groupEmail
      if recursive:
        row[u'level'] = member[u'level']
        row[u'subgroup'] = member[u'subgroup']
      for title in fieldsList:
        row[title] = member.get(title, u'')
      if userFieldsList:
        if membernames:
          row[u'name'] = u'Unknown'
        memberType = member.get(u'type')
        if memberType == u'USER':
          try:
            mbinfo = callGAPI(cd.users(), u'get',
                              throw_reasons=GAPI_USER_GET_THROW_REASONS,
                              userKey=member[u'id'], fields=userFields)
            if membernames:
              row[u'name'] = mbinfo[u'name'][u'fullName']
              del mbinfo[u'name'][u'fullName']
            addRowTitlesToCSVfile(flattenJSON(mbinfo, flattened=row), csvRows, titles)
            continue
          except (GAPI_userNotFound, GAPI_domainNotFound, GAPI_forbidden, GAPI_badRequest, GAPI_backendError, GAPI_systemError):
            pass
        elif memberType == u'GROUP':
          if membernames:
            try:
              row[u'name'] = callGAPI(cd.groups(), u'get',
                                      throw_reasons=GAPI_GROUP_GET_THROW_REASONS, retry_reasons=GAPI_GROUP_GET_RETRY_REASONS,
                                      groupKey=member[u'id'], fields=u'name')[u'name']
            except (GAPI_groupNotFound, GAPI_domainNotFound, GAPI_forbidden, GAPI_badRequest):
              pass
        elif memberType == u'CUSTOMER':
          if membernames:
            try:
              row[u'name'] = callGAPI(cd.customers(), u'get',
                                      throw_reasons=[GAPI_BAD_REQUEST, GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN],
                                      customerKey=member[u'id'], fields=u'customerDomain')[u'customerDomain']
            except (GAPI_badRequest, GAPI_resourceNotFound, GAPI_forbidden):
              pass
      csvRows.append(row)
  sortCSVTitles(GROUPMEMBERS_DEFAULT_FIELDS, titles)
  if recursive:
    removeTitlesFromCSVfile([u'level', u'subgroup'], titles)
    addTitlesToCSVfile([u'level', u'subgroup'], titles)
  writeCSVfile(csvRows, titles, u'Group Members ({0})'.format(subTitle), todrive)

# gam print licenses [todrive [<ToDriveAttributes>]] [(products|product <ProductIDList>)|(skus|sku <SKUIDList>)]
def doPrintLicenses(return_list=False, skus=None):
  lic = buildGAPIObject(LICENSING_API)
  products = []
  feed = collections.deque()
  if not return_list:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile([u'userId', u'productId', u'skuId', u'skuDisplay'])
    while CLArgs.ArgumentsRemaining():
      myarg = getArgument()
      if myarg == u'todrive':
        todrive = getTodriveParameters()
      elif myarg in [u'products', u'product']:
        products = getGoogleProductList()
        skus = []
      elif myarg in [u'sku', u'skus']:
        skus = getGoogleSKUList()
        products = []
      else:
        unknownArgumentExit()
  if not products and not skus:
    for sku in SKUS.values():
      if sku[u'product'] not in products:
        products.append(sku[u'product'])
    products.sort()
  if skus:
    for skuId in skus:
      Entity.SetGetting(Entity.LICENSE)
      page_message = getPageMessageForWhom(forWhom=skuId)
      try:
        productId, skuId = getProductAndSKU(skuId)
        feed += callGAPIpages(lic.licenseAssignments(), u'listForProductAndSku', u'items',
                              page_message=page_message,
                              throw_reasons=[GAPI_INVALID, GAPI_FORBIDDEN],
                              customerId=GC_Values[GC_DOMAIN], productId=productId, skuId=skuId, fields=u'nextPageToken,items(productId,skuId,userId)')
      except (GAPI_invalid, GAPI_forbidden):
        pass
  else:
    for productId in products:
      Entity.SetGetting(Entity.LICENSE)
      page_message = getPageMessageForWhom(forWhom=productId)
      try:
        feed += callGAPIpages(lic.licenseAssignments(), u'listForProduct', u'items',
                              page_message=page_message,
                              throw_reasons=[GAPI_INVALID, GAPI_FORBIDDEN],
                              customerId=GC_Values[GC_DOMAIN], productId=productId, fields=u'nextPageToken,items(productId,skuId,userId)')
      except (GAPI_invalid, GAPI_forbidden):
        pass
  if return_list:
    userSKUIds = {}
    while feed:
      u_license = feed.popleft()
      userId = u_license.get(u'userId', u'').lower()
      skuId = u_license.get(u'skuId')
      if userId and skuId:
        userSKUIds.setdefault(userId, [])
        userSKUIds[userId].append(skuId)
    return userSKUIds
  while feed:
    u_license = feed.popleft()
    userId = u_license.get(u'userId', u'').lower()
    skuId = u_license.get(u'skuId', u'')
    csvRows.append({u'userId': userId, u'productId': u_license.get(u'productId', u''),
                    u'skuId': skuId, u'skuDisplay': _skuIdToDisplayName(skuId)})
  writeCSVfile(csvRows, titles, u'Licenses', todrive)

# Notification commands utilities
READ_UNREAD_CHOICES = [u'read', u'unread',]

def getNotificationParameters(function):
  cd = buildGAPIObject(DIRECTORY_API)
  selected = False
  isUnread = None
  ids = []
  get_all = True
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in [u'unreadonly', u'unread']:
      isUnread = True
      selected = True
    elif myarg == u'read':
      isUnread = False
      selected = True
    elif myarg == u'id':
      notificationId = getString(OB_NOTIFICATION_ID)
      if notificationId.lower() == u'all':
        get_all = True
        isUnread = None
        selected = False
        ids = []
      else:
        get_all = False
        ids.append(notificationId)
    else:
      unknownArgumentExit()
  if not selected:
    if function == u'update':
      missingChoiceExit(READ_UNREAD_CHOICES)
  if get_all:
    fields = u'nextPageToken,items(notificationId,isUnread)' if function != u'info' else None
    try:
      notifications = callGAPIpages(cd.notifications(), u'list', u'items',
                                    throw_reasons=[GAPI_DOMAIN_NOT_FOUND, GAPI_BAD_REQUEST, GAPI_FORBIDDEN],
                                    customer=GC_Values[GC_CUSTOMER_ID], fields=fields)
      for notification in notifications:
        if function == u'update':
          if notification[u'isUnread'] != isUnread:
            ids.append(notification[u'notificationId'])
        elif (not selected) or (notification[u'isUnread'] == isUnread):
          ids.append(notification[u'notificationId'])
    except (GAPI_domainNotFound, GAPI_badRequest, GAPI_forbidden):
      accessErrorExit(cd)
  else:
    notifications = None
  return (cd, isUnread, ids, notifications)

# gam update notification|notifications (id all)|(id <NotificationID>)* unreadonly|unread|read
def doUpdateNotification():
  cd, isUnread, notificationIds, _ = getNotificationParameters(u'update')
  printKeyValueList([u'Marking', len(notificationIds), u'Notification(s) as', u'UNREAD' if isUnread else u'READ'])
  body = {u'isUnread': isUnread}
  i = 0
  count = len(notificationIds)
  for notificationId in notificationIds:
    i += 1
    try:
      result = callGAPI(cd.notifications(), u'patch',
                        throw_reasons=[GAPI_DOMAIN_NOT_FOUND, GAPI_INTERNAL_ERROR, GAPI_BAD_REQUEST, GAPI_FORBIDDEN],
                        customer=GC_Values[GC_CUSTOMER_ID], notificationId=notificationId,
                        body=body, fields=u'notificationId,isUnread')
      printEntityKVList([Entity.NOTIFICATION, result[u'notificationId']],
                        [PHRASE_MARKED_AS, [u'read', u'unread'][result[u'isUnread']]],
                        i, count)
    except (GAPI_domainNotFound, GAPI_internalError, GAPI_badRequest, GAPI_forbidden):
      checkEntityAFDNEorAccessErrorExit(cd, Entity.NOTIFICATION, notificationId, i, count)

# gam delete notification|notifications (id all)|(id <NotificationID>)* [unreadonly|unread|read]
def doDeleteNotification():
  cd, _, notificationIds, _ = getNotificationParameters(u'delete')
  printKeyValueList([u'Deleting', len(notificationIds), u'Notification(s)'])
  i = 0
  count = len(notificationIds)
  for notificationId in notificationIds:
    i += 1
    try:
      callGAPI(cd.notifications(), u'delete',
               throw_reasons=[GAPI_DOMAIN_NOT_FOUND, GAPI_INTERNAL_ERROR, GAPI_BAD_REQUEST, GAPI_FORBIDDEN],
               customer=GC_Values[GC_CUSTOMER_ID], notificationId=notificationId)
      entityActionPerformed([Entity.NOTIFICATION, notificationId], i, count)
    except (GAPI_domainNotFound, GAPI_internalError, GAPI_badRequest, GAPI_forbidden):
      checkEntityAFDNEorAccessErrorExit(cd, Entity.NOTIFICATION, notificationId, i, count)

# gam info notification|notifications (id all)|(id <NotificationID>)* [unreadonly|unread|read]
def doInfoNotifications():
  cd, _, notificationIds, notifications = getNotificationParameters(u'info')
  i = 0
  count = len(notificationIds)
  for notificationId in notificationIds:
    i += 1
    if not notifications:
      try:
        notification = callGAPI(cd.notifications(), u'get',
                                throw_reasons=[GAPI_DOMAIN_NOT_FOUND, GAPI_INTERNAL_ERROR, GAPI_BAD_REQUEST, GAPI_FORBIDDEN],
                                customer=GC_Values[GC_CUSTOMER_ID], notificationId=notificationId)
      except (GAPI_domainNotFound, GAPI_internalError, GAPI_badRequest, GAPI_forbidden):
        checkEntityAFDNEorAccessErrorExit(cd, Entity.NOTIFICATION, notificationId, i, count)
        continue
    else:
      for notification in notifications:
        if notification[u'notificationId'] == notificationId:
          break
    printEntity([Entity.NOTIFICATION, notification[u'notificationId']], i, count)
    Indent.Increment()
    printKeyValueList([u'From', notification[u'fromAddress']])
    printKeyValueList([u'Subject', notification[u'subject']])
    printKeyValueList([u'Date', formatLocalTime(notification[u'sendTime'])])
    printKeyValueList([u'Read Status', [u'READ', u'UNREAD'][notification[u'isUnread']]])
    Indent.Decrement()
    printBlankLine()
    printKeyValueList([dehtml(notification[u'body'])])
    printBlankLine()
    printKeyValueList([u'--------------'])
    printBlankLine()

def ACLRoleKeyValueList(rule):
  if rule[u'scope'][u'type'] != u'default':
    return [u'Scope', u'{0}:{1}'.format(rule[u'scope'][u'type'], rule[u'scope'][u'value']), u'Role', rule[u'role']]
  else:
    return [u'Scope', u'{0}'.format(rule[u'scope'][u'type']), u'Role', rule[u'role']]

def formatACLRule(rule):
  return formatKeyValueList(u'(', ACLRoleKeyValueList(rule), u')')

def formatACLScopeRole(scope, role):
  if role:
    return formatKeyValueList(u'(', [u'Scope', scope, u'Role', role], u')')
  else:
    return formatKeyValueList(u'(', [u'Scope', scope], u')')

def normalizeRuleId(ruleId):
  ruleIdParts = ruleId.split(u':')
  if (len(ruleIdParts) == 1) or (len(ruleIdParts[1]) == 0):
    if ruleIdParts[0] == u'default':
      return ruleId
    if ruleIdParts[0] == u'domain':
      return u'{0}:{1}'.format(u'domain', GC_Values[GC_DOMAIN])
    return u'{0}:{1}'.format(u'user', normalizeEmailAddressOrUID(ruleIdParts[0], noUid=True))
  if ruleIdParts[0] in [u'user', u'group']:
    return u'{0}:{1}'.format(ruleIdParts[0], normalizeEmailAddressOrUID(ruleIdParts[1], noUid=True))
  return ruleId

def makeRoleRuleIdBody(role, ruleId):
  ruleIdParts = ruleId.split(u':')
  if len(ruleIdParts) == 1:
    if ruleIdParts[0] == u'default':
      return {u'role': role, u'scope': {u'type': ruleIdParts[0]}}
    if ruleIdParts[0] == u'domain':
      return {u'role': role, u'scope': {u'type': ruleIdParts[0], u'value': GC_Values[GC_DOMAIN]}}
    return {u'role': role, u'scope': {u'type': u'user', u'value': ruleIdParts[0]}}
  return {u'role': role, u'scope': {u'type': ruleIdParts[0], u'value': ruleIdParts[1]}}

# gam create resource <ResourceID> <String> [description <String>] [type <String>]
def doCreateResourceCalendar():
  cd = buildGAPIObject(DIRECTORY_API)
  body = {u'resourceId': getString(OB_RESOURCE_ID),
          u'resourceName': getString(OB_NAME)}
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'description':
      body[u'resourceDescription'] = getString(OB_STRING, minLen=0).replace(u'\\n', u'\n')
    elif myarg == u'type':
      body[u'resourceType'] = getString(OB_STRING)
    else:
      unknownArgumentExit()
  try:
    callGAPI(cd.resources().calendars(), u'insert',
             throw_reasons=[GAPI_INVALID, GAPI_DUPLICATE, GAPI_BAD_REQUEST, GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN],
             customer=GC_Values[GC_CUSTOMER_ID], body=body, fields=u'')
    entityActionPerformed([Entity.RESOURCE_CALENDAR, body[u'resourceId']])
  except GAPI_invalid as e:
    entityActionFailedWarning([Entity.RESOURCE_CALENDAR, body[u'resourceId']], e.message)
  except GAPI_duplicate:
    entityDuplicateWarning(Entity.RESOURCE_CALENDAR, body[u'resourceId'])
  except (GAPI_badRequest, GAPI_resourceNotFound, GAPI_forbidden):
    accessErrorExit(cd)

def _doUpdateResourceCalendars(entityList):
  cd = buildGAPIObject(DIRECTORY_API)
  body = {}
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'name':
      body[u'resourceName'] = getString(OB_STRING)
    elif myarg == u'description':
      body[u'resourceDescription'] = getString(OB_STRING, minLen=0).replace(u'\\n', u'\n')
    elif myarg == u'type':
      body[u'resourceType'] = getString(OB_STRING)
    else:
      unknownArgumentExit()
  i = 0
  count = len(entityList)
  for resourceId in entityList:
    i += 1
    try:
      callGAPI(cd.resources().calendars(), u'patch',
               throw_reasons=[GAPI_INVALID, GAPI_BAD_REQUEST, GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN],
               customer=GC_Values[GC_CUSTOMER_ID], calendarResourceId=resourceId, body=body, fields=u'')
      entityActionPerformed([Entity.RESOURCE_CALENDAR, resourceId], i, count)
    except GAPI_invalid as e:
      entityActionFailedWarning([Entity.RESOURCE_CALENDAR, resourceId], e.message, i, count)
    except (GAPI_badRequest, GAPI_resourceNotFound, GAPI_forbidden):
      checkEntityAFDNEorAccessErrorExit(cd, Entity.RESOURCE_CALENDAR, resourceId, i, count)

# gam update resources <ResourceEntity> [name <String>] [description <String>] [type <String>]
def doUpdateResourceCalendars():
  _doUpdateResourceCalendars(getEntityList(OB_RESOURCE_ENTITY))

# gam update resource <ResourceID> [name <String>] [description <String>] [type <String>]
def doUpdateResourceCalendar():
  _doUpdateResourceCalendars(getStringReturnInList(OB_RESOURCE_ID))

def _doDeleteResourceCalendars(entityList):
  cd = buildGAPIObject(DIRECTORY_API)
  checkForExtraneousArguments()
  i = 0
  count = len(entityList)
  for resourceId in entityList:
    i += 1
    try:
      callGAPI(cd.resources().calendars(), u'delete',
               throw_reasons=[GAPI_BAD_REQUEST, GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN],
               customer=GC_Values[GC_CUSTOMER_ID], calendarResourceId=resourceId)
      entityActionPerformed([Entity.RESOURCE_CALENDAR, resourceId], i, count)
    except (GAPI_badRequest, GAPI_resourceNotFound, GAPI_forbidden):
      checkEntityAFDNEorAccessErrorExit(cd, Entity.RESOURCE_CALENDAR, resourceId, i, count)

# gam delete resources <ResourceEntity>
def doDeleteResourceCalendars():
  _doDeleteResourceCalendars(getEntityList(OB_RESOURCE_ENTITY))

# gam delete resource <ResourceID>
def doDeleteResourceCalendar():
  _doDeleteResourceCalendars(getStringReturnInList(OB_RESOURCE_ID))

RESOURCE_ALLFIELDS = [u'resourceId', u'resourceName', u'resourceEmail', u'resourceDescription', u'resourceType',]
RESOURCE_FIELDS_WITH_CRS_NLS = [u'resourceDescription',]

def _showResource(resource, i, count, acls=None):

  def _showResourceField(title, resource, field):
    if field in resource:
      if field not in RESOURCE_FIELDS_WITH_CRS_NLS:
        printKeyValueList([title, resource[field]])
      else:
        printKeyValueList([title, convertCRsNLs(resource[field])])

  resourceId = resource.get(u'resourceId')
  if resourceId:
    printEntity([Entity.RESOURCE_ID, resource[u'resourceId']], i, count)
  else:
    printEntity([Entity.RESOURCE_CALENDAR, None], i, count)
  Indent.Increment()
  _showResourceField(u'Name', resource, u'resourceName')
  _showResourceField(u'Email', resource, u'resourceEmail')
  _showResourceField(u'Type', resource, u'resourceType')
  _showResourceField(u'Description', resource, u'resourceDescription')
  if acls:
    j = 0
    jcount = len(acls)
    for rule in acls:
      j += 1
      printEntity([Entity.CALENDAR_ACL, formatACLScopeRole(rule[u'id'], rule[u'role'])], j, jcount)
  Indent.Decrement()

def _doInfoResourceCalendars(entityList):
  cd = buildGAPIObject(DIRECTORY_API)
  checkForExtraneousArguments()
  i = 0
  count = len(entityList)
  for resourceId in entityList:
    i += 1
    try:
      resource = callGAPI(cd.resources().calendars(), u'get',
                          throw_reasons=[GAPI_BAD_REQUEST, GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN],
                          customer=GC_Values[GC_CUSTOMER_ID], calendarResourceId=resourceId, fields=u','.join(RESOURCE_ALLFIELDS))
      _showResource(resource, i, count)
    except (GAPI_badRequest, GAPI_resourceNotFound, GAPI_forbidden):
      checkEntityAFDNEorAccessErrorExit(cd, Entity.RESOURCE_CALENDAR, resourceId, i, count)

# gam info resources <ResourceEntity>
def doInfoResourceCalendars():
  _doInfoResourceCalendars(getEntityList(OB_RESOURCE_ENTITY))

# gam info resource <ResourceID>
def doInfoResourceCalendar():
  _doInfoResourceCalendars(getStringReturnInList(OB_RESOURCE_ID))

RESOURCE_ARGUMENT_TO_PROPERTY_MAP = {
  u'description': [u'resourceDescription'],
  u'email': [u'resourceEmail'],
  u'id': [u'resourceId'],
  u'name': [u'resourceName'],
  u'type': [u'resourceType'],
  }

def _doPrintShowResourceCalendars(csvFormat):
  cd = buildGAPIObject(DIRECTORY_API)
  convertCRNL = GC_Values[GC_CSV_OUTPUT_CONVERT_CR_NL]
  showPermissions = False
  acls = None
  fieldsList = []
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile(None)
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'allfields':
      fieldsList = RESOURCE_ALLFIELDS
    elif myarg in [CL_OB_ACLS, CL_OB_CALENDARACLS, CL_OB_PERMISSIONS]:
      showPermissions = True
    elif myarg in RESOURCE_ARGUMENT_TO_PROPERTY_MAP:
      fieldsList.extend(RESOURCE_ARGUMENT_TO_PROPERTY_MAP[myarg])
    elif myarg == u'fields':
      for field in getString(OB_FIELD_NAME_LIST).lower().replace(u',', u' ').split():
        if field == u'acls':
          showPermissions = True
        elif field in RESOURCE_ARGUMENT_TO_PROPERTY_MAP:
          fieldsList.extend(RESOURCE_ARGUMENT_TO_PROPERTY_MAP[field])
        else:
          CLArgs.Backup()
          invalidChoiceExit(RESOURCE_ARGUMENT_TO_PROPERTY_MAP)
    elif myarg in [u'convertcrnl', u'converttextnl']:
      convertCRNL = True
    else:
      unknownArgumentExit()
  if not fieldsList:
    fieldsList = RESOURCE_ALLFIELDS
  if csvFormat:
    addTitlesToCSVfile(fieldsList, titles)
  if showPermissions:
    cal = buildGAPIObject(CALENDAR_API)
    fields = u'nextPageToken,items({0})'.format(u','.join(set(fieldsList+[u'resourceEmail',])))
  else:
    fields = u'nextPageToken,items({0})'.format(u','.join(set(fieldsList)))
  printGettingAccountEntitiesInfo(Entity.RESOURCE_CALENDAR)
  try:
    page_message = getPageMessage(showTotal=False, showFirstLastItems=True)
    resources = callGAPIpages(cd.resources().calendars(), u'list', u'items',
                              page_message=page_message, message_attribute=u'resourceName',
                              throw_reasons=[GAPI_BAD_REQUEST, GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN],
                              customer=GC_Values[GC_CUSTOMER_ID], fields=fields)
    i = 0
    count = len(resources)
    for resource in resources:
      i += 1
      if showPermissions:
        acls = callGAPIpages(cal.acl(), u'list', u'items',
                             throw_reasons=[GAPI_NOT_FOUND, GAPI_FORBIDDEN],
                             calendarId=resource[u'resourceEmail'], fields=u'nextPageToken,items(id,role,scope)')
      if not csvFormat:
        _showResource(resource, i, count, acls)
      else:
        row = {}
        for field in fieldsList:
          if convertCRNL and field in RESOURCE_FIELDS_WITH_CRS_NLS:
            row[field] = convertCRsNLs(resource.get(field, u''))
          else:
            row[field] = resource.get(field, u'')
        if showPermissions:
          for rule in acls:
            addRowTitlesToCSVfile(flattenJSON(rule, flattened=row.copy()), csvRows, titles)
        else:
          csvRows.append(row)
  except (GAPI_badRequest, GAPI_resourceNotFound, GAPI_forbidden):
    accessErrorExit(cd)
  if csvFormat:
    sortCSVTitles(RESOURCE_ALLFIELDS, titles)
    writeCSVfile(csvRows, titles, u'Resources', todrive)

# gam show resources [allfields|<ResourceFieldName>*|(fields <ResourceFieldNameList>)] [acls] [convertcrnl]
def doShowResourceCalendars():
  _doPrintShowResourceCalendars(False)

# gam print resources [todrive [<ToDriveAttributes>]] [allfields|<ResourceFieldName>*|(fields <ResourceFieldNameList>)] [acls] [convertcrnl]
def doPrintResourceCalendars():
  _doPrintShowResourceCalendars(True)

# Calendar commands utilities
def normalizeCalendarId(calId, user):
  if not user or calId.lower() != u'primary':
    return normalizeEmailAddressOrUID(calId)
  return user

def checkCalendarExists(cal, calId, showMessage=False):
  if cal is None:
    cal = buildGAPIObject(CALENDAR_API)
  try:
    return callGAPI(cal.calendars(), u'get',
                    throw_reasons=GAPI_CALENDAR_THROW_REASONS+[GAPI_NOT_FOUND],
                    calendarId=calId, fields=u'id')[u'id']
  except (GAPI_serviceNotAvailable, GAPI_authError, GAPI_notACalendarUser, GAPI_notFound) as e:
    if showMessage:
      entityActionFailedWarning([Entity.CALENDAR, calId], e.message)
    return None

def validateCalendar(calId, i=0, count=0):
  calId, cal = buildGAPIServiceObject(CALENDAR_API, calId)
  if not cal:
    return (calId, None)
  try:
    callGAPI(cal.calendars(), u'get',
             throw_reasons=GAPI_CALENDAR_THROW_REASONS+[GAPI_NOT_FOUND],
             calendarId=calId, fields=u'')
    return (calId, cal)
  except (GAPI_notACalendarUser, GAPI_notFound) as e:
    entityActionFailedWarning([Entity.CALENDAR, calId], e.message, i, count)
  except (GAPI_serviceNotAvailable, GAPI_authError):
    entityServiceNotApplicableWarning(Entity.CALENDAR, calId, i, count)
  return (calId, None)

CALENDAR_ACL_ROLES_MAP = {
  u'editor': u'writer',
  u'freebusy': u'freeBusyReader',
  u'freebusyreader': u'freeBusyReader',
  u'owner': u'owner',
  u'read': u'reader',
  u'reader': u'reader',
  u'writer': u'writer',
  u'none': u'none',
  }

ACL_SCOPE_CHOICES = [u'default', u'user', u'group', u'domain',] # default must be first element

def getACLScope():
  scopeType, scopeValue = getChoiceAndValue(OB_ACL_SCOPE, ACL_SCOPE_CHOICES[1:], u':')
  if scopeType:
    if scopeType != u'domain':
      scopeValue = normalizeEmailAddressOrUID(scopeValue, noUid=True)
    else:
      scopeValue = scopeValue.lower()
    return (scopeType, scopeValue)
  scopeType = getChoice(ACL_SCOPE_CHOICES, defaultChoice=u'user')
  if scopeType == u'domain':
    entity = getString(OB_DOMAIN_NAME, optional=True)
    if entity:
      scopeValue = entity.lower()
    else:
      scopeValue = GC_Values[GC_DOMAIN]
  elif scopeType != u'default':
    scopeValue = getEmailAddress(noUid=True)
  else:
    scopeValue = None
  return (scopeType, scopeValue)

def getCalendarACLScope():
  scopeType, scopeValue = getACLScope()
  if scopeType != u'default':
    return {u'list': [u'{0}:{1}'.format(scopeType, scopeValue)], u'dict': None}
  return {u'list': [scopeType], u'dict': None}

def getCalendarSiteACLScopeEntity():
  ACLScopeEntity = {u'list': getEntityList(OB_ACL_SCOPE_ENTITY), u'dict': None}
  if isinstance(ACLScopeEntity[u'list'], dict):
    ACLScopeEntity[u'dict'] = ACLScopeEntity[u'list']
  return ACLScopeEntity

def _normalizeCalIdGetRuleIds(origUser, user, cal, calId, j, jcount, ACLScopeEntity):
  if ACLScopeEntity[u'dict']:
    if origUser:
      if not GM_Globals[GM_CSV_SUBKEY_FIELD]:
        ruleIds = ACLScopeEntity[u'dict'][calId]
      else:
        ruleIds = ACLScopeEntity[u'dict'][origUser][calId]
    else:
      ruleIds = ACLScopeEntity[u'dict'][calId]
  else:
    ruleIds = ACLScopeEntity[u'list']
  calId = normalizeCalendarId(calId, user)
  kcount = len(ruleIds)
  entityPerformActionNumItems([Entity.CALENDAR, calId], kcount, Entity.CALENDAR_ACL, j, jcount)
  if kcount == 0:
    setSysExitRC(NO_ENTITIES_FOUND)
  return (calId, cal, ruleIds, kcount)

def _processCalendarACLs(cal, function, entityType, calId, j, jcount, k, kcount, ruleId, role, body):
  result = True
  kwargs = {}
  if function in [u'insert', u'patch']:
    kwargs[u'body'] = body
    kwargs[u'fields'] = u''
  if function in [u'patch', u'delete']:
    kwargs[u'ruleId'] = ruleId
  try:
    callGAPI(cal.acl(), function,
             throw_reasons=[GAPI_NOT_FOUND, GAPI_INVALID, GAPI_INVALID_PARAMETER, GAPI_INVALID_SCOPE_VALUE,
                            GAPI_ILLEGAL_ACCESS_ROLE_FOR_DEFAULT, GAPI_CANNOT_CHANGE_OWN_ACL, GAPI_CANNOT_CHANGE_OWNER_ACL, GAPI_FORBIDDEN],
             calendarId=calId, **kwargs)
    entityActionPerformed([entityType, calId, Entity.CALENDAR_ACL, formatACLScopeRole(ruleId, role)], k, kcount)
  except GAPI_notFound as e:
    if not checkCalendarExists(cal, calId):
      entityUnknownWarning(entityType, calId, j, jcount)
      result = False
    else:
      entityActionFailedWarning([entityType, calId, Entity.CALENDAR_ACL, formatACLScopeRole(ruleId, role)], e.message, k, kcount)
  except (GAPI_invalid, GAPI_invalidParameter, GAPI_invalidScopeValue,
          GAPI_illegalAccessRoleForDefault, GAPI_forbidden, GAPI_cannotChangeOwnAcl, GAPI_cannotChangeOwnerAcl) as e:
    entityActionFailedWarning([entityType, calId, Entity.CALENDAR_ACL, formatACLScopeRole(ruleId, role)], e.message, k, kcount)
  return result

def _addCalendarACLs(cal, entityType, calId, j, jcount, role, ruleIds, kcount):
  Indent.Increment()
  k = 0
  for ruleId in ruleIds:
    k += 1
    ruleId = normalizeRuleId(ruleId)
    if not _processCalendarACLs(cal, u'insert', entityType, calId, j, jcount, k, kcount, ruleId, role, makeRoleRuleIdBody(role, ruleId)):
      break
  Indent.Decrement()

def _doCalendarsAddACLs(origUser, user, cal, calIds, count, role, ACLScopeEntity):
  i = 0
  for calId in calIds:
    i += 1
    calId, cal, ruleIds, jcount = _normalizeCalIdGetRuleIds(origUser, user, cal, calId, i, count, ACLScopeEntity)
    if jcount == 0:
      continue
    _addCalendarACLs(cal, Entity.CALENDAR, calId, i, count, role, ruleIds, jcount)

def _updateDeleteCalendarACLs(cal, function, entityType, calId, j, jcount, role, body, ruleIds, kcount):
  Indent.Increment()
  k = 0
  for ruleId in ruleIds:
    k += 1
    ruleId = normalizeRuleId(ruleId)
    if not _processCalendarACLs(cal, function, entityType, calId, j, jcount, k, kcount, ruleId, role, body):
      break
  Indent.Decrement()

def _doUpdateDeleteCalendarACLs(origUser, user, cal, function, calIds, count, ACLScopeEntity, role, body):
  i = 0
  for calId in calIds:
    i += 1
    calId, cal, ruleIds, jcount = _normalizeCalIdGetRuleIds(origUser, user, cal, calId, i, count, ACLScopeEntity)
    if jcount == 0:
      continue
    _updateDeleteCalendarACLs(cal, function, Entity.CALENDAR, calId, i, count, role, body, ruleIds, jcount)

def _infoCalendarACLs(cal, entityType, calId, j, jcount, ruleIds, kcount):
  Indent.Increment()
  k = 0
  for ruleId in ruleIds:
    k += 1
    ruleId = normalizeRuleId(ruleId)
    try:
      result = callGAPI(cal.acl(), u'get',
                        throw_reasons=[GAPI_NOT_FOUND, GAPI_INVALID, GAPI_INVALID_SCOPE_VALUE, GAPI_FORBIDDEN],
                        calendarId=calId, ruleId=ruleId, fields=u'id,role')
      printEntity([entityType, calId, Entity.CALENDAR_ACL, formatACLScopeRole(result[u'id'], result[u'role'])], k, kcount)
    except (GAPI_notFound, GAPI_invalid) as e:
      if not checkCalendarExists(cal, calId):
        entityUnknownWarning(entityType, calId, j, jcount)
        break
      else:
        entityActionFailedWarning([entityType, calId, Entity.CALENDAR_ACL, formatACLScopeRole(ruleId, None)], e.message, k, kcount)
    except (GAPI_invalidScopeValue, GAPI_forbidden) as e:
      entityActionFailedWarning([entityType, calId, Entity.CALENDAR_ACL, formatACLScopeRole(ruleId, None)], e.message, k, kcount)
  Indent.Decrement()

def _doInfoCalendarACLs(origUser, user, cal, calIds, count, ACLScopeEntity):
  i = 0
  for calId in calIds:
    i += 1
    calId, cal, ruleIds, jcount = _normalizeCalIdGetRuleIds(origUser, user, cal, calId, i, count, ACLScopeEntity)
    if jcount == 0:
      continue
    _infoCalendarACLs(cal, Entity.CALENDAR, calId, i, count, ruleIds, jcount)

def _doPrintShowCalendarACLs(user, cal, calIds, count, csvFormat, csvRows, titles):
  i = 0
  for calId in calIds:
    i += 1
    calId = convertUserUIDtoEmailAddress(calId)
    try:
      acls = callGAPIpages(cal.acl(), u'list', u'items',
                           throw_reasons=[GAPI_NOT_FOUND, GAPI_FORBIDDEN],
                           calendarId=calId, fields=u'nextPageToken,items(id,role,scope)')
      jcount = len(acls)
      if not csvFormat:
        entityPerformActionNumItems([Entity.CALENDAR, calId], jcount, Entity.CALENDAR_ACL, i, count)
      if jcount == 0:
        setSysExitRC(NO_ENTITIES_FOUND)
        continue
      if not csvFormat:
        Indent.Increment()
        j = 0
        for rule in acls:
          j += 1
          printEntity([Entity.CALENDAR, calId, Entity.CALENDAR_ACL, formatACLRule(rule)], j, jcount)
        Indent.Decrement()
      else:
        for rule in acls:
          flattened = {u'calendarId': calId}
          if user:
            flattened[u'primaryEmail'] = user
          addRowTitlesToCSVfile(flattenJSON(rule, flattened=flattened), csvRows, titles)
    except GAPI_forbidden as e:
      entityActionFailedWarning([Entity.CALENDAR, calId], e.message, i, count)
    except GAPI_notFound:
      entityUnknownWarning(Entity.CALENDAR, calId, i, count)

# gam calendar <CalendarItem> add <CalendarACLRole> <ACLScope>
def doCalendarsAddACL(cal, calIds):
  role = getChoice(CALENDAR_ACL_ROLES_MAP, mapChoice=True)
  ACLScopeEntity = getCalendarACLScope()
  checkForExtraneousArguments()
  _doCalendarsAddACLs(None, None, cal, calIds, len(calIds), role, ACLScopeEntity)

# gam calendars <CalendarEntity> add acls <CalendarACLRole> <ACLScopeEntity>
def doCalendarsAddACLs(cal, calIds):
  role = getChoice(CALENDAR_ACL_ROLES_MAP, mapChoice=True)
  ACLScopeEntity = getCalendarSiteACLScopeEntity()
  checkForExtraneousArguments()
  _doCalendarsAddACLs(None, None, cal, calIds, len(calIds), role, ACLScopeEntity)

# gam calendar <CalendarItem> update <CalendarACLRole> <ACLScope>
def doCalendarsUpdateACL(cal, calIds):
  body = {u'role': getChoice(CALENDAR_ACL_ROLES_MAP, mapChoice=True)}
  ACLScopeEntity = getCalendarACLScope()
  checkForExtraneousArguments()
  _doUpdateDeleteCalendarACLs(None, None, cal, u'patch', calIds, len(calIds), ACLScopeEntity, body[u'role'], body)

# gam calendars <CalendarEntity> update acls <CalendarACLRole> <ACLScopeEntity>
def doCalendarsUpdateACLs(cal, calIds):
  body = {u'role': getChoice(CALENDAR_ACL_ROLES_MAP, mapChoice=True)}
  ACLScopeEntity = getCalendarSiteACLScopeEntity()
  checkForExtraneousArguments()
  _doUpdateDeleteCalendarACLs(None, None, cal, u'patch', calIds, len(calIds), ACLScopeEntity, body[u'role'], body)

# gam calendar <CalendarItem> del|delete [<CalendarACLRole>] <ACLScope>
def doCalendarsDeleteACL(cal, calIds):
  role = getChoice(CALENDAR_ACL_ROLES_MAP, defaultChoice=None, mapChoice=True)
  ACLScopeEntity = getCalendarACLScope()
  checkForExtraneousArguments()
  _doUpdateDeleteCalendarACLs(None, None, cal, u'delete', calIds, len(calIds), ACLScopeEntity, role, {})

# gam calendars <CalendarEntity> del|delete acls <ACLScopeEntity>
def doCalendarsDeleteACLs(cal, calIds):
  role = getChoice(CALENDAR_ACL_ROLES_MAP, defaultChoice=None, mapChoice=True)
  ACLScopeEntity = getCalendarSiteACLScopeEntity()
  checkForExtraneousArguments()
  _doUpdateDeleteCalendarACLs(None, None, cal, u'delete', calIds, len(calIds), ACLScopeEntity, role, {})

# gam calendars <CalendarEntity> info acl|acls <ACLScopeEntity>
def doCalendarsInfoACLs(cal, calIds):
  ACLScopeEntity = getCalendarSiteACLScopeEntity()
  checkForExtraneousArguments()
  _doInfoCalendarACLs(None, None, cal, calIds, len(calIds), ACLScopeEntity)

def doCalendarsPrintShowACLs(cal, calIds, csvFormat):
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile(None)
  else:
    titles = csvRows = None
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    else:
      unknownArgumentExit()
  _doPrintShowCalendarACLs(None, cal, calIds, len(calIds), csvFormat, csvRows, titles)
  if csvFormat:
    sortCSVTitles([u'calendarId', ], titles)
    writeCSVfile(csvRows, titles, u'Calendar ACLs', todrive)

# gam calendars <CalendarEntity> print acls
def doCalendarsPrintACLs(cal, calIds):
  checkForExtraneousArguments()
  doCalendarsPrintShowACLs(cal, calIds, True)

# gam calendars <CalendarEntity> show acls
# gam calendar <CalendarItem> showacl
def doCalendarsShowACLs(cal, calIds):
  checkForExtraneousArguments()
  doCalendarsPrintShowACLs(cal, calIds, False)

LIST_EVENTS_DISPLAY_PROPERTIES = {
  u'alwaysincludeemail': (u'alwaysIncludeEmail', {GC_VAR_TYPE: GC_TYPE_BOOLEAN}),
  u'icaluid': (u'iCalUID', {GC_VAR_TYPE: GC_TYPE_STRING}),
  u'maxattendees': (u'maxAttendees', {GC_VAR_TYPE: GC_TYPE_INTEGER}),
  u'orderby': (u'orderBy', {GC_VAR_TYPE: GC_TYPE_CHOICE, u'choices': {u'starttime': u'startTime', u'updated': u'updated'}}),
  u'timezone': (u'timeZone', {GC_VAR_TYPE: GC_TYPE_STRING}),
  }

LIST_EVENTS_SELECT_PROPERTIES = {
  u'endtime': (u'timeMax', {GC_VAR_TYPE: GC_TYPE_DATETIME}),
  u'privateextendedproperty': (u'privateExtendedProperty', {GC_VAR_TYPE: GC_TYPE_STRING}),
  u'sharedextendedproperty': (u'sharedExtendedProperty', {GC_VAR_TYPE: GC_TYPE_STRING}),
  u'showdeletedevents': (u'showDeleted', {GC_VAR_TYPE: GC_TYPE_BOOLEAN}),
  u'showhiddeninvitations': (u'showHiddenInvitations', {GC_VAR_TYPE: GC_TYPE_BOOLEAN}),
  u'singleevents': (u'singleEvents', {GC_VAR_TYPE: GC_TYPE_BOOLEAN}),
  u'starttime': (u'timeMin', {GC_VAR_TYPE: GC_TYPE_DATETIME}),
  u'timemax': (u'timeMax', {GC_VAR_TYPE: GC_TYPE_DATETIME}),
  u'timemin': (u'timeMin', {GC_VAR_TYPE: GC_TYPE_DATETIME}),
  u'updatedmin': (u'updatedMin', {GC_VAR_TYPE: GC_TYPE_DATETIME}),
  }

LIST_EVENTS_MATCH_FIELDS = {
  u'attendees': [u'attendees',],
  u'description': [u'description',],
  u'location': [u'location',],
  u'summary': [u'summary',],
  u'creatorname': [u'creator', u'displayName'],
  u'creatoremail': [u'creator', u'email'],
  u'organizername': [u'organizer', u'displayName'],
  u'organizeremail': [u'organizer', u'email'],
  }

def _getCalendarListEventsProperty(myarg, attributes, kwargs):
  attrName, attribute = attributes.get(myarg, (None, None))
  if not attrName:
    return False
  attrType = attribute[GC_VAR_TYPE]
  if attrType == GC_TYPE_BOOLEAN:
    kwargs[attrName] = True
  elif attrType == GC_TYPE_STRING:
    kwargs[attrName] = getString(OB_STRING)
  elif attrType == GC_TYPE_CHOICE:
    kwargs[attrName] = getChoice(attribute[u'choices'], mapChoice=True)
  elif attrType == GC_TYPE_DATETIME:
    kwargs[attrName] = getFullTime()
  else: # GC_TYPE_INTEGER
    kwargs[attrName] = getInteger()
  return True

def _getCalendarListEventsDisplayProperty(myarg, calendarEventEntity):
  return _getCalendarListEventsProperty(myarg, LIST_EVENTS_DISPLAY_PROPERTIES, calendarEventEntity[u'kwargs'])

def initCalendarEventEntity():
  return {u'list': [], u'queries': [], u'kwargs': {}, u'dict': None, u'matches': []}

def getCalendarEventEntity(noIds=False):
  calendarEventEntity = initCalendarEventEntity()
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in [u'event', u'events']:
      if noIds:
        unknownArgumentExit()
      entitySelector = getEntitySelector()
      if entitySelector:
        entityList = getEntitySelection(entitySelector, False)
        if isinstance(entityList, dict):
          calendarEventEntity[u'dict'] = entityList
        else:
          calendarEventEntity[u'list'] = entityList
      else:
        calendarEventEntity[u'list'].extend(convertEntityToList(getString(OB_EVENT_ID)))
    elif myarg in [u'q', u'query', u'eventquery']:
      calendarEventEntity[u'queries'].append(getString(OB_QUERY))
    elif myarg == u'matchfield':
      matchField = getChoice(LIST_EVENTS_MATCH_FIELDS, mapChoice=True)
      if matchField[0] != u'attendees':
        matchPattern = getREPattern()
      else:
        matchPattern = convertEntityToList(getString(OB_EMAIL_ADDRESS, minLen=0))
      calendarEventEntity[u'matches'].append((matchField, matchPattern))
    elif _getCalendarListEventsProperty(myarg, LIST_EVENTS_SELECT_PROPERTIES, calendarEventEntity[u'kwargs']):
      pass
    else:
      CLArgs.Backup()
      break
  return calendarEventEntity

#
CALENDAR_MIN_COLOR_INDEX = 1
CALENDAR_MAX_COLOR_INDEX = 24

CALENDAR_EVENT_MIN_COLOR_INDEX = 1
CALENDAR_EVENT_MAX_COLOR_INDEX = 11

CALENDAR_EVENT_STATUS_CHOICES = [u'confirmed', u'tentative', u'cancelled',]
CALENDAR_EVENT_TRANSPARENCY_CHOICES = [u'opaque', u'transparent',]
CALENDAR_EVENT_VISIBILITY_CHOICES = [u'default', u'public', u'private', u'confedential']

def _getCalendarEventAttribute(myarg, body, parameters, updateCmd):
  if not updateCmd and myarg in [u'id', u'eventid']:
    body[u'id'] = getEventID()
  elif myarg == u'description':
    body[u'description'] = getString(OB_STRING, minLen=0).replace(u'\\n', u'\n')
  elif myarg == u'location':
    body[u'location'] = getString(OB_STRING, minLen=0)
  elif myarg == u'source':
    body[u'source'] = {u'title': getString(OB_STRING), u'url': getString(OB_URL)}
  elif myarg == u'summary':
    body[u'summary'] = getString(OB_STRING, minLen=0)
  elif myarg == u'start':
    body[u'start'] = getEventTime()
  elif myarg == u'end':
    body[u'end'] = getEventTime()
  elif myarg == u'recurrence':
    body.setdefault(u'recurrence', [])
    body[u'recurrence'].append(getString(OB_RECURRENCE))
  elif myarg == u'timezone':
    parameters[u'timeZone'] = getString(OB_STRING)
  elif myarg == u'attendee':
    body.setdefault(u'attendees', [])
    body[u'attendees'].append({u'email': getEmailAddress(noUid=True)})
  elif myarg == u'optionalattendee':
    body.setdefault(u'attendees', [])
    body[u'attendees'].append({u'email': getEmailAddress(noUid=True), u'optional': True})
  elif myarg == u'sendnotifications':
    parameters[u'sendNotifications'] = getBoolean()
  elif myarg == u'notifyattendees':
    parameters[u'sendNotifications'] = True
  elif myarg == u'anyonecanaddself':
    body[u'anyoneCanAddSelf'] = getBoolean(True)
  elif myarg == u'guestscaninviteothers':
    body[u'guestsCanInviteOthers'] = getBoolean()
  elif myarg == u'guestscantinviteothers':
    body[u'guestsCanInviteOthers'] = False
  elif myarg == u'guestscanseeotherguests':
    body[u'guestsCanSeeOtherGuests'] = getBoolean()
  elif myarg == u'guestscantseeotherguests':
    body[u'guestsCanSeeOtherGuests'] = False
  elif myarg == u'status':
    body[u'status'] = getChoice(CALENDAR_EVENT_STATUS_CHOICES)
  elif myarg == u'tentative':
    body[u'status'] = u'tentative'
  elif myarg == u'transparency':
    body[u'transparency'] = getChoice(CALENDAR_EVENT_TRANSPARENCY_CHOICES)
  elif myarg == u'available':
    body[u'transparency'] = u'transparent'
  elif myarg == u'visibility':
    body[u'visibility'] = getChoice(CALENDAR_EVENT_VISIBILITY_CHOICES)
  elif myarg in [u'colorindex', u'colorid']:
    body[u'colorId'] = str(getInteger(CALENDAR_EVENT_MIN_COLOR_INDEX, CALENDAR_EVENT_MAX_COLOR_INDEX))
  elif myarg == u'noreminders':
    body[u'reminders'] = {u'useDefault': False}
  elif myarg == u'reminder':
    body.setdefault(u'reminders', {u'overrides': [], u'useDefault': False})
    body[u'reminders'][u'overrides'].append(getCalendarReminder())
    body[u'reminders'][u'useDefault'] = False
  elif myarg == u'privateproperty':
    body.setdefault(u'extendedProperties', {})
    body[u'extendedProperties'].setdefault(u'private', {})
    key = getString(OB_PROPERTY_KEY)
    body[u'extendedProperties'][u'private'][key] = getString(OB_PROPERTY_VALUE, minLen=0)
  elif myarg == u'sharedproperty':
    body.setdefault(u'extendedProperties', {})
    body[u'extendedProperties'].setdefault(u'shared', {})
    key = getString(OB_PROPERTY_KEY)
    body[u'extendedProperties'][u'shared'][key] = getString(OB_PROPERTY_VALUE, minLen=0)
  elif updateCmd and myarg == u'clearprivateproperty':
    body.setdefault(u'extendedProperties', {})
    body[u'extendedProperties'].setdefault(u'private', {})
    body[u'extendedProperties'][u'private'][getString(OB_PROPERTY_KEY)] = None
  elif updateCmd and myarg == u'clearsharedproperty':
    body.setdefault(u'extendedProperties', {})
    body[u'extendedProperties'].setdefault(u'shared', {})
    body[u'extendedProperties'][u'shared'][getString(OB_PROPERTY_KEY)] = None
  else:
    return False
  return True

def _eventMatches(event, match):
  eventAttr = event
  for attr in match[0]:
    eventAttr = eventAttr.get(attr)
    if not eventAttr:
      return False
  if match[0][0] != u'attendees':
    return match[1].search(eventAttr) is not None
  attendees = [attendee[u'email'] for attendee in eventAttr]
  for attendee in match[1]:
    if attendee not in attendees:
      return False
  return True

def _validateCalendarGetEventIDs(origUser, user, cal, calId, j, jcount, calendarEventEntity, doIt):
  if calendarEventEntity[u'dict']:
    if origUser:
      if not GM_Globals[GM_CSV_SUBKEY_FIELD]:
        calEventIds = calendarEventEntity[u'dict'][calId][:]
      else:
        calEventIds = calendarEventEntity[u'dict'][origUser][calId][:]
    else:
      calEventIds = calendarEventEntity[u'dict'][calId][:]
  else:
    calEventIds = calendarEventEntity[u'list'][:]
  calId = normalizeCalendarId(calId, user)
  if not calEventIds:
    fieldList = [u'id',]
    for match in calendarEventEntity[u'matches']:
      fieldList.append(match[0][0])
    fields = u','.join(fieldList)
    try:
      eventIdsSet = set()
      calEventIds = []
      if len(calendarEventEntity[u'queries']) <= 1:
        if len(calendarEventEntity[u'queries']) == 1:
          calendarEventEntity[u'kwargs'][u'q'] = calendarEventEntity[u'queries'][0]
        events = callGAPIpages(cal.events(), u'list', items=u'items',
                               throw_reasons=GAPI_CALENDAR_THROW_REASONS+[GAPI_NOT_FOUND, GAPI_FORBIDDEN],
                               calendarId=calId, fields=u'nextPageToken,items({0})'.format(fields), **calendarEventEntity[u'kwargs'])
        while events:
          event = events.popleft()
          for match in calendarEventEntity[u'matches']:
            if not _eventMatches(event, match):
              break
          else:
            calEventIds.append(event[u'id'])
      else:
        for query in calendarEventEntity[u'queries']:
          calendarEventEntity[u'kwargs'][u'q'] = query
          events = callGAPIpages(cal.events(), u'list', items=u'items',
                                 throw_reasons=GAPI_CALENDAR_THROW_REASONS+[GAPI_NOT_FOUND, GAPI_FORBIDDEN],
                                 calendarId=calId, fields=u'nextPageToken,items({0})'.format(fields), **calendarEventEntity[u'kwargs'])
          while events:
            event = events.popleft()
            for match in calendarEventEntity[u'matches']:
              if not _eventMatches(event, match):
                break
            else:
              eventId = event[u'id']
              if eventId not in eventIdsSet:
                calEventIds.append(eventId)
                eventIdsSet.add(eventId)
      kcount = len(calEventIds)
      if kcount == 0:
        entityNumEntitiesActionNotPerformedWarning(Entity.CALENDAR, calId, Entity.EVENT, kcount, PHRASE_NO_ENTITIES_MATCHED.format(Entity.Plural(Entity.EVENT)), j, jcount)
        setSysExitRC(NO_ENTITIES_FOUND)
        return (calId, cal, None, 0)
    except GAPI_notFound:
      entityUnknownWarning(Entity.CALENDAR, calId, j, jcount)
      return (calId, cal, None, 0)
    except (GAPI_notACalendarUser, GAPI_forbidden) as e:
      entityActionFailedWarning([Entity.CALENDAR, calId], e.message, j, jcount)
      return (calId, cal, None, 0)
    except (GAPI_serviceNotAvailable, GAPI_authError):
      entityServiceNotApplicableWarning(Entity.CALENDAR, calId, j, jcount)
      return (calId, cal, None, 0)
  else:
    kcount = len(calEventIds)
  if not doIt:
    entityNumEntitiesActionNotPerformedWarning(Entity.CALENDAR, calId, Entity.EVENT, kcount, PHRASE_USE_DOIT_ARGUMENT_TO_PERFORM_ACTION, j, jcount)
    return (calId, cal, None, 0)
  entityPerformActionNumItems([Entity.CALENDAR, calId], kcount, Entity.EVENT, j, jcount)
  if kcount == 0:
    setSysExitRC(NO_ENTITIES_FOUND)
  return (calId, cal, calEventIds, kcount)

def _validateCalendarGetEvents(user, cal, calId, j, jcount, calendarEventEntity, showAction):
  calId = normalizeCalendarId(calId, user)
  try:
    eventIdsSet = set()
    eventsList = collections.deque()
    if len(calendarEventEntity[u'queries']) <= 1:
      if len(calendarEventEntity[u'queries']) == 1:
        calendarEventEntity[u'kwargs'][u'q'] = calendarEventEntity[u'queries'][0]
      events = callGAPIpages(cal.events(), u'list', u'items',
                             throw_reasons=GAPI_CALENDAR_THROW_REASONS+[GAPI_NOT_FOUND, GAPI_FORBIDDEN],
                             calendarId=calId, fields=u'nextPageToken,items', **calendarEventEntity[u'kwargs'])
      while events:
        event = events.popleft()
        for match in calendarEventEntity[u'matches']:
          if not _eventMatches(event, match):
            break
        else:
          eventsList.append(event)
    else:
      for query in calendarEventEntity[u'queries']:
        calendarEventEntity[u'kwargs'][u'q'] = query
        events = callGAPIpages(cal.events(), u'list', u'items',
                               throw_reasons=GAPI_CALENDAR_THROW_REASONS+[GAPI_NOT_FOUND, GAPI_FORBIDDEN],
                               calendarId=calId, fields=u'nextPageToken,items', **calendarEventEntity[u'kwargs'])
        while events:
          event = events.popleft()
          for match in calendarEventEntity[u'matches']:
            if not _eventMatches(event, match):
              break
          else:
            eventId = event[u'id']
            if eventId not in eventIdsSet:
              eventsList.append(event)
              eventIdsSet.add(eventId)
    kcount = len(eventsList)
    if showAction:
      entityPerformActionNumItems([Entity.CALENDAR, calId], kcount, Entity.EVENT, j, jcount)
    if kcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
    return (calId, cal, eventsList, kcount)
  except GAPI_notFound:
    entityUnknownWarning(Entity.CALENDAR, calId, j, jcount)
    return (calId, cal, None, 0)
  except (GAPI_notACalendarUser, GAPI_forbidden) as e:
    entityActionFailedWarning([Entity.CALENDAR, calId], e.message, j, jcount)
    return (calId, cal, None, 0)
  except (GAPI_serviceNotAvailable, GAPI_authError):
    entityServiceNotApplicableWarning(Entity.CALENDAR, calId, j, jcount)
    return (calId, cal, None, 0)

def _checkIfEventRecurrenceTimeZoneRequired(body, parameters):
  if (u'recurrence' in body) and ((u'start' in body) or (u'end' in body)):
    timeZone = parameters.get(u'timeZone')
    if not timeZone:
      return True
    if u'start' in body:
      body[u'start'][u'timeZone'] = timeZone
    if u'end' in body:
      body[u'end'][u'timeZone'] = timeZone
  return False

def _setEventRecurrenceTimeZone(cal, calId, body):
  try:
    timeZone = callGAPI(cal.calendars(), u'get',
                        throw_reasons=GAPI_CALENDAR_THROW_REASONS+[GAPI_NOT_FOUND, GAPI_FORBIDDEN, GAPI_INVALID],
                        calendarId=calId, fields=u'timeZone')[u'timeZone']
    if u'start' in body:
      body[u'start'][u'timeZone'] = timeZone
    if u'end' in body:
      body[u'end'][u'timeZone'] = timeZone
  except (GAPI_serviceNotAvailable, GAPI_authError, GAPI_notACalendarUser, GAPI_notFound, GAPI_forbidden, GAPI_invalid):
    return False
  return True

def _addCalendarEvents(user, cal, calIds, count,
                       eventRecurrenceTimeZoneRequired, sendNotifications, body):
  i = 0
  for calId in calIds:
    i += 1
    calId = normalizeCalendarId(calId, user)
    if eventRecurrenceTimeZoneRequired and not _setEventRecurrenceTimeZone(cal, calId, body):
      continue
    try:
      event = callGAPI(cal.events(), u'insert',
                       throw_reasons=GAPI_CALENDAR_THROW_REASONS+[GAPI_INVALID, GAPI_REQUIRED, GAPI_TIME_RANGE_EMPTY, GAPI_DUPLICATE, GAPI_FORBIDDEN],
                       calendarId=calId, sendNotifications=sendNotifications, body=body, fields=u'id')
      entityActionPerformed([Entity.CALENDAR, calId, Entity.EVENT, event[u'id']], i, count)
    except (GAPI_invalid, GAPI_required, GAPI_timeRangeEmpty) as e:
      entityActionFailedWarning([Entity.CALENDAR, calId, Entity.EVENT, u''], e.message, i, count)
      return False
    except GAPI_duplicate as e:
      entityActionFailedWarning([Entity.CALENDAR, calId, Entity.EVENT, u''], e.message, i, count)
    except (GAPI_forbidden, GAPI_notACalendarUser) as e:
      entityActionFailedWarning([Entity.CALENDAR, calId], e.message, i, count)
      break
    except (GAPI_serviceNotAvailable, GAPI_authError):
      entityServiceNotApplicableWarning(Entity.CALENDAR, calId, i, count)
      break
  return True

def _updateDeleteCalendarEvents(origUser, user, cal, calIds, count, function, calendarEventEntity, doIt,
                                eventRecurrenceTimeZoneRequired, body, kwargs):
  i = 0
  for calId in calIds:
    i += 1
    calId, cal, calEventIds, jcount = _validateCalendarGetEventIDs(origUser, user, cal, calId, i, count, calendarEventEntity, doIt)
    if jcount == 0:
      continue
    if eventRecurrenceTimeZoneRequired and not _setEventRecurrenceTimeZone(cal, calId, body):
      continue
    Indent.Increment()
    j = 0
    for eventId in calEventIds:
      j += 1
      try:
        callGAPI(cal.events(), function,
                 throw_reasons=GAPI_CALENDAR_THROW_REASONS+[GAPI_NOT_FOUND, GAPI_DELETED, GAPI_FORBIDDEN, GAPI_INVALID, GAPI_REQUIRED, GAPI_TIME_RANGE_EMPTY],
                 calendarId=calId, eventId=eventId, **kwargs)
        entityActionPerformed([Entity.CALENDAR, calId, Entity.EVENT, eventId], j, jcount)
      except (GAPI_notFound, GAPI_deleted) as e:
        if not checkCalendarExists(cal, calId):
          entityUnknownWarning(Entity.CALENDAR, calId, j, jcount)
          break
        else:
          entityActionFailedWarning([Entity.CALENDAR, calId, Entity.EVENT, eventId], e.message, j, jcount)
      except (GAPI_invalid, GAPI_required, GAPI_timeRangeEmpty) as e:
        entityActionFailedWarning([Entity.CALENDAR, calId, Entity.EVENT, eventId], e.message, j, jcount)
        return False
      except (GAPI_forbidden, GAPI_notACalendarUser) as e:
        entityActionFailedWarning([Entity.CALENDAR, calId], e.message, i, count)
        break
      except (GAPI_serviceNotAvailable, GAPI_authError):
        entityServiceNotApplicableWarning(Entity.CALENDAR, calId, i, count)
        break
    Indent.Decrement()
  return True

def _wipeCalendarEvents(user, cal, calIds, count):
  i = 0
  for calId in calIds:
    i += 1
    if user:
      calId = normalizeCalendarId(calId, user)
    else:
      calId, cal = buildGAPIServiceObject(CALENDAR_API, calId)
      if not cal:
        continue
    try:
      callGAPI(cal.calendars(), u'clear',
               throw_reasons=GAPI_CALENDAR_THROW_REASONS+[GAPI_NOT_FOUND, GAPI_FORBIDDEN],
               calendarId=calId)
      entityActionPerformed([Entity.CALENDAR, calId], i, count)
    except (GAPI_notACalendarUser, GAPI_notFound, GAPI_forbidden) as e:
      entityActionFailedWarning([Entity.CALENDAR, calId], e.message, i, count)
    except (GAPI_serviceNotAvailable, GAPI_authError):
      entityServiceNotApplicableWarning(Entity.CALENDAR, calId, i, count)

def _moveCalendarEvents(origUser, user, cal, calIds, count, calendarEventEntity, newCalId, sendNotifications):
  i = 0
  for calId in calIds:
    i += 1
    calId, cal, calEventIds, jcount = _validateCalendarGetEventIDs(origUser, user, cal, calId, i, count, calendarEventEntity, True)
    if jcount == 0:
      continue
    Indent.Increment()
    j = 0
    for eventId in calEventIds:
      j += 1
      try:
        callGAPI(cal.events(), u'move',
                 throw_reasons=GAPI_CALENDAR_THROW_REASONS+[GAPI_NOT_FOUND, GAPI_FORBIDDEN],
                 calendarId=calId, eventId=eventId, destination=newCalId, sendNotifications=sendNotifications, fields=u'')
        entityModifierNewValueActionPerformed([Entity.CALENDAR, calId, Entity.EVENT, eventId], Action.MODIFIER_TO, u'{0}: {1}'.format(Entity.Singular(Entity.CALENDAR), newCalId), j, jcount)
      except GAPI_notFound as e:
        if not checkCalendarExists(cal, calId):
          entityUnknownWarning(Entity.CALENDAR, calId, i, count)
          break
        else:
          entityActionFailedWarning([Entity.CALENDAR, calId, Entity.EVENT, eventId, Entity.CALENDAR, newCalId], entityTypeNameMessage(Entity.EVENT, eventId, e.message), j, jcount)
      except (GAPI_notACalendarUser, GAPI_forbidden) as e:
        entityActionFailedWarning([Entity.CALENDAR, calId], e.message, i, count)
        break
      except (GAPI_serviceNotAvailable, GAPI_authError):
        entityServiceNotApplicableWarning(Entity.CALENDAR, calId, i, count)
        break
    Indent.Decrement()

EVENT_PRINT_ORDER = [u'id', u'summary', u'description', u'location',
                     u'start', u'end', u'endTimeUnspecified',
                     u'creator', u'organizer', u'status', u'created', u'updated',]

EVENT_TIME_OBJECTS = [u'created', u'updated', u'dateTime']

def _showCalendarEvent(event, k, kcount):
  printEntity([Entity.EVENT, event[u'id']], k, kcount)
  skip_objects = [u'id',]
  Indent.Increment()
  for field in EVENT_PRINT_ORDER:
    if field in event:
      showJSON(field, event[field], skip_objects, EVENT_TIME_OBJECTS)
      skip_objects.append(field)
  showJSON(None, event, skip_objects)
  Indent.Decrement()

def _infoCalendarEvents(origUser, user, cal, calIds, count, calendarEventEntity):
  i = 0
  for calId in calIds:
    i += 1
    calId, cal, calEventIds, jcount = _validateCalendarGetEventIDs(origUser, user, cal, calId, i, count, calendarEventEntity, True)
    if jcount == 0:
      continue
    Indent.Increment()
    j = 0
    for eventId in calEventIds:
      j += 1
      try:
        event = callGAPI(cal.events(), u'get',
                         throw_reasons=GAPI_CALENDAR_THROW_REASONS+[GAPI_NOT_FOUND, GAPI_DELETED, GAPI_FORBIDDEN],
                         calendarId=calId, eventId=eventId)
        _showCalendarEvent(event, j, jcount)
      except (GAPI_notFound, GAPI_deleted) as e:
        if not checkCalendarExists(cal, calId):
          entityUnknownWarning(Entity.CALENDAR, calId, i, count)
          break
        else:
          entityActionFailedWarning([Entity.CALENDAR, calId, Entity.EVENT, eventId], e.message, j, jcount)
      except (GAPI_notACalendarUser, GAPI_forbidden) as e:
        entityActionFailedWarning([Entity.CALENDAR, calId], e.message, i, count)
        break
      except (GAPI_serviceNotAvailable, GAPI_authError):
        entityServiceNotApplicableWarning(Entity.CALENDAR, calId, i, count)
        break
    Indent.Decrement()

def _printShowCalendarEvents(user, cal, calIds, count, calendarEventEntity, csvFormat, csvRows, titles):
  i = 0
  for calId in calIds:
    i += 1
    calId, cal, events, jcount = _validateCalendarGetEvents(user, cal, calId, i, count, calendarEventEntity, not csvFormat)
    if jcount == 0:
      continue
    if not csvFormat:
      Indent.Increment()
      j = 0
      for event in events:
        j += 1
        _showCalendarEvent(event, j, jcount)
      Indent.Decrement()
    else:
      for event in events:
        flattened = {u'calendarId': calId}
        if user:
          flattened[u'primaryEmail'] = user
        addRowTitlesToCSVfile(flattenJSON(event, flattened=flattened), csvRows, titles)

# gam calendars <UserEntity> add event <EventAddAttributes>+
# gam calendar <UserItem> addevent <EventAddAttributes>+
def doCalendarsAddEvent(cal, calIds):
  body = {}
  parameters = {u'sendNotifications': None}
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if not _getCalendarEventAttribute(myarg, body, parameters, False):
      unknownArgumentExit()
  _addCalendarEvents(None, cal, calIds, len(calIds),
                     _checkIfEventRecurrenceTimeZoneRequired(body, parameters), parameters[u'sendNotifications'], body)

# gam calendars <UserEntity> update event <EventEntity> <EventUpdateAttributes>+
def doCalendarsUpdateEvents(cal, calIds):
  calendarEventEntity = getCalendarEventEntity()
  body = {}
  parameters = {u'sendNotifications': None}
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if _getCalendarEventAttribute(myarg, body, parameters, True):
      pass
    else:
      unknownArgumentExit()
  _updateDeleteCalendarEvents(None, None, cal, calIds, len(calIds), u'patch', calendarEventEntity, True,
                              _checkIfEventRecurrenceTimeZoneRequired(body, parameters), body,
                              {u'body': body, u'sendNotifications': parameters[u'sendNotifications'], u'fields': u''})

# gam calendars <UserEntity> delete event <EventEntity> [doit] [notifyattendees]
# gam calendar <UserItem> deleteevent <EventEntity> [doit] [notifyattendees]
def doCalendarsDeleteEvents(cal, calIds):
  doIt = sendNotifications = False
  calendarEventEntity = getCalendarEventEntity()
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'notifyattendees':
      sendNotifications = True
    elif myarg == u'doit':
      doIt = True
    else:
      unknownArgumentExit()
  _updateDeleteCalendarEvents(None, None, cal, calIds, len(calIds), u'delete', calendarEventEntity, doIt,
                              False, {},
                              {u'sendNotifications': sendNotifications})

# gam calendars <UserEntity> wipe events
# gam calendar <UserItem> wipe
def doCalendarsWipeEvents(cal, calIds):
  checkArgumentPresent([CL_OB_EVENT, CL_OB_EVENTS])
  checkForExtraneousArguments()
  _wipeCalendarEvents(None, cal, calIds, len(calIds))

# gam calendars <UserEntity> move events <EventEntity> to <CalendarItem> [notifyattendees]
def doCalendarsMoveEvents(cal, calIds):
  sendNotifications = False
  calendarEventEntity = getCalendarEventEntity()
  checkArgumentPresent(TO_ARGUMENT)
  newCalId = convertUserUIDtoEmailAddress(getString(OB_CALENDAR_ITEM))
  sendNotifications = False
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'notifyattendees':
      sendNotifications = True
    else:
      unknownArgumentExit()
  if not checkCalendarExists(cal, newCalId, True):
    return
  _moveCalendarEvents(None, None, cal, calIds, len(calIds), calendarEventEntity, newCalId, sendNotifications)

# gam calendars <UserEntity> info event <EventEntity>
def doCalendarsInfoEvents(cal, calIds):
  calendarEventEntity = getCalendarEventEntity()
  checkForExtraneousArguments()
  _infoCalendarEvents(None, None, cal, calIds, len(calIds), calendarEventEntity)

def calendarsPrintShowEvents(cal, calIds, csvFormat):
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile([u'calendarId']+EVENT_PRINT_ORDER)
  else:
    titles = csvRows = None
  calendarEventEntity = getCalendarEventEntity(noIds=True)
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif _getCalendarListEventsDisplayProperty(myarg, calendarEventEntity):
      pass
    else:
      unknownArgumentExit()
  _printShowCalendarEvents(None, cal, calIds, len(calIds), calendarEventEntity, csvFormat, csvRows, titles)
  if csvFormat:
    sortCSVTitles([u'calendarId',]+EVENT_PRINT_ORDER, titles)
    writeCSVfile(csvRows, titles, u'Calendar Events', todrive)

# gam calendars <UserEntity> print events ([allevents] <EventSelectProperties>*) [todrive [<ToDriveAttributes>]] <EventDisplayProperties>*
def doCalendarsPrintEvents(cal, calIds):
  calendarsPrintShowEvents(cal, calIds, True)

# gam calendars <UserEntity> show events ([allevents] <EventSelectProperties>*) <EventDisplayProperties>*
def doCalendarsShowEvents(cal, calIds):
  calendarsPrintShowEvents(cal, calIds, False)

def _validateResourceId(resourceId, i, count):
  cd = buildGAPIObject(DIRECTORY_API)
  try:
    return callGAPI(cd.resources().calendars(), u'get',
                    throw_reasons=[GAPI_BAD_REQUEST, GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN],
                    customer=GC_Values[GC_CUSTOMER_ID], calendarResourceId=resourceId, fields=u'resourceEmail')[u'resourceEmail']
  except (GAPI_badRequest, GAPI_resourceNotFound, GAPI_forbidden):
    checkEntityAFDNEorAccessErrorExit(cd, Entity.RESOURCE_CALENDAR, resourceId, i, count)
    return None

def _normalizeResourceIdGetRuleIds(resourceId, i, count, ACLScopeEntity):
  calId = _validateResourceId(resourceId, i, count)
  if not calId:
    return (None, None, 0)
  if ACLScopeEntity[u'dict']:
    ruleIds = ACLScopeEntity[u'dict'][resourceId]
  else:
    ruleIds = ACLScopeEntity[u'list']
  jcount = len(ruleIds)
  entityPerformActionNumItems([Entity.RESOURCE_CALENDAR, resourceId], jcount, Entity.CALENDAR_ACL, i, count)
  if jcount == 0:
    setSysExitRC(NO_ENTITIES_FOUND)
  return (calId, ruleIds, jcount)

# gam resource <ResourceID> add calendaracls <CalendarACLRole> <ACLScopeEntity>
# gam resources <ResourceEntity> add calendaracls <CalendarACLRole> <ACLScopeEntity>
def doResourceAddCalendarACLs(entityList):
  cal = buildGAPIObject(CALENDAR_API)
  role = getChoice(CALENDAR_ACL_ROLES_MAP, mapChoice=True)
  ACLScopeEntity = getCalendarSiteACLScopeEntity()
  checkForExtraneousArguments()
  i = 0
  count = len(entityList)
  for resourceId in entityList:
    i += 1
    calId, ruleIds, jcount = _normalizeResourceIdGetRuleIds(resourceId, i, count, ACLScopeEntity)
    if jcount == 0:
      continue
    _addCalendarACLs(cal, Entity.RESOURCE_CALENDAR, calId, i, count, role, ruleIds, jcount)

def _resourceUpdateDeleteCalendarACLs(entityList, function, role, body):
  cal = buildGAPIObject(CALENDAR_API)
  ACLScopeEntity = getCalendarSiteACLScopeEntity()
  checkForExtraneousArguments()
  i = 0
  count = len(entityList)
  for resourceId in entityList:
    i += 1
    calId, ruleIds, jcount = _normalizeResourceIdGetRuleIds(resourceId, i, count, ACLScopeEntity)
    if jcount == 0:
      continue
    _updateDeleteCalendarACLs(cal, function, Entity.RESOURCE_CALENDAR, calId, i, count, role, body, ruleIds, jcount)

# gam resource <ResourceID> update calendaracls <CalendarACLRole> <ACLScopeEntity>
# gam resources <ResourceEntity> update calendaracls <CalendarACLRole> <ACLScopeEntity>
def doResourceUpdateCalendarACLs(entityList):
  role = getChoice(CALENDAR_ACL_ROLES_MAP, mapChoice=True)
  body = {u'role': role}
  _resourceUpdateDeleteCalendarACLs(entityList, u'patch', role, body)

# gam resource <ResourceID> delete calendaracls [<CalendarACLRole>] <ACLScopeEntity>
# gam resources <ResourceEntity> delete calendaracls [<CalendarACLRole>] <ACLScopeEntity>
def doResourceDeleteCalendarACLs(entityList):
  role = getChoice(CALENDAR_ACL_ROLES_MAP, defaultChoice=None, mapChoice=True)
  body = {}
  _resourceUpdateDeleteCalendarACLs(entityList, u'delete', role, body)

# gam resource <ResourceID> info calendaracls <CalendarACLScopeEntity>
# gam resources <ResourceEntity> info calendaracls <CalendarACLScopeEntity>
def doResourceInfoCalendarACLs(entityList):
  cal = buildGAPIObject(CALENDAR_API)
  ACLScopeEntity = getCalendarSiteACLScopeEntity()
  checkForExtraneousArguments()
  i = 0
  count = len(entityList)
  for resourceId in entityList:
    i += 1
    calId, ruleIds, jcount = _normalizeResourceIdGetRuleIds(resourceId, i, count, ACLScopeEntity)
    if jcount == 0:
      continue
    _infoCalendarACLs(cal, Entity.RESOURCE_CALENDAR, calId, i, count, ruleIds, jcount)

def _doResourcePrintShowCalendarACLs(entityList, csvFormat):
  cal = buildGAPIObject(CALENDAR_API)
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile(None)
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    else:
      unknownArgumentExit()
  i = 0
  count = len(entityList)
  for resourceId in entityList:
    i += 1
    calId = _validateResourceId(resourceId, i, count)
    if not calId:
      continue
    try:
      acls = callGAPIpages(cal.acl(), u'list', u'items',
                           throw_reasons=[GAPI_NOT_FOUND, GAPI_FORBIDDEN],
                           calendarId=calId, fields=u'nextPageToken,items(id,role,scope)')
      jcount = len(acls)
      if not csvFormat:
        entityPerformActionNumItems([Entity.RESOURCE_CALENDAR, resourceId], jcount, Entity.CALENDAR_ACL, i, count)
      if jcount == 0:
        setSysExitRC(NO_ENTITIES_FOUND)
        continue
      if not csvFormat:
        Indent.Increment()
        j = 0
        for rule in acls:
          j += 1
          printEntity([Entity.RESOURCE_CALENDAR, resourceId, Entity.CALENDAR_ACL, formatACLRule(rule)], j, jcount)
        Indent.Decrement()
      else:
        for rule in acls:
          addRowTitlesToCSVfile(flattenJSON(rule, flattened={u'resourceId': resourceId, u'resourceEmail': calId}), csvRows, titles)
    except GAPI_notFound:
      entityUnknownWarning(Entity.RESOURCE_CALENDAR, calId, i, count)
    except GAPI_forbidden as e:
      entityActionFailedWarning([Entity.RESOURCE_CALENDAR, calId], e.message, i, count)
  if csvFormat:
    sortCSVTitles([u'resourceId', u'resourceEmail'], titles)
    writeCSVfile(csvRows, titles, u'Resource Calendar ACLs', todrive)

# gam resource <ResourceID> print calendaracls [todrive [<ToDriveAttributes>]]
# gam resources <ResourceEntity> print calendaracls [todrive [<ToDriveAttributes>]]
def doResourcePrintCalendarACLs(entityList):
  _doResourcePrintShowCalendarACLs(entityList, True)

# gam resource <ResourceID> show calendaracls
# gam resources <ResourceEntity> show calendaracls
def doResourceShowCalendarACLs(entityList):
  _doResourcePrintShowCalendarACLs(entityList, False)

def _showSchema(schema, i=0, count=0):
  printEntity([Entity.USER_SCHEMA, schema[u'schemaName']], i, count)
  Indent.Increment()
  for a_key in schema:
    if a_key not in [u'kind', u'etag', u'schemaName', u'fields']:
      printKeyValueList([a_key, schema[a_key]])
  for field in schema[u'fields']:
    printKeyValueList([u'Field', field[u'fieldName']])
    Indent.Increment()
    for a_key in field:
      if a_key not in [u'kind', u'etag', u'fieldName']:
        printKeyValueList([a_key, field[a_key]])
    Indent.Decrement()
  Indent.Decrement()

SCHEMA_FIELDTYPE_CHOICES_MAP = {
  u'bool': u'BOOL',
  u'date': u'DATE',
  u'double': u'DOUBLE',
  u'email': u'EMAIL',
  u'int64': u'INT64',
  u'phone': u'PHONE',
  u'string': u'STRING',
  }

def _doCreateUpdateUserSchemas(updateCmd, entityList):
  cd = buildGAPIObject(DIRECTORY_API)
  addBody = {u'schemaName': u'', u'fields': []}
  deleteFields = []
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'field':
      a_field = {u'fieldName': getString(OB_FIELD_NAME), u'fieldType': u'STRING'}
      while CLArgs.ArgumentsRemaining():
        argument = getArgument()
        if argument == u'type':
          a_field[u'fieldType'] = getChoice(SCHEMA_FIELDTYPE_CHOICES_MAP, mapChoice=True)
        elif argument in [u'multivalued', u'multivalue']:
          a_field[u'multiValued'] = True
        elif argument == u'indexed':
          a_field[u'indexed'] = True
        elif argument == u'restricted':
          a_field[u'readAccessType'] = u'ADMINS_AND_SELF'
        elif argument == u'range':
          a_field[u'numericIndexingSpec'] = {u'minValue': getInteger(), u'maxValue': getInteger()}
        elif argument == u'endfield':
          break
        elif argument == u'field':
          CLArgs.Backup()
          break
        else:
          unknownArgumentExit()
      addBody[u'fields'].append(a_field)
    elif updateCmd and myarg == u'deletefield':
      deleteFields.append(getString(OB_FIELD_NAME))
    else:
      unknownArgumentExit()
  if not updateCmd and not addBody[u'fields']:
    missingArgumentExit(u'SchemaFieldDefinition')
  i = 0
  count = len(entityList)
  for schemaName in entityList:
    i += 1
    try:
      if updateCmd:
        oldBody = callGAPI(cd.schemas(), u'get',
                           throw_reasons=[GAPI_INVALID, GAPI_BAD_REQUEST, GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN],
                           customerId=GC_Values[GC_CUSTOMER_ID], schemaKey=schemaName, fields=u'schemaName,fields')
        for field in oldBody[u'fields']:
          field.pop(u'etag', None)
          field.pop(u'kind', None)
          field.pop(u'fieldId', None)
        badDelete = False
        for delField in deleteFields:
          fieldNameLower = delField.lower()
          for n, field in enumerate(oldBody[u'fields']):
            if field[u'fieldName'].lower() == fieldNameLower:
              del oldBody[u'fields'][n]
              break
          else:
            entityActionNotPerformedWarning([Entity.USER_SCHEMA, schemaName, Entity.FIELD, delField], PHRASE_DOES_NOT_EXIST)
            badDelete = True
        if badDelete:
          continue
        for addField in addBody[u'fields']:
          fieldNameLower = addField[u'fieldName'].lower()
          for n, field in enumerate(oldBody[u'fields']):
            if field[u'fieldName'].lower() == fieldNameLower:
              del oldBody[u'fields'][n]
              break
        oldBody[u'fields'].extend(addBody[u'fields'])
        if not oldBody[u'fields']:
          entityActionNotPerformedWarning([Entity.USER_SCHEMA, schemaName],
                                          PHRASE_SCHEMA_WOULD_HAVE_NO_FIELDS.format(Entity.Singular(Entity.USER_SCHEMA), Entity.Plural(Entity.FIELD)))
          continue
        result = callGAPI(cd.schemas(), u'update',
                          throw_reasons=[GAPI_BAD_REQUEST, GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN],
                          customerId=GC_Values[GC_CUSTOMER_ID], body=oldBody, schemaKey=schemaName)
        entityActionPerformed([Entity.USER_SCHEMA, result[u'schemaName']], i, count)
      else:
        addBody[u'schemaName'] = schemaName
        result = callGAPI(cd.schemas(), u'insert',
                          throw_reasons=[GAPI_DUPLICATE, GAPI_CONDITION_NOT_MET, GAPI_BAD_REQUEST, GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN],
                          customerId=GC_Values[GC_CUSTOMER_ID], body=addBody, fields=u'schemaName')
        entityActionPerformed([Entity.USER_SCHEMA, result[u'schemaName']], i, count)
    except GAPI_duplicate:
      entityDuplicateWarning(Entity.USER_SCHEMA, schemaName, i, count)
    except GAPI_conditionNotMet as e:
      entityActionFailedWarning([Entity.USER_SCHEMA, schemaName], e.message, i, count)
    except (GAPI_badRequest, GAPI_resourceNotFound, GAPI_forbidden):
      checkEntityAFDNEorAccessErrorExit(cd, Entity.USER_SCHEMA, schemaName, i, count)

# gam create schema|schemas <SchemaName> <SchemaFieldDefinition>+
def doCreateUserSchema():
  _doCreateUpdateUserSchemas(False, getStringReturnInList(OB_SCHEMA_NAME))

# gam update schema|schemas <SchemaEntity> <SchemaFieldDefinition>+
def doUpdateUserSchemas():
  _doCreateUpdateUserSchemas(True, getEntityList(OB_SCHEMA_ENTITY))

# gam delete schema|schemas <SchemaEntity>
def doDeleteUserSchemas():
  cd = buildGAPIObject(DIRECTORY_API)
  entityList = getEntityList(OB_SCHEMA_ENTITY)
  checkForExtraneousArguments()
  i = 0
  count = len(entityList)
  for schemaKey in entityList:
    i += 1
    try:
      callGAPI(cd.schemas(), u'delete',
               throw_reasons=[GAPI_BAD_REQUEST, GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN],
               customerId=GC_Values[GC_CUSTOMER_ID], schemaKey=schemaKey)
      entityActionPerformed([Entity.USER_SCHEMA, schemaKey], i, count)
    except (GAPI_badRequest, GAPI_resourceNotFound, GAPI_forbidden):
      checkEntityAFDNEorAccessErrorExit(cd, Entity.USER_SCHEMA, schemaKey, i, count)

# gam info schema|schemas <SchemaEntity>
def doInfoUserSchemas():
  cd = buildGAPIObject(DIRECTORY_API)
  entityList = getEntityList(OB_SCHEMA_ENTITY)
  checkForExtraneousArguments()
  i = 0
  count = len(entityList)
  for schemaKey in entityList:
    i += 1
    try:
      schema = callGAPI(cd.schemas(), u'get',
                        throw_reasons=[GAPI_INVALID, GAPI_BAD_REQUEST, GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN],
                        customerId=GC_Values[GC_CUSTOMER_ID], schemaKey=schemaKey)
      _showSchema(schema, i, count)
    except (GAPI_invalid, GAPI_badRequest, GAPI_resourceNotFound, GAPI_forbidden):
      checkEntityAFDNEorAccessErrorExit(cd, Entity.USER_SCHEMA, schemaKey, i, count)

def _doPrintShowUserSchemas(csvFormat):
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile(None)
  cd = buildGAPIObject(DIRECTORY_API)
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    else:
      unknownArgumentExit()
  try:
    result = callGAPI(cd.schemas(), u'list',
                      throw_reasons=[GAPI_BAD_REQUEST, GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN],
                      customerId=GC_Values[GC_CUSTOMER_ID])
    jcount = len(result.get(u'schemas', [])) if (result) else 0
    if not csvFormat:
      performActionNumItems(jcount, Entity.USER_SCHEMA)
    if jcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
    else:
      if not csvFormat:
        Indent.Increment()
        j = 0
        for schema in result[u'schemas']:
          j += 1
          _showSchema(schema, j, jcount)
        Indent.Decrement()
      else:
        for schema in result[u'schemas']:
          addRowTitlesToCSVfile(flattenJSON(schema), csvRows, titles)
  except (GAPI_badRequest, GAPI_resourceNotFound, GAPI_forbidden):
    accessErrorExit(cd)
  if csvFormat:
    sortCSVTitles([u'schemaId', u'schemaName', u'fields.Count'], titles)
    writeCSVfile(csvRows, titles, u'User Schemas', todrive)

# gam print schema|schemas [todrive [<ToDriveAttributes>]]
def doPrintUserSchemas():
  _doPrintShowUserSchemas(True)

# gam show schema|schemas
def doShowUserSchemas():
  _doPrintShowUserSchemas(False)

def checkSiteExists(sitesObject, domain, site):
  try:
    callGData(sitesObject, u'GetSite',
              throw_errors=[GDATA_NOT_FOUND],
              retry_errors=[GDATA_INTERNAL_SERVER_ERROR],
              domain=domain, site=site)
    return True
  except GData_notFound:
    return None

SITE_ACLS = 'ACLs'
SITE_CATEGORIES = u'Categories'
SITE_LINK = u'Link'
SITE_NAME = u'Name'
SITE_SITE = u'Site'
SITE_SOURCELINK = u'SourceLink'
SITE_SUMMARY = u'Summary'
SITE_THEME = u'Theme'
SITE_UPDATED = u'Updated'
SITE_WEB_ADDRESS_MAPPINGS = 'WebAddressMappings'

SITE_DATA_DOMAIN = u'domain'
SITE_DATA_SITE = u'site'
SITE_DATA_DOMAIN_SITE = u'domainSite'
SITE_DATA_FIELDS = u'fields'

class SitesManager(object):

  SITE_ARGUMENT_TO_PROPERTY_MAP = {
    u'categories': SITE_CATEGORIES,
    u'name': SITE_NAME,
    u'sourcelink': SITE_SOURCELINK,
    u'summary': SITE_SUMMARY,
    u'theme': SITE_THEME,
    }

  @staticmethod
  def AclEntryToFields(acl_entry):

    def GetAclAttr(attrlist):
      objAttr = acl_entry
      for attr in attrlist:
        objAttr = getattr(objAttr, attr)
        if not objAttr:
          return None
      return objAttr

    fields = {}
    fields[u'role'] = GetAclAttr([u'role', u'value'])
    if not fields[u'role']:
      fields[u'role'] = GetAclAttr([u'withKey', u'role', u'value'])+u' (with link)'
    fields[u'scope'] = {u'type': GetAclAttr([u'scope', u'type']),
                        u'value': GetAclAttr([u'scope', u'value'])}
    link = acl_entry.FindInviteLink()
    if link:
      fields[u'inviteLink'] = link
    return fields

  @staticmethod
  def FieldsToAclEntry(fields):
    import gdata.apps.sites

    acl_entry = gdata.apps.sites.AclEntry()
    acl_entry.role = gdata.apps.sites.AclRole(value=fields[u'role'])
    acl_entry.scope = gdata.apps.sites.AclScope(stype=fields[u'scope'][u'type'], value=fields[u'scope'].get(u'value'))
    return acl_entry

  @staticmethod
  def ActivityEntryToFields(activity_entry):
    fields = {}

    def GetActivityField(fieldName, attrlist):
      objAttr = activity_entry
      for attr in attrlist:
        objAttr = getattr(objAttr, attr)
        if not objAttr:
          return
      fields[fieldName] = objAttr

    def GetActivityFieldData(objAttr, attrlist, default):
      for attr in attrlist:
        objAttr = getattr(objAttr, attr)
        if not objAttr:
          return default
      return  objAttr

    def AppendItemToFieldsList(fieldName, fieldValue):
      fields.setdefault(fieldName, [])
      fields[fieldName].append(fieldValue)


    GetActivityField(u'Summary', [u'title', u'text'])
    GetActivityField(u'Updated', [u'updated', u'text'])
    for author in activity_entry.author:
      AppendItemToFieldsList(u'Authors', u'{0}/{1}'.format(GetActivityFieldData(author, [u'name', u'text'], u'Unknown Name'), GetActivityFieldData(author, [u'email', u'text'], u'Unknown Email')))
    fields[u'Operation'] = activity_entry.Kind()
    return fields

  @staticmethod
  def SiteToFields(site_entry):
    fields = {}

    def GetSiteField(fieldName, attrlist):
      objAttr = site_entry
      for attr in attrlist:
        objAttr = getattr(objAttr, attr)
        if not objAttr:
          return
      fields[fieldName] = objAttr

    def AppendItemToFieldsList(fieldName, fieldValue):
      fields.setdefault(fieldName, [])
      fields[fieldName].append(fieldValue)

    GetSiteField(SITE_SITE, [u'siteName', u'text'])
    GetSiteField(SITE_NAME, [u'title', u'text'])
    GetSiteField(SITE_SUMMARY, [u'summary', u'text'])
    GetSiteField(SITE_THEME, [u'theme', u'text'])
    GetSiteField(SITE_UPDATED, [u'updated', u'text'])
    if len(site_entry.category) > 0:
      for category in site_entry.category:
        AppendItemToFieldsList(SITE_CATEGORIES, category.term)
    link = site_entry.FindAlternateLink()
    if link:
      fields[SITE_LINK] = link
    link = site_entry.FindSourceLink()
    if link:
      fields[SITE_SOURCELINK] = link
    for link in site_entry.FindWebAddressMappings():
      AppendItemToFieldsList(SITE_WEB_ADDRESS_MAPPINGS, link)
    return fields

  @staticmethod
  def GetSiteFields():

    fields = {}
    while CLArgs.ArgumentsRemaining():
      myarg = getArgument()
      if myarg in SitesManager.SITE_ARGUMENT_TO_PROPERTY_MAP:
        fieldName = SitesManager.SITE_ARGUMENT_TO_PROPERTY_MAP[myarg]
        if fieldName == SITE_NAME:
          fields[fieldName] = getString(OB_STRING)
        elif fieldName == SITE_SOURCELINK:
          fields[fieldName] = getString(OB_URI)
        elif fieldName == SITE_SUMMARY:
          fields[fieldName] = getString(OB_STRING, minLen=0).replace(u'\\n', u'\n')
        elif fieldName == SITE_THEME:
          fields[fieldName] = getString(OB_STRING)
        elif fieldName == SITE_CATEGORIES:
          fields[fieldName] = getString(OB_STRING, minLen=0).split(u',')
      else:
        unknownArgumentExit()
    return fields

  @staticmethod
  def FieldsToSite(fields):
    import atom
    import gdata.apps.sites

    def GetField(fieldName):
      return fields.get(fieldName)

    def GetSiteField(fieldName, fieldClass):
      value = fields.get(fieldName)
      if value:
        return fieldClass(text=value)
      return None

    site_entry = gdata.apps.sites.SiteEntry(sourceSite=GetField(SITE_SOURCELINK))
    site_entry.siteName = GetSiteField(SITE_SITE, gdata.apps.sites.SiteName)
    site_entry.title = GetSiteField(SITE_NAME, atom.Title)
    site_entry.summary = GetSiteField(SITE_SUMMARY, atom.Summary)
    site_entry.theme = GetSiteField(SITE_THEME, gdata.apps.sites.Theme)
    value = GetField(SITE_CATEGORIES)
    if value:
      for category in value:
        site_entry.category.append(atom.Category(term=category, scheme=gdata.apps.sites.TAG_KIND_TERM))
    return site_entry

def getSiteEntity():
  siteEntity = {u'list': getEntityList(OB_SITE_ENTITY), u'dict': None}
  if isinstance(siteEntity[u'list'], dict):
    siteEntity[u'dict'] = siteEntity[u'list']
  return siteEntity

def _validateUserGetSites(entityType, user, i, count, siteEntity, itemType=None, modifier=None):
  if siteEntity[u'dict']:
    sites = siteEntity[u'dict'][user]
  else:
    sites = siteEntity[u'list']
  user, sitesObject = getSitesObject(entityType, user, i, count)
  if not sitesObject:
    return (user, None, None, 0)
  jcount = len(sites)
  if not itemType:
    entityPerformActionNumItems([entityType, user], jcount, Entity.SITE, i, count)
  else:
    entityPerformActionSubItemModifierNumItems([entityType, user], itemType, modifier, jcount, Entity.SITE, i, count)
  if jcount == 0:
    setSysExitRC(NO_ENTITIES_FOUND)
  return (user, sitesObject, sites, jcount)

def _validateSite(fullSite, i, count):
  domain, site, domainSite = validateSplitSiteName(fullSite)
  if domainSite:
    return (domain, site, domainSite)
  entityActionNotPerformedWarning([Entity.SITE, site], PHRASE_INVALID_SITE.format(site, SITENAME_FORMAT_REQUIRED), i, count)
  return (domain, site, None)

def _validateSiteGetRuleIds(origUser, fullSite, j, jcount, ACLScopeEntity, showAction=True):
  domain, site, domainSite = _validateSite(fullSite, j, jcount)
  if not domainSite:
    return (domain, site, None, None, 0)
  if ACLScopeEntity:
    if ACLScopeEntity[u'dict']:
      if not GM_Globals[GM_CSV_SUBKEY_FIELD]:
        ruleIds = ACLScopeEntity[u'dict'][fullSite]
      else:
        ruleIds = ACLScopeEntity[u'dict'][origUser][fullSite]
    else:
      ruleIds = ACLScopeEntity[u'list']
    kcount = len(ruleIds)
    if kcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
  else:
    ruleIds = []
    kcount = 0
  if showAction:
    entityPerformActionNumItems([Entity.SITE, domainSite], kcount, Entity.SITE_ACL, j, jcount)
  return (domain, site, domainSite, ruleIds, kcount)

def _createSite(users, entityType):
  sitesManager = SitesManager()
  domain, site, domainSite = getSiteName()
  fields = sitesManager.GetSiteFields()
  if not fields.get(SITE_NAME):
    fields[SITE_NAME] = site
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, sitesObject = getSitesObject(entityType, user, i, count)
    if not sitesObject:
      continue
    try:
      siteEntry = sitesManager.FieldsToSite(fields)
      callGData(sitesObject, u'CreateSite',
                throw_errors=[GDATA_NOT_FOUND, GDATA_ENTITY_EXISTS, GDATA_BAD_REQUEST, GDATA_FORBIDDEN],
                retry_errors=[GDATA_INTERNAL_SERVER_ERROR],
                siteentry=siteEntry, domain=domain, site=None)
      entityActionPerformed([Entity.SITE, domainSite])
    except GData_notFound as e:
      entityActionFailedWarning([Entity.DOMAIN, domain], e.message)
    except (GData_entityExists, GData_badRequest, GData_forbidden) as e:
      entityActionFailedWarning([Entity.SITE, domainSite], e.message)

# gam [<UserTypeEntity>] create site <SiteName> <SiteAttributes>*
def createUserSite(users):
  _createSite(users, Entity.USER)

def doCreateDomainSite():
  _createSite([GC_Values[GC_DOMAIN],], Entity.DOMAIN)

def _updateSites(users, entityType):
  sitesManager = SitesManager()
  siteEntity = getSiteEntity()
  updateFields = sitesManager.GetSiteFields()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, sitesObject, sites, jcount = _validateUserGetSites(entityType, user, i, count, siteEntity)
    if jcount == 0:
      continue
    Indent.Increment()
    j = 0
    for site in sites:
      j += 1
      domain, site, domainSite = _validateSite(site, j, jcount)
      if not domainSite:
        continue
      try:
        siteEntry = callGData(sitesObject, u'GetSite',
                              throw_errors=[GDATA_NOT_FOUND, GDATA_FORBIDDEN],
                              retry_errors=[GDATA_INTERNAL_SERVER_ERROR],
                              domain=domain, site=site)
        fields = sitesManager.SiteToFields(siteEntry)
        for field in updateFields:
          if field != SITE_SOURCELINK:
            fields[field] = updateFields[field]
        newSiteEntry = sitesManager.FieldsToSite(fields)
        callGData(sitesObject, u'UpdateSite',
                  throw_errors=[GDATA_NOT_FOUND, GDATA_BAD_REQUEST, GDATA_FORBIDDEN],
                  retry_errors=[GDATA_INTERNAL_SERVER_ERROR],
                  siteentry=newSiteEntry, domain=domain, site=site, extra_headers={u'If-Match': siteEntry.etag})
        entityActionPerformed([Entity.SITE, domainSite])
      except (GData_notFound, GData_badRequest, GData_forbidden) as e:
        entityActionFailedWarning([Entity.SITE, domainSite], e.message)

# gam [<UserTypeEntity>] update site <SiteEntity> <SiteAttributes>+
def updateUserSites(users):
  _updateSites(users, Entity.USER)

def doUpdateDomainSites():
  _updateSites([GC_Values[GC_DOMAIN],], Entity.DOMAIN)

SITE_FIELD_PRINT_ORDER = [
  SITE_UPDATED,
  SITE_NAME,
  SITE_SUMMARY,
  SITE_THEME,
  SITE_SOURCELINK,
  SITE_CATEGORIES,
  SITE_LINK,
  ]

def _showSite(sitesManager, sitesObject, domain, site, roles, j, jcount):
  fields = sitesManager.SiteToFields(site)
  domainSite = u'{0}/{1}'.format(domain, fields[SITE_SITE])
  printKeyValueListWithCount([SITE_SITE, domainSite], j, jcount)
  Indent.Increment()
  for field in SITE_FIELD_PRINT_ORDER:
    if field in fields:
      if not isinstance(fields[field], list):
        if field != SITE_SUMMARY:
          printKeyValueList([field, fields[field]])
        else:
          printKeyValueList([field, None])
          Indent.Increment()
          printKeyValueList([Indent.MultiLineText(fields[field])])
          Indent.Decrement()
      else:
        printKeyValueList([field, u','.join(fields[field])])
  if fields.get(SITE_WEB_ADDRESS_MAPPINGS):
    printKeyValueList([SITE_WEB_ADDRESS_MAPPINGS, None])
    Indent.Increment()
    for link in fields[SITE_WEB_ADDRESS_MAPPINGS]:
      printKeyValueList([link, None])
    Indent.Decrement()
  if roles:
    try:
      acls = callGDataPages(sitesObject, u'GetAclFeed',
                            throw_errors=[GDATA_NOT_FOUND, GDATA_FORBIDDEN],
                            retry_errors=[GDATA_INTERNAL_SERVER_ERROR],
                            domain=domain, site=fields[SITE_SITE])
      printKeyValueList([SITE_ACLS, None])
      Indent.Increment()
      for acl in acls:
        fields = sitesManager.AclEntryToFields(acl)
        if fields[u'role'] in roles:
          printKeyValueList([formatACLRule(fields)])
      Indent.Decrement()
    except (GData_notFound, GData_forbidden) as e:
      entityActionFailedWarning([Entity.SITE, domainSite], e.message)
  Indent.Decrement()

SITE_ACL_ROLES_MAP = {
  u'editor': u'writer',
  u'invite': u'invite',
  u'owner': u'owner',
  u'read': u'reader',
  u'reader': u'reader',
  u'writer': u'writer',
  }

def getACLRoles(aclRolesMap):
  roles = []
  for role in getString(OB_ROLE_LIST, minLen=0).strip().lower().replace(u',', u' ').split():
    if role == u'all':
      for role in aclRolesMap:
        roles.append(aclRolesMap[role])
    elif role in aclRolesMap:
      roles.append(aclRolesMap[role])
    else:
      CLArgs.Backup()
      invalidChoiceExit(aclRolesMap)
  return list(set(roles))

def _infoSites(users, entityType):
  siteEntity = getSiteEntity()
  url_params = {}
  roles = None
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'withmappings':
      url_params[u'with-mappings'] = u'true'
    elif myarg in [u'role', u'roles']:
      roles = getACLRoles(SITE_ACL_ROLES_MAP)
    else:
      unknownArgumentExit()
  sitesManager = SitesManager()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, sitesObject, sites, jcount = _validateUserGetSites(entityType, user, i, count, siteEntity)
    if jcount == 0:
      continue
    Indent.Increment()
    j = 0
    for site in sites:
      j += 1
      domain, site, domainSite = _validateSite(site, j, jcount)
      if not domainSite:
        continue
      try:
        result = callGData(sitesObject, u'GetSite',
                           throw_errors=[GDATA_NOT_FOUND, GDATA_FORBIDDEN],
                           retry_errors=[GDATA_INTERNAL_SERVER_ERROR],
                           domain=domain, site=site, url_params=url_params)
        if result:
          _showSite(sitesManager, sitesObject, domain, result, roles, j, jcount)
      except (GData_notFound, GData_forbidden) as e:
        entityActionFailedWarning([Entity.SITE, domainSite], e.message)
    Indent.Decrement()

# gam [<UserTypeEntity>] info site <SiteEntity> [withmappings] [role|roles all|<SiteACLRoleList>]
def infoUserSites(users):
  _infoSites(users, Entity.USER)

def doInfoDomainSites():
  _infoSites([GC_Values[GC_DOMAIN],], Entity.DOMAIN)

def _printShowSites(entityList, entityType, csvFormat):
  def _getSites(domain, i, count):
    try:
      page_message = getPageMessage()
      return callGDataPages(sitesObject, u'GetSiteFeed',
                            page_message=page_message,
                            throw_errors=[GDATA_NOT_FOUND, GDATA_FORBIDDEN],
                            retry_errors=[GDATA_INTERNAL_SERVER_ERROR],
                            domain=domain, url_params=url_params)
    except (GData_notFound, GData_forbidden) as e:
      entityActionFailedWarning([Entity.DOMAIN, domain], e.message, i, count)
    return []

  def _printSites(entity, i, count, domain, sites):
    for site in sites:
      fields = sitesManager.SiteToFields(site)
      if fields[SITE_SITE] in sitesSet:
        continue
      sitesSet.add(fields[SITE_SITE])
      domainSite = u'{0}/{1}'.format(domain, fields[SITE_SITE])
      siteRow = {Entity.Singular(entityType): entity, SITE_SITE: domainSite}
      for field in fields:
        if field != SITE_SITE:
          if not isinstance(fields[field], list):
            if field != SITE_SUMMARY or not convertCRNL:
              siteRow[field] = fields[field]
            else:
              siteRow[field] = convertCRsNLs(fields[field])
          else:
            siteRow[field] = delimiter.join(fields[field])
      rowShown = False
      if roles:
        try:
          acls = callGDataPages(sitesObject, u'GetAclFeed',
                                throw_errors=[GDATA_NOT_FOUND, GDATA_FORBIDDEN],
                                retry_errors=[GDATA_INTERNAL_SERVER_ERROR],
                                domain=domain, site=fields[SITE_SITE])
          for acl in acls:
            fields = sitesManager.AclEntryToFields(acl)
            if fields[u'role'] in roles:
              siteACLRow = siteRow.copy()
              siteACLRow[u'Role'] = fields[u'role']
              if fields[u'scope'][u'type'] != u'default':
                siteACLRow[u'Scope'] = u'{0}:{1}'.format(fields[u'scope'][u'type'], fields[u'scope'][u'value'])
              else:
                siteACLRow[u'Scope'] = fields[u'scope'][u'type']
              rowShown = True
              addRowTitlesToCSVfile(siteACLRow, csvRows, titles)
        except (GData_notFound, GData_forbidden) as e:
          entityActionFailedWarning([Entity.SITE, domainSite], e.message, i, count)
      if not rowShown:
        addRowTitlesToCSVfile(siteRow, csvRows, titles)

  def _showSites(entity, i, count, domain, sites):
    jcount = len(sites)
    if entityType == Entity.USER:
      entityPerformActionNumItems([entityType, entity, Entity.DOMAIN, domain], jcount, Entity.SITE, i, count)
    else:
      entityPerformActionNumItems([entityType, entity], jcount, Entity.SITE, i, count)
    Indent.Increment()
    j = 0
    for site in sites:
      j += 1
      _showSite(sitesManager, sitesObject, domain, site, roles, j, jcount)
    Indent.Decrement()

  domains = []
  domainLists = []
  url_params = {}
  includeAllSites = [u'false', u'true'][entityType == Entity.DOMAIN]
  roles = None
  convertCRNL = GC_Values[GC_CSV_OUTPUT_CONVERT_CR_NL]
  delimiter = GC_Values[GC_CSV_OUTPUT_FIELD_DELIMITER]
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile([Entity.Singular(entityType), SITE_SITE, SITE_NAME])
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg in [u'domain', u'domains']:
      if entityType == Entity.DOMAIN:
        entityList = getEntityList(OB_DOMAIN_NAME_ENTITY)
      else:
        domains = getEntityList(OB_DOMAIN_NAME_ENTITY)
        domainLists = domains if isinstance(domains, dict) else None
    elif myarg == u'includeallsites':
      includeAllSites = u'true'
    elif myarg == u'maxresults':
      url_params[u'max-results'] = getInteger(minVal=1)
    elif myarg == u'withmappings':
      url_params[u'with-mappings'] = u'true'
    elif myarg in [u'role', u'roles']:
      roles = getACLRoles(SITE_ACL_ROLES_MAP)
    elif myarg in [u'convertcrnl', u'converttextnl', u'convertsummarynl']:
      convertCRNL = True
    elif myarg == u'delimiter':
      delimiter = getDelimiter()
    else:
      unknownArgumentExit()
  sitesManager = SitesManager()
  sitesSet = set()
  i, count, entityList = getEntityArgument(entityList)
  if entityType == Entity.USER:
    for user in entityList:
      i += 1
      if domainLists:
        domainList = domainLists[user]
      elif domains:
        domainList = domains
      else:
        _, domain = splitEmailAddress(user)
        domainList = [domain]
      user, sitesObject = getSitesObject(entityType, user, i, count)
      if not sitesObject:
        continue
      jcount = len(domainList)
      j = 0
      for domain in domainList:
        j += 1
        if domain != u'site':
          url_params[u'include-all-sites'] = includeAllSites
        else:
          url_params.pop(u'include-all-sites', None)
        printGettingAllEntityItemsForWhom(Entity.SITE, u'{0}: {1}, {2}: {3}'.format(Entity.Singular(Entity.USER), user, Entity.Singular(Entity.DOMAIN), domain))
        sites = _getSites(domain, i, count)
        if not csvFormat:
          _showSites(domain, j, jcount, domain, sites)
        else:
          _printSites(user, j, jcount, domain, sites)
  else:
    for domain in entityList:
      i += 1
      domain, sitesObject = getSitesObject(entityType, domain, i, count)
      if not sitesObject:
        continue
      if domain != u'site':
        url_params[u'include-all-sites'] = includeAllSites
      else:
        url_params.pop(u'include-all-sites', None)
      printGettingAllEntityItemsForWhom(Entity.SITE, u'{0}: {1}'.format(Entity.Singular(Entity.DOMAIN), domain))
      sites = _getSites(domain, i, count)
      if not csvFormat:
        _showSites(domain, i, count, domain, sites)
      else:
        _printSites(domain, i, count, domain, sites)
  if csvFormat:
    if roles:
      removeTitlesFromCSVfile([u'Scope', u'Role'], titles)
      addTitlesToCSVfile([u'Scope', u'Role'], titles)
    writeCSVfile(csvRows, titles, u'Sites', todrive)

# gam [<UserTypeEntity>] print sites [todrive [<ToDriveAttributes>]] [domain|domains <DomainNameEntity>] [includeallsites] [withmappings] [role|roles all|<SiteACLRoleList>] [maxresults <Number>] [convertcrnl] [delimiter <String>]
def printUserSites(users):
  _printShowSites(users, Entity.USER, True)

# gam [<UserTypeEntity>] show sites [domain|domains <DomainNameEntity>] [includeallsites] [withmappings] [role|roles all|<SiteACLRoleList>] [maxresults <Number>] [convertcrnl]
def showUserSites(users):
  _printShowSites(users, Entity.USER, False)

# gam print sites [todrive [<ToDriveAttributes>]] [domain|domains <DomainNameEntity>] [includeallsites] [withmappings] [role|roles all|<SiteACLRoleList>] [maxresults <Number>] [convertcrnl] [delimiter <String>]
def doPrintDomainSites():
  _printShowSites([GC_Values[GC_DOMAIN],], Entity.DOMAIN, True)

# gam show sites [domain|domains <DomainNameEntity>] [includeallsites] [withmappings] [role|roles all|<SiteACLRoleList>] [maxresults <Number>] [convertcrnl]
def doShowDomainSites():
  _printShowSites([GC_Values[GC_DOMAIN],], Entity.DOMAIN, False)

SITE_ACTION_TO_MODIFIER_MAP = {
  Action.ADD: Action.MODIFIER_TO,
  Action.UPDATE: Action.MODIFIER_IN,
  Action.DELETE: Action.MODIFIER_FROM,
  Action.INFO: Action.MODIFIER_FROM,
  Action.SHOW: Action.MODIFIER_FROM,
  }

def _processSiteACLs(users, entityType):
  action = Action.Get()
  siteEntity = getSiteEntity()
  if action in [Action.ADD, Action.UPDATE]:
    role = getChoice(SITE_ACL_ROLES_MAP, mapChoice=True)
  else:
    role = None
  ACLScopeEntity = getCalendarSiteACLScopeEntity() if action != Action.SHOW else {}
  checkForExtraneousArguments()
  modifier = SITE_ACTION_TO_MODIFIER_MAP[action]
  sitesManager = SitesManager()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, sitesObject, sites, jcount = _validateUserGetSites(entityType, user, i, count, siteEntity, Entity.SITE_ACL, modifier)
    if jcount == 0:
      continue
    Indent.Increment()
    j = 0
    for site in sites:
      j += 1
      domain, site, domainSite, ruleIds, kcount = _validateSiteGetRuleIds(origUser, site, j, jcount, ACLScopeEntity, showAction=action != Action.SHOW)
      if not domainSite:
        continue
      if action != Action.SHOW:
        Indent.Increment()
        k = 0
        for ruleId in ruleIds:
          k += 1
          ruleId = normalizeRuleId(ruleId)
          try:
            if action == Action.ADD:
              acl = sitesManager.FieldsToAclEntry(makeRoleRuleIdBody(role, ruleId))
              acl = callGData(sitesObject, u'CreateAclEntry',
                              throw_errors=[GDATA_NOT_FOUND, GDATA_ENTITY_EXISTS, GDATA_BAD_REQUEST, GDATA_FORBIDDEN],
                              retry_errors=[GDATA_INTERNAL_SERVER_ERROR],
                              aclentry=acl, domain=domain, site=site)
              fields = sitesManager.AclEntryToFields(acl)
              if not fields.get(u'inviteLink'):
                entityActionPerformed([Entity.SITE, domainSite, Entity.SITE_ACL, formatACLRule(fields)], k, kcount)
              else:
                entityActionPerformed([Entity.SITE, domainSite, Entity.SITE_ACL, u'{0} (Link: {1})'.format(formatACLRule(fields), fields[u'inviteLink'])], k, kcount)
            elif action == Action.UPDATE:
              acl = callGData(sitesObject, u'GetAclEntry',
                              throw_errors=[GDATA_NOT_FOUND, GDATA_BAD_REQUEST, GDATA_FORBIDDEN],
                              retry_errors=[GDATA_INTERNAL_SERVER_ERROR],
                              domain=domain, site=site, ruleId=ruleId)
              acl.role.value = role
              acl = callGData(sitesObject, u'UpdateAclEntry',
                              throw_errors=[GDATA_NOT_FOUND, GDATA_BAD_REQUEST, GDATA_FORBIDDEN],
                              retry_errors=[GDATA_INTERNAL_SERVER_ERROR],
                              aclentry=acl, domain=domain, site=site, ruleId=ruleId, extra_headers={u'If-Match': acl.etag})
              fields = sitesManager.AclEntryToFields(acl)
              entityActionPerformed([Entity.SITE, domainSite, Entity.SITE_ACL, formatACLRule(fields)], k, kcount)
            elif action == Action.DELETE:
              acl = callGData(sitesObject, u'GetAclEntry',
                              throw_errors=[GDATA_NOT_FOUND, GDATA_BAD_REQUEST, GDATA_FORBIDDEN],
                              retry_errors=[GDATA_INTERNAL_SERVER_ERROR],
                              domain=domain, site=site, ruleId=ruleId)
              callGData(sitesObject, u'DeleteAclEntry',
                        throw_errors=[GDATA_NOT_FOUND, GDATA_BAD_REQUEST, GDATA_FORBIDDEN],
                        retry_errors=[GDATA_INTERNAL_SERVER_ERROR],
                        domain=domain, site=site, ruleId=ruleId, extra_headers={u'If-Match': acl.etag})
              entityActionPerformed([Entity.SITE, domainSite, Entity.SITE_ACL, formatACLScopeRole(ruleId, None)], k, kcount)
            elif action == Action.INFO:
              acl = callGData(sitesObject, u'GetAclEntry',
                              throw_errors=[GDATA_NOT_FOUND, GDATA_BAD_REQUEST, GDATA_FORBIDDEN],
                              retry_errors=[GDATA_INTERNAL_SERVER_ERROR],
                              domain=domain, site=site, ruleId=ruleId)
              fields = sitesManager.AclEntryToFields(acl)
              printEntity([Entity.SITE, domainSite, Entity.SITE_ACL, formatACLRule(fields)], k, kcount)
          except GData_notFound as e:
            if not checkSiteExists(sitesObject, domain, site):
              entityUnknownWarning(Entity.SITE, domainSite, j, jcount)
              break
            entityActionFailedWarning([Entity.SITE, domainSite, Entity.SITE_ACL, formatACLScopeRole(ruleId, role)], e.message, k, kcount)
          except (GData_entityExists, GData_badRequest, GData_forbidden) as e:
            entityActionFailedWarning([Entity.SITE, domainSite, Entity.SITE_ACL, formatACLScopeRole(ruleId, role)], e.message, k, kcount)
        Indent.Decrement()
      else:
        try:
          acls = callGDataPages(sitesObject, u'GetAclFeed',
                                throw_errors=[GDATA_NOT_FOUND, GDATA_FORBIDDEN],
                                retry_errors=[GDATA_INTERNAL_SERVER_ERROR],
                                domain=domain, site=site)
          kcount = len(acls)
          entityPerformActionNumItems([Entity.SITE, domainSite], kcount, Entity.SITE_ACL, j, jcount)
          if kcount == 0:
            continue
          Indent.Increment()
          k = 0
          for acl in acls:
            k += 1
            fields = sitesManager.AclEntryToFields(acl)
            printEntity([Entity.SITE, domainSite, Entity.SITE_ACL, formatACLRule(fields)], k, kcount)
          Indent.Decrement()
        except GData_notFound:
          entityUnknownWarning(Entity.SITE, domainSite, j, jcount)
        except GData_forbidden as e:
          entityActionFailedWarning([Entity.SITE, domainSite], e.message, j, jcount)
    Indent.Decrement()

# gam [<UserTypeEntity>] add siteacls <SiteEntity> <SiteACLRole> <ACLScopeEntity>
# gam [<UserTypeEntity>] update siteacls <SiteEntity> <SiteACLRole> <ACLScopeEntity>
# gam [<UserTypeEntity>] delete siteacls <SiteEntity> <ACLScopeEntity>
# gam [<UserTypeEntity>] info siteacls <SiteEntity> <ACLScopeEntity>
# gam [<UserTypeEntity>] show siteacls <SiteEntity>
def processUserSiteACLs(users):
  _processSiteACLs(users, Entity.USER)

def doProcessDomainSiteACLs():
  _processSiteACLs([GC_Values[GC_DOMAIN],], Entity.DOMAIN)

def _printSiteActivity(users, entityType):
  sitesManager = SitesManager()
  todrive = {}
  url_params = {}
  titles, csvRows = initializeTitlesCSVfile([SITE_SITE])
  sites = getEntityList(OB_SITE_ENTITY)
  siteLists = sites if isinstance(sites, dict) else None
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'maxresults':
      url_params[u'max-results'] = getInteger(minVal=1)
    elif myarg == u'updatedmin':
      url_params[u'updated-min'] = getYYYYMMDD()
    elif myarg == u'updatedmax':
      url_params[u'updated-max'] = getYYYYMMDD()
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    if siteLists:
      sites = siteLists[user]
    user, sitesObject = getSitesObject(entityType, user, i, count)
    if not sitesObject:
      continue
    jcount = len(sites)
    if jcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
      continue
    Indent.Increment()
    j = 0
    for site in sites:
      j += 1
      domain, site, domainSite = _validateSite(site, j, jcount)
      if not domainSite:
        continue
      printGettingAllEntityItemsForWhom(Entity.ACTIVITY, domainSite)
      try:
        page_message = getPageMessage()
        activities = callGDataPages(sitesObject, u'GetActivityFeed',
                                    page_message=page_message,
                                    throw_errors=[GDATA_NOT_FOUND, GDATA_FORBIDDEN],
                                    retry_errors=[GDATA_INTERNAL_SERVER_ERROR],
                                    domain=domain, site=site, url_params=url_params)
        for activity in activities:
          fields = sitesManager.ActivityEntryToFields(activity)
          activityRow = {SITE_SITE: domainSite}
          for key in fields:
            if not isinstance(fields[key], list):
              activityRow[key] = fields[key]
            else:
              activityRow[key] = u','.join(fields[key])
          addRowTitlesToCSVfile(activityRow, csvRows, titles)
      except GData_notFound:
        entityUnknownWarning(Entity.SITE, domainSite, j, jcount)
      except GData_forbidden as e:
        entityActionFailedWarning([Entity.SITE, domainSite], e.message, j, jcount)
  writeCSVfile(csvRows, titles, u'Site Activities', todrive)

# gam [<UserTypeEntity>] print siteactivity <SiteEntity> [todrive [<ToDriveAttributes>]] [maxresults <Number>] [updated_min <Date>] [updated_max <Date>]
def printUserSiteActivity(users):
  _printSiteActivity(users, Entity.USER)

def doPrintDomainSiteActivity():
  _printSiteActivity([GC_Values[GC_DOMAIN],], Entity.DOMAIN)

# User commands utilities
UPDATE_USER_ARGUMENT_TO_PROPERTY_MAP = {
  u'address': u'addresses',
  u'addresses': u'addresses',
  u'agreed2terms': u'agreedToTerms',
  u'agreedtoterms': u'agreedToTerms',
  u'changepassword': u'changePasswordAtNextLogin',
  u'changepasswordatnextlogin': u'changePasswordAtNextLogin',
  u'crypt': u'hashFunction',
  u'customerid': u'customerId',
  u'email': u'primaryEmail',
  u'emails': u'emails',
  u'externalid': u'externalIds',
  u'externalids': u'externalIds',
  u'familyname': u'familyName',
  u'firstname': u'givenName',
  u'gal': u'includeInGlobalAddressList',
  u'givenname': u'givenName',
  u'im': u'ims',
  u'ims': u'ims',
  u'includeinglobaladdresslist': u'includeInGlobalAddressList',
  u'ipwhitelisted': u'ipWhitelisted',
  u'lastname': u'familyName',
  u'md5': u'hashFunction',
  u'note': u'notes',
  u'notes': u'notes',
  u'org': u'orgUnitPath',
  u'organization': u'organizations',
  u'organizations': u'organizations',
  u'orgunitpath': u'orgUnitPath',
  u'otheremail': u'emails',
  u'otheremails': u'emails',
  u'ou': u'orgUnitPath',
  u'password': u'password',
  u'phone': u'phones',
  u'phones': u'phones',
  u'primaryemail': u'primaryEmail',
  u'relation': u'relations',
  u'relations': u'relations',
  u'sha': u'hashFunction',
  u'sha-1': u'hashFunction',
  u'sha1': u'hashFunction',
  u'suspended': u'suspended',
  u'username': u'primaryEmail',
  u'website': u'websites',
  u'websites': u'websites',
  }

HASH_FUNCTION_MAP = {
  u'sha': u'SHA-1',
  u'sha1': u'SHA-1',
  u'sha-1': u'SHA-1',
  u'md5': u'MD5',
  u'crypt': u'crypt',
  }

ADDRESS_ARGUMENT_TO_FIELD_MAP = {
  u'country': u'country',
  u'countrycode': u'countryCode',
  u'extendedaddress': u'extendedAddress',
  u'locality': u'locality',
  u'pobox': u'poBox',
  u'postalcode': u'postalCode',
  u'region': u'region',
  u'streetaddress': u'streetAddress',
  }

ORGANIZATION_ARGUMENT_TO_FIELD_MAP = {
  u'costcenter': u'costCenter',
  u'department': u'department',
  u'description': u'description',
  u'domain': u'domain',
  u'location': u'location',
  u'name': u'name',
  u'symbol': u'symbol',
  u'title': u'title',
  }

def getUserAttributes(cd, updateCmd, noUid=False):
  from gamlib import gluprop as UProp

  def clearBodyList(body, itemName):
    if itemName in body:
      del body[itemName]
    body.setdefault(itemName, None)

  def appendItemToBodyList(body, itemName, itemValue, checkBlankField=None):
    if (itemName in body) and (body[itemName] is None):
      del body[itemName]
    body.setdefault(itemName, [])
    if checkBlankField is None or itemValue[checkBlankField]:
      body[itemName].append(itemValue)

  def gen_sha512_hash(password):
    from passlib.handlers.sha2_crypt import sha512_crypt
    return sha512_crypt.encrypt(password, rounds=5000)

  def _splitSchemaNameDotFieldName(sn_fn, fnRequired=True):
    if sn_fn.find(u'.') != -1:
      schemaName, fieldName = sn_fn.split(u'.', 1)
      schemaName = schemaName.strip()
      fieldName = fieldName.strip()
      if schemaName and fieldName:
        return (schemaName, fieldName)
    elif not fnRequired:
      schemaName = sn_fn.strip()
      if schemaName:
        return (schemaName, None)
    invalidArgumentExit(OB_SCHEMA_NAME_FIELD_NAME)

  if updateCmd:
    body = {}
    need_password = False
  else:
    body = {u'name': {u'givenName': u'Unknown', u'familyName': u'Unknown'}}
    body[u'primaryEmail'] = getEmailAddress(noUid=noUid)
    need_password = True
  need_to_hash_password = True
  admin_body = {}
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'admin':
      admin_body[u'status'] = getBoolean()
    elif myarg == u'nohash':
      need_to_hash_password = False
    elif myarg in UPDATE_USER_ARGUMENT_TO_PROPERTY_MAP:
      up = UPDATE_USER_ARGUMENT_TO_PROPERTY_MAP[myarg]
      userProperty = UProp.PROPERTIES[up]
      propertyClass = userProperty[UProp.CLASS]
      if UProp.TYPE_KEYWORDS in userProperty:
        typeKeywords = userProperty[UProp.TYPE_KEYWORDS]
        clTypeKeyword = typeKeywords[UProp.PTKW_CL_TYPE_KEYWORD]
      if up == u'givenName':
        body.setdefault(u'name', {})
        body[u'name'][up] = getString(OB_STRING, minLen=0)
      elif up == u'familyName':
        body.setdefault(u'name', {})
        body[u'name'][up] = getString(OB_STRING, minLen=0)
      elif up == u'password':
        need_password = False
        body[up] = getString(OB_PASSWORD)
        if body[up].lower() == u'random':
          need_password = True
      elif propertyClass == UProp.PC_BOOLEAN:
        body[up] = getBoolean()
      elif up == u'hashFunction':
        body[up] = HASH_FUNCTION_MAP[myarg]
        need_to_hash_password = False
      elif up == u'primaryEmail' and updateCmd:
        body[up] = getEmailAddress(noUid=True)
      elif up == u'customerId' and updateCmd:
        body[up] = getString(OB_STRING)
      elif up == u'orgUnitPath':
        body[up] = getOrgUnitItem(pathOnly=True)
      elif up == u'addresses':
        if checkArgumentPresent(CLEAR_NONE_ARGUMENT):
          clearBodyList(body, up)
          continue
        entry = {}
        getChoice([clTypeKeyword,])
        getKeywordAttribute(UProp, typeKeywords, entry)
        if checkArgumentPresent(UNSTRUCTURED_FORMATTED_ARGUMENT):
          entry[u'sourceIsStructured'] = False
          entry[u'formatted'] = getString(OB_STRING, minLen=0).replace(u'\\n', u'\n')
        while CLArgs.ArgumentsRemaining():
          argument = getArgument()
          if argument in ADDRESS_ARGUMENT_TO_FIELD_MAP:
            value = getString(OB_STRING, minLen=0)
            if value:
              entry[ADDRESS_ARGUMENT_TO_FIELD_MAP[argument]] = value
          elif argument == u'notprimary':
            break
          elif argument == u'primary':
            entry[u'primary'] = True
            break
          else:
            unknownArgumentExit()
        appendItemToBodyList(body, up, entry)
      elif up == u'ims':
        if checkArgumentPresent(CLEAR_NONE_ARGUMENT):
          clearBodyList(body, up)
          continue
        entry = {}
        getChoice([clTypeKeyword,])
        getKeywordAttribute(UProp, typeKeywords, entry)
        getChoice([UProp.IM_PROTOCOLS[UProp.PTKW_CL_TYPE_KEYWORD],])
        getKeywordAttribute(UProp, UProp.IM_PROTOCOLS, entry)
        # Backwards compatability: notprimary|primary on either side of IM address
        entry[u'primary'] = getChoice(PRIMARY_NOTPRIMARY_CHOICE_MAP, defaultChoice=False, mapChoice=True)
        entry[u'im'] = getString(OB_STRING, minLen=0)
        entry[u'primary'] = getChoice(PRIMARY_NOTPRIMARY_CHOICE_MAP, defaultChoice=entry[u'primary'], mapChoice=True)
        appendItemToBodyList(body, up, entry, u'im')
      elif up == u'notes':
        if checkArgumentPresent(CLEAR_NONE_ARGUMENT):
          clearBodyList(body, up)
          continue
        entry = {}
        getKeywordAttribute(UProp, typeKeywords, entry, defaultChoice=u'text_plain')
        if checkArgumentPresent(FILE_ARGUMENT):
          entry[u'value'] = readFile(getString(OB_FILE_NAME), encoding=GM_Globals[GM_SYS_ENCODING])
        else:
          entry[u'value'] = getString(OB_STRING, minLen=0).replace(u'\\n', u'\n')
        body[up] = entry
      elif up == u'organizations':
        if checkArgumentPresent(CLEAR_NONE_ARGUMENT):
          clearBodyList(body, up)
          continue
        entry = {}
        while CLArgs.ArgumentsRemaining():
          argument = getArgument()
          if argument == clTypeKeyword:
            getKeywordAttribute(UProp, typeKeywords, entry)
          elif argument == typeKeywords[UProp.PTKW_CL_CUSTOMTYPE_KEYWORD]:
#            entry[typeKeywords[UProp.PTKW_ATTR_TYPE_KEYWORD]] = typeKeywords[UProp.PTKW_ATTR_TYPE_CUSTOM_VALUE]
            entry[typeKeywords[UProp.PTKW_ATTR_CUSTOMTYPE_KEYWORD]] = getString(OB_STRING)
          elif argument in ORGANIZATION_ARGUMENT_TO_FIELD_MAP:
            value = getString(OB_STRING, minLen=0)
            if value:
              entry[ORGANIZATION_ARGUMENT_TO_FIELD_MAP[argument]] = value
          elif argument == u'notprimary':
            break
          elif argument == u'primary':
            entry[u'primary'] = True
            break
          else:
            unknownArgumentExit()
        appendItemToBodyList(body, up, entry)
      elif up == u'phones':
        if checkArgumentPresent(CLEAR_NONE_ARGUMENT):
          clearBodyList(body, up)
          continue
        entry = {}
        while CLArgs.ArgumentsRemaining():
          argument = getArgument()
          if argument == clTypeKeyword:
            getKeywordAttribute(UProp, typeKeywords, entry)
          elif argument == u'value':
            entry[u'value'] = getString(OB_STRING, minLen=0)
          elif argument == u'notprimary':
            break
          elif argument == u'primary':
            entry[u'primary'] = True
            break
          else:
            unknownArgumentExit()
        appendItemToBodyList(body, up, entry, u'value')
      elif up == u'relations':
        if checkArgumentPresent(CLEAR_NONE_ARGUMENT):
          clearBodyList(body, up)
          continue
        entry = {}
        getKeywordAttribute(UProp, typeKeywords, entry)
        entry[u'value'] = getString(OB_STRING, minLen=0)
        appendItemToBodyList(body, up, entry, u'value')
      elif up == u'emails':
        if checkArgumentPresent(CLEAR_NONE_ARGUMENT):
          clearBodyList(body, up)
          continue
        entry = {}
        getKeywordAttribute(UProp, typeKeywords, entry)
        entry[u'address'] = getEmailAddress(noUid=True, minLen=0)
        appendItemToBodyList(body, up, entry, u'address')
      elif up == u'externalIds':
        if checkArgumentPresent(CLEAR_NONE_ARGUMENT):
          clearBodyList(body, up)
          continue
        entry = {}
        getKeywordAttribute(UProp, typeKeywords, entry)
        entry[u'value'] = getString(OB_STRING, minLen=0)
        appendItemToBodyList(body, up, entry, u'value')
      elif up == u'websites':
        if checkArgumentPresent(CLEAR_NONE_ARGUMENT):
          clearBodyList(body, up)
          continue
        entry = {}
        getKeywordAttribute(UProp, typeKeywords, entry)
        entry[u'value'] = getString(OB_URL, minLen=0)
        entry[u'primary'] = getChoice(PRIMARY_NOTPRIMARY_CHOICE_MAP, defaultChoice=False, mapChoice=True)
        appendItemToBodyList(body, up, entry, u'value')
    elif myarg == u'clearschema':
      if not updateCmd:
        unknownArgumentExit()
      schemaName, fieldName = _splitSchemaNameDotFieldName(getString(OB_SCHEMA_NAME_FIELD_NAME), False)
      up = u'customSchemas'
      body.setdefault(up, {})
      body[up].setdefault(schemaName, {})
      if fieldName is None:
        try:
          schema = callGAPI(cd.schemas(), u'get',
                            throw_reasons=[GAPI_INVALID, GAPI_BAD_REQUEST, GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN],
                            customerId=GC_Values[GC_CUSTOMER_ID], schemaKey=schemaName, fields=u'fields(fieldName)')
          for field in schema[u'fields']:
            body[up][schemaName][field[u'fieldName']] = None
        except (GAPI_invalid, GAPI_badRequest, GAPI_resourceNotFound, GAPI_forbidden):
          entityDoesNotExistWarning(Entity.USER_SCHEMA, schemaName, 0, 0)
          unknownArgumentExit()
      else:
        body[up][schemaName][fieldName] = None
    elif myarg.find(u'.') >= 0:
      schemaName, fieldName = _splitSchemaNameDotFieldName(CLArgs.Previous())
      up = u'customSchemas'
      body.setdefault(up, {})
      body[up].setdefault(schemaName, {})
      multivalue = checkArgumentPresent(MULTIVALUE_ARGUMENT)
      if multivalue:
        body[up][schemaName].setdefault(fieldName, [])
        typeKeywords = UProp.PROPERTIES[up][UProp.TYPE_KEYWORDS]
        clTypeKeyword = typeKeywords[UProp.PTKW_CL_TYPE_KEYWORD]
        schemaValue = {}
        if checkArgumentPresent([clTypeKeyword,]):
          getKeywordAttribute(UProp, typeKeywords, schemaValue)
        schemaValue[u'value'] = getString(OB_STRING, minLen=0)
        if schemaValue[u'value'] or multivalue != u'multinonempty':
          body[up][schemaName][fieldName].append(schemaValue)
      else:
        body[up][schemaName][fieldName] = getString(OB_STRING, minLen=0)
    else:
      unknownArgumentExit()
  if need_password:
    body[u'password'] = u''.join(random.sample(u'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789~`!@#$%^&*()-=_+:;"\'{}[]\\|', 25))
  if u'password' in body and need_to_hash_password:
    body[u'password'] = gen_sha512_hash(body[u'password'])
    body[u'hashFunction'] = u'crypt'
  return (body, admin_body)

def changeAdminStatus(cd, user, admin_body, i=0, count=0):
  try:
    callGAPI(cd.users(), u'makeAdmin',
             throw_reasons=[GAPI_USER_NOT_FOUND, GAPI_DOMAIN_NOT_FOUND, GAPI_FORBIDDEN],
             userKey=user, body=admin_body)
    printEntityKVList([Entity.USER, user], [PHRASE_ADMIN_STATUS_CHANGED_TO, admin_body[u'status']], i, count)
  except (GAPI_userNotFound, GAPI_domainNotFound, GAPI_forbidden):
    entityUnknownWarning(Entity.USER, user, i, count)

# gam create user <EmailAddress> <UserAttributes>
def doCreateUser():
  cd = buildGAPIObject(DIRECTORY_API)
  body, admin_body = getUserAttributes(cd, False, noUid=True)
  user = body[u'primaryEmail']
  try:
    callGAPI(cd.users(), u'insert',
             throw_reasons=[GAPI_DUPLICATE, GAPI_DOMAIN_NOT_FOUND, GAPI_FORBIDDEN, GAPI_INVALID, GAPI_INVALID_ORGUNIT, GAPI_INVALID_SCHEMA_VALUE],
             body=body, fields=u'')
    entityActionPerformed([Entity.USER, user])
    if admin_body:
      changeAdminStatus(cd, user, admin_body)
  except GAPI_duplicate:
    entityDuplicateWarning(Entity.USER, user)
  except (GAPI_domainNotFound, GAPI_forbidden) as e:
    entityActionFailedWarning([Entity.USER, user], e.message)
  except GAPI_invalidSchemaValue:
    entityActionFailedWarning([Entity.USER, user], PHRASE_INVALID_SCHEMA_VALUE)
  except GAPI_invalid as e:
    entityActionFailedWarning([Entity.USER, user], e.message)
  except GAPI_invalidOrgunit:
    entityActionFailedWarning([Entity.USER, user], PHRASE_INVALID_ORGUNIT)

# gam <UserTypeEntity> update user <UserAttributes>
def updateUsers(entityList):
  cd = buildGAPIObject(DIRECTORY_API)
  body, admin_body = getUserAttributes(cd, True)
  i, count, entityList = getEntityArgument(entityList)
  for user in entityList:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      if (u'primaryEmail' in body) and (body[u'primaryEmail'][:4].lower() == u'vfe@'):
        user_primary = callGAPI(cd.users(), u'get',
                                throw_reasons=GAPI_USER_GET_THROW_REASONS,
                                userKey=user, fields=u'primaryEmail,id')
        user = user_primary[u'id']
        user_primary = user_primary[u'primaryEmail']
        user_name, user_domain = splitEmailAddress(user_primary)
        body[u'primaryEmail'] = u'vfe.{0}.{1:05}@{2}'.format(user_name, random.randint(1, 99999), user_domain)
        body[u'emails'] = [{u'type': u'custom',
                            u'customType': u'former_employee',
                            u'primary': False, u'address': user_primary}]
      if body:
        callGAPI(cd.users(), u'update',
                 throw_reasons=[GAPI_USER_NOT_FOUND, GAPI_DOMAIN_NOT_FOUND, GAPI_FORBIDDEN, GAPI_INVALID, GAPI_INVALID_ORGUNIT, GAPI_INVALID_SCHEMA_VALUE],
                 userKey=user, body=body, fields=u'')
        entityActionPerformed([Entity.USER, user], i, count)
      if admin_body:
        changeAdminStatus(cd, user, admin_body, i, count)
    except (GAPI_userNotFound, GAPI_domainNotFound, GAPI_forbidden, GAPI_badRequest, GAPI_backendError, GAPI_systemError):
      entityUnknownWarning(Entity.USER, user, i, count)
    except GAPI_invalidSchemaValue:
      entityActionFailedWarning([Entity.USER, user], PHRASE_INVALID_SCHEMA_VALUE, i, count)
    except GAPI_invalid as e:
      entityActionFailedWarning([Entity.USER, user], e.message, i, count)
    except GAPI_invalidOrgunit:
      entityActionFailedWarning([Entity.USER, user], PHRASE_INVALID_ORGUNIT, i, count)

# gam update users <UserTypeEntity> <UserAttributes>
def doUpdateUsers():
  updateUsers(getEntityToModify(defaultEntityType=CL_ENTITY_USERS)[1])

# gam update user <UserItem> <UserAttributes>
def doUpdateUser():
  updateUsers(getStringReturnInList(OB_USER_ITEM))

# gam <UserTypeEntity> delete users
def deleteUsers(entityList):
  cd = buildGAPIObject(DIRECTORY_API)
  checkForExtraneousArguments()
  i, count, entityList = getEntityArgument(entityList)
  for user in entityList:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      callGAPI(cd.users(), u'delete',
               throw_reasons=[GAPI_USER_NOT_FOUND, GAPI_DOMAIN_NOT_FOUND, GAPI_FORBIDDEN],
               userKey=user)
      entityActionPerformed([Entity.USER, user], i, count)
    except (GAPI_userNotFound, GAPI_domainNotFound, GAPI_forbidden):
      entityUnknownWarning(Entity.USER, user, i, count)

# gam delete users <UserTypeEntity>
def doDeleteUsers():
  deleteUsers(getEntityToModify(defaultEntityType=CL_ENTITY_USERS)[1])

# gam delete user <UserItem>
def doDeleteUser():
  deleteUsers(getStringReturnInList(OB_USER_ITEM))

# gam <UserEntity> undelete users [org|ou <OrgUnitPath>]
def undeleteUsers(entityList):
  cd = buildGAPIObject(DIRECTORY_API)
  if checkArgumentPresent(ORG_OU_ARGUMENT):
    orgUnitPaths = getEntityList(OB_ORGUNIT_ENTITY, shlexSplit=True)
    userOrgUnitLists = orgUnitPaths if isinstance(orgUnitPaths, dict) else None
  else:
    orgUnitPaths = [u'/']
    userOrgUnitLists = None
  checkForExtraneousArguments()
  body = {u'orgUnitPath': u''}
  i, count, entityList = getEntityArgument(entityList)
  for user in entityList:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    user_uid = user if user.find(u'@') == -1 else None
    if not user_uid:
      printEntityKVList([Entity.DELETED_USER, user],
                        [PHRASE_LOOKING_UP_GOOGLE_UNIQUE_ID, None],
                        i, count)
      try:
        deleted_users = callGAPIpages(cd.users(), u'list', u'users',
                                      throw_reasons=[GAPI_BAD_REQUEST, GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN],
                                      customer=GC_Values[GC_CUSTOMER_ID], showDeleted=True, maxResults=GC_Values[GC_USER_MAX_RESULTS])
      except (GAPI_badRequest, GAPI_resourceNotFound, GAPI_forbidden):
        accessErrorExit(cd)
      matching_users = []
      for deleted_user in deleted_users:
        if str(deleted_user[u'primaryEmail']).lower() == user:
          matching_users.append(deleted_user)
      jcount = len(matching_users)
      if jcount == 0:
        entityUnknownWarning(Entity.DELETED_USER, user, i, count)
        setSysExitRC(NO_ENTITIES_FOUND)
        continue
      if jcount > 1:
        entityActionNotPerformedWarning([Entity.DELETED_USER, user],
                                        PHRASE_PLEASE_SELECT_ENTITY_TO_PROCESS.format(jcount, Entity.Plural(Entity.DELETED_USER), u'undelete', 'uid:<String>'),
                                        i, count)
        Indent.Increment()
        j = 0
        for matching_user in matching_users:
          printEntity([Entity.UNIQUE_ID, matching_user[u'id']], j, jcount)
          Indent.Increment()
          for attr_name in [u'creationTime', u'lastLoginTime', u'deletionTime']:
            if attr_name in matching_user:
              printKeyValueList([attr_name, formatLocalTime(matching_user[attr_name])])
          Indent.Decrement()
        Indent.Decrement()
        setSysExitRC(MULTIPLE_DELETED_USERS_FOUND_RC)
        continue
      user_uid = matching_users[0][u'id']
    if userOrgUnitLists:
      orgUnitPaths = userOrgUnitLists[user]
    body[u'orgUnitPath'] = makeOrgUnitPathAbsolute(orgUnitPaths[0])
    try:
      callGAPI(cd.users(), u'undelete',
               throw_reasons=[GAPI_BAD_REQUEST, GAPI_INVALID, GAPI_INVALID_ORGUNIT, GAPI_DELETED_USER_NOT_FOUND],
               userKey=user_uid, body=body)
      entityActionPerformed([Entity.DELETED_USER, user], i, count)
    except (GAPI_badRequest, GAPI_invalid, GAPI_deletedUserNotFound):
      entityUnknownWarning(Entity.DELETED_USER, user, i, count)
    except GAPI_invalidOrgunit:
      entityActionFailedWarning([Entity.USER, user], PHRASE_INVALID_ORGUNIT, i, count)

# gam undelete users <UserEntity> [org|ou <OrgUnitPath>]
def doUndeleteUsers():
  undeleteUsers(getEntityList(OB_USER_ENTITY))

# gam undelete user <UserItem> [org|ou <OrgUnitPath>]
def doUndeleteUser():
  undeleteUsers(getStringReturnInList(OB_USER_ITEM))

USER_NAME_PROPERTY_PRINT_ORDER = [
  u'givenName',
  u'familyName',
  u'fullName',
  ]
USER_SCALAR_PROPERTY_PRINT_ORDER = [
  u'isAdmin',
  u'isDelegatedAdmin',
  u'isEnrolledIn2Sv',
  u'isEnforcedIn2Sv',
  u'agreedToTerms',
  u'ipWhitelisted',
  u'suspended',
  u'suspensionReason',
  u'changePasswordAtNextLogin',
  u'id',
  u'customerId',
  u'isMailboxSetup',
  u'includeInGlobalAddressList',
  u'creationTime',
  u'lastLoginTime',
  u'deletionTime',
  u'orgUnitPath',
  u'thumbnailPhotoUrl',
  ]
USER_ARRAY_PROPERTY_PRINT_ORDER = [
  u'notes',
  u'addresses',
  u'organizations',
  u'relations',
  u'emails',
  u'ims',
  u'phones',
  u'externalIds',
  u'websites',
  ]

USER_ADDRESSES_PROPERTY_PRINT_ORDER = [
  u'sourceIsStructured',
  u'formatted',
  u'extendedAddress',
  u'streetAddress',
  u'poBox',
  u'locality',
  u'region',
  u'postalCode',
  u'country',
  u'countryCode',
  ]

def _showType(up, row, typeKey, typeCustomValue, customTypeKey):
  if typeKey in row:
    if (row[typeKey] != typeCustomValue) or (not customTypeKey in row) or (not row[customTypeKey]):
      printKeyValueList([typeKey, row[typeKey]])
    elif up in [u'emails', u'externalIds', u'relations', u'websites']:
      printKeyValueList([typeKey, row[customTypeKey]])
    else:
      printKeyValueList([typeKey, row[typeKey]])
      Indent.Increment()
      printKeyValueList([customTypeKey, row[customTypeKey]])
      Indent.Decrement()
    return True
  elif customTypeKey in row:
    printKeyValueList([customTypeKey, row[customTypeKey]])
    return True
  return False
#
USER_ARGUMENT_TO_PROPERTY_MAP = {
  u'address': [u'addresses',],
  u'addresses': [u'addresses',],
  u'admin': [u'isAdmin', u'isDelegatedAdmin',],
  u'agreed2terms': [u'agreedToTerms',],
  u'agreedtoterms': [u'agreedToTerms',],
  u'aliases': [u'aliases', u'nonEditableAliases',],
  u'changepassword': [u'changePasswordAtNextLogin',],
  u'changepasswordatnextlogin': [u'changePasswordAtNextLogin',],
  u'creationtime': [u'creationTime',],
  u'deletiontime': [u'deletionTime',],
  u'email': [u'emails',],
  u'emails': [u'emails',],
  u'externalid': [u'externalIds',],
  u'externalids': [u'externalIds',],
  u'familyname': [u'name.familyName',],
  u'firstname': [u'name.givenName',],
  u'fullname': [u'name.fullName',],
  u'gal': [u'includeInGlobalAddressList',],
  u'givenname': [u'name.givenName',],
  u'id': [u'id',],
  u'im': [u'ims',],
  u'ims': [u'ims',],
  u'includeinglobaladdresslist': [u'includeInGlobalAddressList',],
  u'ipwhitelisted': [u'ipWhitelisted',],
  u'isadmin': [u'isAdmin', u'isDelegatedAdmin',],
  u'isdelegatedadmin': [u'isAdmin', u'isDelegatedAdmin',],
  u'is2svenforced': [u'isEnforcedIn2Sv',],
  u'is2svenrolled': [u'isEnrolledIn2Sv',],
  u'ismailboxsetup': [u'isMailboxSetup',],
  u'lastlogintime': [u'lastLoginTime',],
  u'lastname': [u'name.familyName',],
  u'name': [u'name.givenName', u'name.familyName', u'name.fullName',],
  u'nicknames': [u'aliases', u'nonEditableAliases',],
  u'noneditablealiases': [u'aliases', u'nonEditableAliases',],
  u'note': [u'notes',],
  u'notes': [u'notes',],
  u'org': [u'orgUnitPath',],
  u'organization': [u'organizations',],
  u'organizations': [u'organizations',],
  u'orgunitpath': [u'orgUnitPath',],
  u'otheremail': [u'emails',],
  u'otheremails': [u'emails',],
  u'ou': [u'orgUnitPath',],
  u'phone': [u'phones',],
  u'phones': [u'phones',],
  u'photo': [u'thumbnailPhotoUrl',],
  u'photourl': [u'thumbnailPhotoUrl',],
  u'primaryemail': [u'primaryEmail',],
  u'relation': [u'relations',],
  u'relations': [u'relations',],
  u'suspended': [u'suspended', u'suspensionReason',],
  u'thumbnailphotourl': [u'thumbnailPhotoUrl',],
  u'username': [u'primaryEmail',],
  u'website': [u'websites',],
  u'websites': [u'websites',],
  }

INFO_USER_OPTIONS = [u'noaliases', u'nogroups', u'nolicenses', u'nolicences', u'noschemas', u'schemas', u'userview',]
USER_TIME_OBJECTS = [u'creationTime', u'deletionTime', u'lastLoginTime']

def infoUsers(entityList):
  from gamlib import gluprop as UProp

  def _callbackGetLicense(request_id, response, exception):
    if exception is None:
      if response and u'skuId' in response:
        licenses.append(response[u'skuId'])

  cd = buildGAPIObject(DIRECTORY_API)
  getSchemas = getAliases = getGroups = getLicenses = True
  formatJSON = False
  projection = u'full'
  customFieldMask = viewType = None
  fieldsList = []
  groups = collections.deque()
  licenses = []
  skus = sorted(SKUS.keys())
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'noaliases':
      getAliases = False
    elif myarg == u'nogroups':
      getGroups = False
    elif myarg in [u'nolicenses', u'nolicences']:
      getLicenses = False
    elif myarg in [u'products', u'product']:
      skus = []
      for productId in getGoogleProductList():
        skus += [skuId for skuId in SKUS if SKUS[skuId][u'product'] == productId]
    elif myarg in [u'sku', u'skus']:
      skus = getGoogleSKUList()
    elif myarg == u'noschemas':
      getSchemas = False
      projection = u'basic'
    elif myarg in [u'custom', u'schemas']:
      getSchemas = True
      projection = u'custom'
      customFieldMask = getString(OB_SCHEMA_NAME_LIST)
    elif myarg == u'userview':
      viewType = u'domain_public'
      getGroups = getLicenses = False
    elif myarg in USER_ARGUMENT_TO_PROPERTY_MAP:
      if not fieldsList:
        fieldsList = [u'primaryEmail',]
      fieldsList.extend(USER_ARGUMENT_TO_PROPERTY_MAP[myarg])
    elif myarg == u'fields':
      if not fieldsList:
        fieldsList.append(u'primaryEmail')
      fieldNameList = getString(OB_FIELD_NAME_LIST)
      for field in fieldNameList.lower().replace(u',', u' ').split():
        if field in USER_ARGUMENT_TO_PROPERTY_MAP:
          fieldsList.extend(USER_ARGUMENT_TO_PROPERTY_MAP[field])
        else:
          CLArgs.Backup()
          invalidChoiceExit(USER_ARGUMENT_TO_PROPERTY_MAP)
# Ignore info group arguments that may have come from whatis
    elif myarg in INFO_GROUP_OPTIONS:
      pass
    elif myarg == "formatjson":
      formatJSON = True
    else:
      unknownArgumentExit()
  fields = u','.join(set(fieldsList)).replace(u'.', u'/') if fieldsList else None
  if getLicenses:
    lic = buildGAPIObject(LICENSING_API)
  i, count, entityList = getEntityArgument(entityList)
  for userEmail in entityList:
    i += 1
    userEmail = normalizeEmailAddressOrUID(userEmail)
    try:
      user = callGAPI(cd.users(), u'get',
                      throw_reasons=GAPI_USER_GET_THROW_REASONS,
                      userKey=userEmail, projection=projection, customFieldMask=customFieldMask, viewType=viewType, fields=fields)
      if getGroups:
        groups = callGAPIpages(cd.groups(), u'list', u'groups',
                               userKey=user[u'primaryEmail'], fields=u'nextPageToken,groups(name,email)')
      if getLicenses:
        svcargs = dict([(u'userId', None), (u'productId', None), (u'skuId', None), (u'fields', u'skuId')]+GM_Globals[GM_EXTRA_ARGS_LIST])
        dbatch = googleapiclient.http.BatchHttpRequest(callback=_callbackGetLicense)
        for skuId in skus:
          svcparms = svcargs.copy()
          svcparms[u'userId'] = user[u'primaryEmail']
          svcparms[u'productId'], svcparms[u'skuId'] = getProductAndSKU(skuId)
          dbatch.add(lic.licenseAssignments().get(**svcparms))
        dbatch.execute()
      if formatJSON:
        if getGroups:
          user[u'groups'] = list(groups)
        if getLicenses:
          user[u'licenses'] = [_formatSKUIdDisplayName(u_license) for u_license in licenses]
        printLine(json.dumps(user, ensure_ascii=False, sort_keys=True))
        continue
      printEntity([Entity.USER, user[u'primaryEmail']], i, count)
      Indent.Increment()
      printKeyValueList([u'Settings', None])
      Indent.Increment()
      if u'name' in user:
        for up in USER_NAME_PROPERTY_PRINT_ORDER:
          if up in user[u'name']:
            printKeyValueList([UProp.PROPERTIES[up][UProp.TITLE], user[u'name'][up]])
      for up in USER_SCALAR_PROPERTY_PRINT_ORDER:
        if up in user:
          if up not in USER_TIME_OBJECTS:
            printKeyValueList([UProp.PROPERTIES[up][UProp.TITLE], user[up]])
          else:
            printKeyValueList([UProp.PROPERTIES[up][UProp.TITLE], formatLocalTime(user[up])])
      Indent.Decrement()
      for up in USER_ARRAY_PROPERTY_PRINT_ORDER:
        if up not in user:
          continue
        propertyValue = user[up]
        userProperty = UProp.PROPERTIES[up]
        propertyClass = userProperty[UProp.CLASS]
        propertyTitle = userProperty[UProp.TITLE]
        typeKey = userProperty[UProp.TYPE_KEYWORDS][UProp.PTKW_ATTR_TYPE_KEYWORD]
        typeCustomValue = userProperty[UProp.TYPE_KEYWORDS][UProp.PTKW_ATTR_TYPE_CUSTOM_VALUE]
        customTypeKey = userProperty[UProp.TYPE_KEYWORDS][UProp.PTKW_ATTR_CUSTOMTYPE_KEYWORD]
        if propertyClass == UProp.PC_ARRAY:
          if len(propertyValue) > 0:
            printKeyValueList([propertyTitle, None])
            Indent.Increment()
            if isinstance(propertyValue, list):
              for row in propertyValue:
                _showType(up, row, typeKey, typeCustomValue, customTypeKey)
                Indent.Increment()
                for key in row:
                  if key in [typeKey, customTypeKey]:
                    continue
                  printKeyValueList([key, row[key]])
                Indent.Decrement()
            else:
              printKeyValueList([propertyClass, propertyValue])
            Indent.Decrement()
        elif propertyClass == UProp.PC_ADDRESSES:
          if len(propertyValue) > 0:
            printKeyValueList([propertyTitle, None])
            Indent.Increment()
            if isinstance(propertyValue, list):
              for row in propertyValue:
                _showType(up, row, typeKey, typeCustomValue, customTypeKey)
                Indent.Increment()
                for key in USER_ADDRESSES_PROPERTY_PRINT_ORDER:
                  if key in row:
                    if key != u'formatted':
                      printKeyValueList([key, row[key]])
                    else:
                      printKeyValueList([key, convertCRsNLs(row[key])])
                Indent.Decrement()
            else:
              printKeyValueList([propertyClass, propertyValue])
            Indent.Decrement()
        elif propertyClass == UProp.PC_EMAILS:
          if len(propertyValue) > 0:
            needTitle = True
            if isinstance(propertyValue, list):
              for row in propertyValue:
                if row[u'address'].lower() == user[u'primaryEmail'].lower():
                  continue
                if needTitle:
                  needTitle = False
                  printKeyValueList([propertyTitle, None])
                  Indent.Increment()
                if not _showType(up, row, typeKey, typeCustomValue, customTypeKey):
                  if not getAliases:
                    continue
                  printKeyValueList([typeKey, u'alias'])
                Indent.Increment()
                for key in row:
                  if key in [typeKey, customTypeKey]:
                    continue
                  printKeyValueList([key, row[key]])
                Indent.Decrement()
            else:
              printKeyValueList([propertyClass, propertyValue])
            if not needTitle:
              Indent.Decrement()
        elif propertyClass == UProp.PC_IMS:
          if len(propertyValue) > 0:
            printKeyValueList([propertyTitle, None])
            Indent.Increment()
            if isinstance(propertyValue, list):
              protocolKey = UProp.IM_PROTOCOLS[UProp.PTKW_ATTR_TYPE_KEYWORD]
              protocolCustomValue = UProp.IM_PROTOCOLS[UProp.PTKW_ATTR_TYPE_CUSTOM_VALUE]
              customProtocolKey = UProp.IM_PROTOCOLS[UProp.PTKW_ATTR_CUSTOMTYPE_KEYWORD]
              for row in propertyValue:
                _showType(up, row, typeKey, typeCustomValue, customTypeKey)
                Indent.Increment()
                _showType(up, row, protocolKey, protocolCustomValue, customProtocolKey)
                for key in row:
                  if key in [typeKey, customTypeKey, protocolKey, customProtocolKey]:
                    continue
                  printKeyValueList([key, row[key]])
                Indent.Decrement()
            else:
              printKeyValueList([propertyClass, propertyValue])
            Indent.Decrement()
        elif propertyClass == UProp.PC_NOTES:
          if len(propertyValue) > 0:
            printKeyValueList([propertyTitle, None])
            Indent.Increment()
            if isinstance(propertyValue, dict):
              typeVal = propertyValue.get(typeKey, u'text_plain')
              printKeyValueList([typeKey, typeVal])
              Indent.Increment()
              if typeVal == u'text_html':
                printKeyValueList([u'value', Indent.MultiLineText(dehtml(propertyValue[u'value']), n=1)])
              else:
                printKeyValueList([u'value', Indent.MultiLineText(propertyValue[u'value'], n=1)])
              Indent.Decrement()
            else:
              printKeyValueList([Indent.MultiLineText(propertyValue)])
            Indent.Decrement()
      if getSchemas:
        up = u'customSchemas'
        if up in user:
          propertyValue = user[up]
          userProperty = UProp.PROPERTIES[up]
          propertyTitle = userProperty[UProp.TITLE]
          typeKey = userProperty[UProp.TYPE_KEYWORDS][UProp.PTKW_ATTR_TYPE_KEYWORD]
          typeCustomValue = userProperty[UProp.TYPE_KEYWORDS][UProp.PTKW_ATTR_TYPE_CUSTOM_VALUE]
          customTypeKey = userProperty[UProp.TYPE_KEYWORDS][UProp.PTKW_ATTR_CUSTOMTYPE_KEYWORD]
          printKeyValueList([UProp.PROPERTIES[up][UProp.TITLE], None])
          Indent.Increment()
          for schema in propertyValue:
            printKeyValueList([u'Schema', schema])
            Indent.Increment()
            for field in propertyValue[schema]:
              if isinstance(propertyValue[schema][field], list):
                printKeyValueList([field])
                Indent.Increment()
                for an_item in propertyValue[schema][field]:
                  _showType(up, an_item, typeKey, typeCustomValue, customTypeKey)
                  Indent.Increment()
                  printKeyValueList([u'value', an_item[u'value']])
                  Indent.Decrement()
                Indent.Decrement()
              else:
                printKeyValueList([field, propertyValue[schema][field]])
            Indent.Decrement()
          Indent.Decrement()
      if getAliases:
        for up in [u'aliases', u'nonEditableAliases',]:
          if up in user:
            propertyValue = user[up]
            printKeyValueList([UProp.PROPERTIES[up][UProp.TITLE], None])
            Indent.Increment()
            for alias in propertyValue:
              printKeyValueList([alias])
            Indent.Decrement()
      if groups:
        printEntitiesCount(Entity.GROUP, groups)
        Indent.Increment()
        for group in groups:
          printKeyValueList([group[u'name'], group[u'email']])
        Indent.Decrement()
      if licenses:
        printEntitiesCount(Entity.LICENSE, licenses)
        Indent.Increment()
        for u_license in licenses:
          printKeyValueList([_formatSKUIdDisplayName(u_license)])
        Indent.Decrement()
      Indent.Decrement()
    except (GAPI_userNotFound, GAPI_domainNotFound, GAPI_forbidden, GAPI_badRequest, GAPI_backendError, GAPI_systemError):
      entityUnknownWarning(Entity.USER, userEmail, i, count)

# gam info users <UserTypeEntity> [noaliases] [nogroups] [nolicenses|nolicences] [noschemas] [schemas|custom <SchemaNameList>] [userview] [fields <UserFieldNameList>] [products|product <ProductIDList>] [skus|sku <SKUIDList>] [formatjson]
def doInfoUsers():
  infoUsers(getEntityToModify(defaultEntityType=CL_ENTITY_USERS)[1])

# gam info user <UserItem> [noaliases] [nogroups] [nolicenses|nolicences] [noschemas] [schemas|custom <SchemaNameList>] [userview] [fields <UserFieldNameList>] [products|product <ProductIDList>] [skus|sku <SKUIDList>] [formatjson]
# gam info user
def doInfoUser():
  if CLArgs.ArgumentsRemaining():
    infoUsers(getStringReturnInList(OB_USER_ITEM))
  else:
    credentials = getClientCredentials(OAUTH2_FAM1_SCOPES)
    infoUsers([credentials.id_token[u'email']])

USERS_ORDERBY_CHOICES_MAP = {
  u'familyname': u'familyName',
  u'lastname': u'familyName',
  u'givenname': u'givenName',
  u'firstname': u'givenName',
  u'email': u'email',
  }

# gam <UserTypeEntity> print
def doPrintUserEntity(entityList):
  if not CLArgs.ArgumentsRemaining():
    _, _, entityList = getEntityArgument(entityList)
    for entity in entityList:
      printLine(normalizeEmailAddressOrUID(entity))
    return
  doPrintUsers(entityList)

# gam [<UserTypeEntity>] print users [todrive [<ToDriveAttributes>]] ([domain <DomainName>] [query <QueryUsers>] [deleted_only|only_deleted])|[select <UserTypeEntity>]
#	[groups] [license|licenses|licence|licences] [emailpart|emailparts|username] [schemas|custom all|<SchemaNameList>]
#	[orderby <UserOrderByFieldName> [ascending|descending]] [userview]
#	[basic|full|allfields | <UserFieldName>* | fields <UserFieldNameList>] [delimiter <String>]
def doPrintUsers(entityList=None):
  def _printUser(userEntity):
    if email_parts and (u'primaryEmail' in userEntity):
      userEmail = userEntity[u'primaryEmail']
      if userEmail.find(u'@') != -1:
        userEntity[u'primaryEmailLocal'], userEntity[u'primaryEmailDomain'] = splitEmailAddress(userEmail)
    addRowTitlesToCSVfile(flattenJSON(userEntity, time_objects=USER_TIME_OBJECTS), csvRows, titles)

  _PRINT_USER_REASON_TO_MESSAGE_MAP = {GAPI_RESOURCE_NOT_FOUND: PHRASE_DOES_NOT_EXIST}
  def _callbackPrintUser(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      _printUser(response)
    else:
      http_status, reason, message = checkGAPIError(exception)
      if reason in GAPI_USER_GET_THROW_REASONS:
        entityUnknownWarning(Entity.USER, ri[RI_ITEM], int(ri[RI_J]), int(ri[RI_JCOUNT]))
      else:
        errMsg = getHTTPError(_PRINT_USER_REASON_TO_MESSAGE_MAP, http_status, reason, message)
        printKeyValueList([ERROR, errMsg])

  cd = buildGAPIObject(DIRECTORY_API)
  todrive = {}
  fieldsList = []
  fieldsTitles = {}
  titles, csvRows = initializeTitlesCSVfile(None)
  addFieldToCSVfile(u'primaryemail', USER_ARGUMENT_TO_PROPERTY_MAP, fieldsList, fieldsTitles, titles)
  sortHeaders = getGroupFeed = getLicenseFeed = email_parts = False
  customer = GC_Values[GC_CUSTOMER_ID]
  domain = None
  query = None
  projection = u'basic'
  customFieldMask = None
  viewType = deleted_only = orderBy = sortOrder = None
  delimiter = GC_Values[GC_CSV_OUTPUT_FIELD_DELIMITER]
  select = selectLookup = False
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'domain':
      domain = getString(OB_DOMAIN_NAME).lower()
      customer = None
    elif myarg == u'query':
      query = getString(OB_QUERY)
    elif myarg in [u'deletedonly', u'onlydeleted']:
      deleted_only = True
    elif myarg == u'select':
      _, entityList = getEntityToModify(defaultEntityType=CL_ENTITY_USERS)
      select = True
    elif myarg == u'orderby':
      orderBy = getChoice(USERS_ORDERBY_CHOICES_MAP, mapChoice=True)
      sortOrder = getChoice(SORTORDER_CHOICES_MAP, defaultChoice=u'ascending', mapChoice=True)
    elif myarg == u'userview':
      viewType = u'domain_public'
    elif myarg in [u'custom', u'schemas']:
      if not fieldsList:
        fieldsList = [u'primaryEmail',]
      fieldsList.append(u'customSchemas')
      customFieldMask = getString(OB_SCHEMA_NAME_LIST).replace(u' ', u',')
      if customFieldMask.lower() == u'all':
        customFieldMask = None
        projection = u'full'
      else:
        projection = u'custom'
    elif myarg == u'delimiter':
      delimiter = getDelimiter()
    elif myarg in PROJECTION_CHOICES_MAP:
      projection = myarg
      sortHeaders = True
      fieldsList = []
    elif myarg == u'allfields':
      projection = u'basic'
      sortHeaders = True
      fieldsList = []
    elif myarg in USER_ARGUMENT_TO_PROPERTY_MAP:
      if not fieldsList:
        fieldsList = [u'primaryEmail',]
      addFieldToCSVfile(myarg, USER_ARGUMENT_TO_PROPERTY_MAP, fieldsList, fieldsTitles, titles)
    elif myarg == u'fields':
      if not fieldsList:
        fieldsList = [u'primaryEmail',]
      fieldNameList = getString(OB_FIELD_NAME_LIST)
      for field in fieldNameList.lower().replace(u',', u' ').split():
        if field in USER_ARGUMENT_TO_PROPERTY_MAP:
          addFieldToCSVfile(field, USER_ARGUMENT_TO_PROPERTY_MAP, fieldsList, fieldsTitles, titles)
        else:
          CLArgs.Backup()
          invalidChoiceExit(USER_ARGUMENT_TO_PROPERTY_MAP)
    elif myarg == u'groups':
      getGroupFeed = True
    elif myarg in [u'license', u'licenses', u'licence', u'licences']:
      getLicenseFeed = True
    elif myarg in [u'emailpart', u'emailparts', u'username']:
      email_parts = True
    else:
      unknownArgumentExit()
  _, _, entityList = getEntityArgument(entityList)
  if entityList is None:
    fields = u'nextPageToken,users({0})'.format(u','.join(set(fieldsList))).replace(u'.', u'/') if fieldsList else None
    printGettingAccountEntitiesInfo(Entity.USER, qualifier=queryQualifier(query))
    page_message = getPageMessage(showFirstLastItems=True)
    try:
      feed = callGAPIpages(cd.users(), u'list', u'users',
                           page_message=page_message, message_attribute=u'primaryEmail',
                           throw_reasons=[GAPI_DOMAIN_NOT_FOUND, GAPI_INVALID_INPUT, GAPI_BAD_REQUEST, GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN],
                           customer=customer, domain=domain, fields=fields, query=query,
                           showDeleted=deleted_only, orderBy=orderBy, sortOrder=sortOrder, viewType=viewType,
                           projection=projection, customFieldMask=customFieldMask, maxResults=GC_Values[GC_USER_MAX_RESULTS])
      while feed:
        _printUser(feed.popleft())
    except GAPI_domainNotFound:
      entityActionFailedWarning([Entity.USER, PHRASE_LIST, Entity.DOMAIN, domain], PHRASE_NOT_FOUND)
      return
    except GAPI_invalidInput:
      entityActionFailedWarning([Entity.USER, PHRASE_LIST], invalidQuery(query))
      return
    except (GAPI_badRequest, GAPI_resourceNotFound, GAPI_forbidden):
      accessErrorExit(cd)
  else:
    if fieldsList:
      fields = u','.join(set(fieldsList)).replace(u'.', u'/')
      selectLookup = len(fieldsList) > 1
    else:
      fields = None
      selectLookup = True
    if selectLookup:
      jcount = len(entityList)
      svcargs = dict([(u'userKey', None), (u'fields', fields), (u'projection', projection), (u'customFieldMask', customFieldMask), (u'viewType', viewType)]+GM_Globals[GM_EXTRA_ARGS_LIST])
      dbatch = googleapiclient.http.BatchHttpRequest(callback=_callbackPrintUser)
      bcount = 0
      j = 0
      for userEntity in entityList:
        j += 1
        svcparms = svcargs.copy()
        svcparms[u'userKey'] = normalizeEmailAddressOrUID(userEntity)
        dbatch.add(cd.users().get(**svcparms), request_id=batchRequestID(u'', 0, 0, j, jcount, svcparms[u'userKey']))
        bcount += 1
        if bcount >= GC_Values[GC_BATCH_SIZE]:
          dbatch.execute()
          dbatch = googleapiclient.http.BatchHttpRequest(callback=_callbackPrintUser)
          bcount = 0
      if bcount > 0:
        dbatch.execute()
    else:
      for userEntity in entityList:
        _printUser({u'primaryEmail': normalizeEmailAddressOrUID(userEntity)})
  if sortHeaders:
    sortCSVTitles([u'primaryEmail',], titles)
  if select and orderBy:
    import operator
    csvRows.sort(key=operator.itemgetter(u'name.{0}'.format(orderBy)), reverse=sortOrder == u'DESCENDING')
  if getGroupFeed:
    addTitleToCSVfile(u'Groups', titles)
    i = 0
    count = len(csvRows)
    for user in csvRows:
      i += 1
      userEmail = user[u'primaryEmail']
      printGettingAllEntityItemsForWhom(Entity.GROUP_MEMBERSHIP, userEmail, i, count)
      groups = callGAPIpages(cd.groups(), u'list', u'groups',
                             userKey=userEmail, fields=u'nextPageToken,groups(email)')
      user[u'Groups'] = delimiter.join([groupname[u'email'] for groupname in groups])
  if getLicenseFeed:
    addTitleToCSVfile(u'Licenses', titles)
    licenses = doPrintLicenses(return_list=True)
    if licenses:
      for user in csvRows:
        user[u'Licenses'] = delimiter.join(licenses.get(user[u'primaryEmail'].lower(), []))
  writeCSVfile(csvRows, titles, u'Users', todrive)

SITEVERIFICATION_METHOD_CHOICES_MAP = {
  u'cname': u'DNS_CNAME',
  u'txt': u'DNS_TXT',
  u'text': u'DNS_TXT',
  u'file': u'FILE',
  u'site': u'FILE',
  }

# gam create verify|verification <DomainName>
def doCreateSiteVerification():
  verif = buildGAPIObject(SITEVERIFICATION_API)
  a_domain = getString(OB_DOMAIN_NAME)
  checkForExtraneousArguments()
  txt_record = callGAPI(verif.webResource(), u'getToken',
                        body={u'site': {u'type': u'INET_DOMAIN', u'identifier': a_domain},
                              u'verificationMethod': u'DNS_TXT'})
  printKeyValueList([u'TXT Record Name ', a_domain])
  printKeyValueList([u'TXT Record Value', txt_record[u'token']])
  printBlankLine()
  cname_record = callGAPI(verif.webResource(), u'getToken',
                          body={u'site': {u'type': u'INET_DOMAIN', u'identifier': a_domain},
                                u'verificationMethod': u'DNS_CNAME'})
  cname_token = cname_record[u'token']
  cname_list = cname_token.split(u' ')
  cname_subdomain = cname_list[0]
  cname_value = cname_list[1]
  printKeyValueList([u'CNAME Record Name ', u'{0}.{1}'.format(cname_subdomain, a_domain)])
  printKeyValueList([u'CNAME Record Value', cname_value])
  printBlankLine()
  webserver_file_record = callGAPI(verif.webResource(), u'getToken',
                                   body={u'site': {u'type': u'SITE', u'identifier': u'http://{0}/'.format(a_domain)},
                                         u'verificationMethod': u'FILE'})
  webserver_file_token = webserver_file_record[u'token']
  printKeyValueList([u'Saving web server verification file to', webserver_file_token])
  writeFile(webserver_file_token, u'google-site-verification: {0}'.format(webserver_file_token), continueOnError=True)
  printKeyValueList([u'Verification File URL', u'http://{0}/{1}'.format(a_domain, webserver_file_token)])
  printBlankLine()
  webserver_meta_record = callGAPI(verif.webResource(), u'getToken',
                                   body={u'site': {u'type': u'SITE', u'identifier': u'http://{0}/'.format(a_domain)},
                                         u'verificationMethod': u'META'})
  printKeyValueList([u'Meta URL', u'//{0}/'.format(a_domain)])
  printKeyValueList([u'Meta HTML Header Data', webserver_meta_record[u'token']])
  printBlankLine()

def _showSiteVerificationInfo(site):
  import urllib2
  printKeyValueList([u'Site', site[u'site'][u'identifier']])
  Indent.Increment()
  printKeyValueList([u'ID', urllib2.unquote(site[u'id'])])
  printKeyValueList([u'Type', site[u'site'][u'type']])
  printKeyValueList([u'All Owners', None])
  if u'owners' in site:
    Indent.Increment()
    for owner in site[u'owners']:
      printKeyValueList([owner])
    Indent.Decrement()
  Indent.Decrement()

# gam update verify|verification <DomainName> cname|txt|text|file|site
def doUpdateSiteVerification():
  verif = buildGAPIObject(SITEVERIFICATION_API)
  a_domain = getString(OB_DOMAIN_NAME)
  verificationMethod = getChoice(SITEVERIFICATION_METHOD_CHOICES_MAP, mapChoice=True)
  if verificationMethod in [u'DNS_TXT', u'DNS_CNAME']:
    verify_type = u'INET_DOMAIN'
    identifier = a_domain
  else:
    verify_type = u'SITE'
    identifier = u'http://{0}/'.format(a_domain)
  checkForExtraneousArguments()
  body = {u'site': {u'type': verify_type, u'identifier': identifier},
          u'verificationMethod': verificationMethod}
  try:
    verify_result = callGAPI(verif.webResource(), u'insert',
                             throw_reasons=[GAPI_BAD_REQUEST],
                             verificationMethod=verificationMethod, body=body)
  except GAPI_badRequest as e:
    printKeyValueList([ERROR, e.message])
    verify_data = callGAPI(verif.webResource(), u'getToken',
                           body=body)
    printKeyValueList([u'Method', verify_data[u'method']])
    printKeyValueList([u'Token', verify_data[u'token']])
    if verify_data[u'method'] == u'DNS_CNAME':
      try:
        import dns.resolver
        resolver = dns.resolver.Resolver()
        resolver.nameservers = GOOGLE_NAMESERVERS
        cname_token = verify_data[u'token']
        cname_list = cname_token.split(u' ')
        cname_subdomain = cname_list[0]
        try:
          answers = resolver.query(u'{0},{1}'.format(cname_subdomain, a_domain), u'A')
          for answer in answers:
            printKeyValueList([u'DNS Record', answer])
        except (dns.resolver.NXDOMAIN, dns.resolver.NoAnswer):
          printKeyValueList([ERROR, u'No such domain found in DNS!'])
      except ImportError:
        pass
    elif verify_data[u'method'] == u'DNS_TXT':
      try:
        import dns.resolver
        resolver = dns.resolver.Resolver()
        resolver.nameservers = GOOGLE_NAMESERVERS
        try:
          answers = resolver.query(a_domain, u'TXT')
          for answer in answers:
            printKeyValueList([u'DNS Record', answer.replace(u'"', u'')])
        except (dns.resolver.NXDOMAIN, dns.resolver.NoAnswer):
          printKeyValueList([ERROR, u'Domain not found in DNS!'])
      except ImportError:
        printKeyValueList([u'!!!No DNS'])
    return
  printKeyValueList([u'Verified!'])
  _showSiteVerificationInfo(verify_result)
  printKeyValueList([u'You can now add', a_domain, u'or it\'s subdomains as secondary or domain aliases of the G Suite Account', GC_Values[GC_DOMAIN]])

# gam info verify|verification
def doInfoSiteVerification():
  verif = buildGAPIObject(SITEVERIFICATION_API)
  checkForExtraneousArguments()
  sites = callGAPIitems(verif.webResource(), u'list', u'items')
  if sites:
    for site in sites:
      _showSiteVerificationInfo(site)
  else:
    printKeyValueList([u'No Sites Verified.'])

GUARDIAN_STATES = [u'COMPLETE', u'PENDING', u'GUARDIAN_INVITATION_STATE_UNSPECIFIED']

# gam create guardian|guardianinvite|inviteguardian <EmailAddress> <StudentItem>
def doInviteGuardian():
  croom = buildGAPIObject(CLASSROOM_API)
  body = {u'invitedEmailAddress': getEmailAddress()}
  studentId = normalizeStudentGuardianEmailAddressOrUID(getString(OB_STUDENT_ITEM))
  checkForExtraneousArguments()
  try:
    result = callGAPI(croom.userProfiles().guardianInvitations(), u'create',
                      throw_reasons=[GAPI_NOT_FOUND, GAPI_INVALID_ARGUMENT, GAPI_BAD_REQUEST, GAPI_FORBIDDEN, GAPI_PERMISSION_DENIED, GAPI_ALREADY_EXISTS],
                      studentId=studentId, body=body, fields=u'invitationId')
    entityActionPerformed([Entity.STUDENT, studentId, Entity.GUARDIAN, body[u'invitedEmailAddress'], Entity.GUARDIAN_INVITATION, result[u'invitationId']])
  except (GAPI_notFound, GAPI_invalidArgument, GAPI_badRequest, GAPI_forbidden):
    entityUnknownWarning(Entity.STUDENT, studentId, 0, 0)
  except GAPI_alreadyExists:
    entityActionFailedWarning([Entity.STUDENT, studentId, Entity.GUARDIAN, body[u'invitedEmailAddress']], PHRASE_DUPLICATE)

def _cancelGuardianInvitation(croom, studentId, invitationId):
  try:
    result = callGAPI(croom.userProfiles().guardianInvitations(), u'patch',
                      throw_reasons=[GAPI_FORBIDDEN, GAPI_NOT_FOUND, GAPI_FAILED_PRECONDITION],
                      studentId=studentId, invitationId=invitationId, updateMask=u'state', body={u'state': u'COMPLETE'}, fields=u'invitedEmailAddress')
    entityActionPerformed([Entity.STUDENT, studentId, Entity.GUARDIAN_INVITATION, result[u'invitedEmailAddress']])
  except GAPI_forbidden:
    entityUnknownWarning(Entity.STUDENT, studentId, 0, 0)
    systemErrorExit(GM_Globals[GM_SYSEXITRC], None)
  except GAPI_notFound:
    entityActionFailedWarning([Entity.STUDENT, studentId, Entity.GUARDIAN_INVITATION, invitationId], PHRASE_NOT_FOUND)
  except GAPI_failedPrecondition:
    entityActionFailedWarning([Entity.STUDENT, studentId, Entity.GUARDIAN_INVITATION, invitationId], PHRASE_GUARDIAN_INVITATION_STATUS_NOT_PENDING)

# gam cancel guardianinvitation|guardianinvitations <GuardianInvitationID> <StudentItem>
def doCancelGuardianInvitation():
  croom = buildGAPIObject(CLASSROOM_API)
  invitationId = getString(OB_GUARDIAN_INVITATION_ID)
  studentId = normalizeStudentGuardianEmailAddressOrUID(getString(OB_STUDENT_ITEM))
  checkForExtraneousArguments()
  _cancelGuardianInvitation(croom, studentId, invitationId)

# gam delete guardian|guardians <GuardianIitem> <StudentItem> [invitations]
def doDeleteGuardian():
  croom = buildGAPIObject(CLASSROOM_API)
  invitationsOnly = False
  guardianId = normalizeStudentGuardianEmailAddressOrUID(getString(OB_GUARDIAN_ITEM))
  studentId = normalizeStudentGuardianEmailAddressOrUID(getString(OB_STUDENT_ITEM))
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in [u'invitation', u'invitations']:
      invitationsOnly = True
    else:
      unknownArgumentExit()
  if not invitationsOnly:
    try:
      callGAPI(croom.userProfiles().guardians(), u'delete',
               throw_reasons=[GAPI_FORBIDDEN, GAPI_NOT_FOUND],
               studentId=studentId, guardianId=guardianId)
      entityActionPerformed([Entity.STUDENT, studentId, Entity.GUARDIAN, guardianId])
      return
    except GAPI_forbidden:
      entityUnknownWarning(Entity.STUDENT, studentId, 0, 0)
      systemErrorExit(GM_Globals[GM_SYSEXITRC], None)
    except GAPI_notFound:
      pass
  Action.Set(Action.CANCEL)
  try:
    results = callGAPIpages(croom.userProfiles().guardianInvitations(), u'list', items=u'guardianInvitations',
                            throw_reasons=[GAPI_FORBIDDEN],
                            studentId=studentId, invitedEmailAddress=guardianId, states=[u'PENDING',])
    if len(results) > 0:
      for result in results:
        _cancelGuardianInvitation(croom, studentId, result[u'invitationId'])
    else:
      entityActionFailedWarning([Entity.STUDENT, studentId, [Entity.GUARDIAN, Entity.GUARDIAN_INVITATION][invitationsOnly]], guardianId, PHRASE_NOT_A_GUARDIAN_OR_INVITATION)
  except GAPI_forbidden:
    entityUnknownWarning(Entity.STUDENT, studentId, 0, 0)

#gam show guardian|guardians [invitedguardian <EmailAddress>] [student <StudentItem>] [invitations] [states <GuardianStateList>] [<UserTypeEntity>]
def doShowGuardians():
  printShowGuardians(False)

#gam print guardian|guardians [todrive [<ToDriveAttributes>]] [invitedguardian <EmailAddress>] [student <StudentItem>] [invitations] [states <GuardianStateList>] [<UserTypeEntity>]
def doPrintGuardians():
  printShowGuardians(True)

def printShowGuardians(csvFormat):
  croom = buildGAPIObject(CLASSROOM_API)
  invitedEmailAddress = None
  studentIds = [u'-',]
  states = None
  service = croom.userProfiles().guardians()
  items = u'guardians'
  entityType = Entity.GUARDIAN
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile([u'studentEmail', u'studentId', u'invitedEmailAddress', u'guardianId'])
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'invitedguardian':
      invitedEmailAddress = getEmailAddress()
    elif myarg == u'student':
      studentIds = [getString(OB_STUDENT_ITEM)]
    elif myarg == u'invitations':
      service = croom.userProfiles().guardianInvitations()
      items = u'guardianInvitations'
      entityType = Entity.GUARDIAN_INVITATION
      titles, csvRows = initializeTitlesCSVfile([u'studentEmail', u'studentId', u'invitedEmailAddress', u'invitationId'])
      if states is None:
        states = GUARDIAN_STATES
    elif myarg == u'states':
      states = getString(OB_GUARDIAN_STATE_LIST).upper().split(u',')
    else:
      CLArgs.Backup()
      _, studentIds = getEntityToModify(defaultEntityType=CL_ENTITY_USERS)
  i = 0
  count = len(studentIds)
  for studentId in studentIds:
    i += 1
    studentId = normalizeStudentGuardianEmailAddressOrUID(studentId)
    kwargs = {u'invitedEmailAddress': invitedEmailAddress, u'studentId': studentId}
    if items == u'guardianInvitations':
      kwargs[u'states'] = states
    if studentId != u'-':
      if csvFormat:
        printGettingAllEntityItemsForWhom(entityType, studentId, i, count)
    try:
      result = callGAPIpages(service, u'list', items=items,
                             throw_reasons=[GAPI_NOT_FOUND, GAPI_INVALID_ARGUMENT, GAPI_BAD_REQUEST, GAPI_FORBIDDEN, GAPI_PERMISSION_DENIED],
                             **kwargs)
      jcount = len(result)
      if not csvFormat:
        entityPerformActionNumItems([Entity.STUDENT, studentId], jcount, entityType, i, count)
        Indent.Increment()
        j = 0
        for guardian in result:
          j += 1
          printKeyValueListWithCount([u'invitedEmailAddress', guardian[u'invitedEmailAddress']], j, jcount)
          Indent.Increment()
          showJSON(None, guardian, [u'invitedEmailAddress',], COURSE_TIME_OBJECTS)
          Indent.Decrement()
        Indent.Decrement()
      else:
        for guardian in result:
          guardian[u'studentEmail'] = studentId
          addRowTitlesToCSVfile(flattenJSON(guardian, time_objects=COURSE_TIME_OBJECTS), csvRows, titles)
    except (GAPI_notFound, GAPI_invalidArgument, GAPI_badRequest, GAPI_forbidden):
      entityUnknownWarning(Entity.STUDENT, studentId, i, count)
    except GAPI_permissionDenied as e:
      entityActionFailedWarning([Entity.STUDENT, studentId], e.message, i, count)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Guardians', todrive)

COURSE_STATE_OPTIONS_MAP = {
  u'active': u'ACTIVE',
  u'archived': u'ARCHIVED',
  u'provisioned': u'PROVISIONED',
  u'declined': u'DECLINED',
  }

def getCourseAttribute(myarg, body):
  if myarg == u'name':
    body[u'name'] = getString(OB_STRING)
  elif myarg == u'section':
    body[u'section'] = getString(OB_STRING, minLen=0)
  elif myarg == u'heading':
    body[u'descriptionHeading'] = getString(OB_STRING, minLen=0)
  elif myarg == u'description':
    body[u'description'] = getString(OB_STRING, minLen=0).replace(u'\\n', u'\n')
  elif myarg == u'room':
    body[u'room'] = getString(OB_STRING, minLen=0)
  elif myarg in [u'state', u'status']:
    body[u'courseState'] = getChoice(COURSE_STATE_OPTIONS_MAP, mapChoice=True)
  else:
    unknownArgumentExit()

# gam create course id|alias <CourseAlias> [teacher <UserItem>] <CourseAttributes>
def doCreateCourse():
  croom = buildGAPIObject(CLASSROOM_API)
  body = {u'ownerId': u'me', u'name': u'Unknown Course'}
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in [u'alias', u'id']:
      body[u'id'] = getCourseAlias()
    elif myarg == u'teacher':
      body[u'ownerId'] = getEmailAddress()
    else:
      getCourseAttribute(myarg, body)
  try:
    result = callGAPI(croom.courses(), u'create',
                      throw_reasons=[GAPI_ALREADY_EXISTS, GAPI_NOT_FOUND, GAPI_PERMISSION_DENIED, GAPI_FORBIDDEN],
                      body=body, fields=u'id')
    entityActionPerformed([Entity.COURSE, body[u'name'], Entity.COURSE_ID, result[u'id']])
  except (GAPI_alreadyExists, GAPI_notFound, GAPI_permissionDenied, GAPI_forbidden) as e:
    entityActionFailedWarning([Entity.COURSE, body[u'name'], Entity.TEACHER, body[u'ownerId']], e.message)

def _doUpdateCourses(entityList):
  croom = buildGAPIObject(CLASSROOM_API)
  body = {}
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    getCourseAttribute(myarg, body)
  updateMask = u','.join(body.keys())
  i = 0
  count = len(entityList)
  for course in entityList:
    i += 1
    body[u'id'] = addCourseIdScope(course)
    try:
      result = callGAPI(croom.courses(), u'patch',
                        throw_reasons=[GAPI_NOT_FOUND, GAPI_PERMISSION_DENIED],
                        id=body[u'id'], body=body, updateMask=updateMask, fields=u'id')
      entityActionPerformed([Entity.COURSE, result[u'id']], i, count)
    except (GAPI_notFound, GAPI_permissionDenied) as e:
      entityActionFailedWarning([Entity.COURSE, removeCourseIdScope(body[u'id'])], e.message, i, count)

# gam update courses <CourseEntity> <CourseAttributes>
def doUpdateCourses():
  _doUpdateCourses(getEntityList(OB_COURSE_ENTITY))

# gam update course <CourseID> <CourseAttributes>
def doUpdateCourse():
  _doUpdateCourses(getStringReturnInList(OB_COURSE_ID))

def _doDeleteCourses(entityList):
  croom = buildGAPIObject(CLASSROOM_API)
  checkForExtraneousArguments()
  i = 0
  count = len(entityList)
  for course in entityList:
    i += 1
    courseId = addCourseIdScope(course)
    try:
      callGAPI(croom.courses(), u'delete',
               throw_reasons=[GAPI_NOT_FOUND, GAPI_PERMISSION_DENIED],
               id=courseId)
      entityActionPerformed([Entity.COURSE, removeCourseIdScope(courseId)], i, count)
    except (GAPI_notFound, GAPI_permissionDenied) as e:
      entityActionFailedWarning([Entity.COURSE, removeCourseIdScope(courseId)], e.message, i, count)

# gam delete courses <CourseEntity>
def doDeleteCourses():
  _doDeleteCourses(getEntityList(OB_COURSE_ENTITY))

# gam delete course <CourseID>
def doDeleteCourse():
  _doDeleteCourses(getStringReturnInList(OB_COURSE_ID))

COURSE_ARGUMENT_TO_PROPERTY_MAP = {
  u'alternatelink': u'alternateLink',
  u'coursegroupemail': u'courseGroupEmail',
  u'coursematerialsets': u'courseMaterialSets',
  u'coursestate': u'courseState',
  u'creationtime': u'creationTime',
  u'description': u'description',
  u'descriptionheading': u'descriptionHeading',
  u'enrollmentcode': u'enrollmentCode',
  u'guardiansenabled': u'guardiansEnabled',
  u'id': u'id',
  u'name': u'name',
  u'ownerid': u'ownerId',
  u'room': u'room',
  u'section': u'section',
  u'teacherfolder': u'teacherFolder',
  u'teachergroupemail': u'teacherGroupEmail',
  u'updatetime': u'updateTime',
  }
COURSE_MEMBER_ARGUMENTS = [u'none', u'all', u'students', u'teachers']
COURSE_TIME_OBJECTS = [u'creationTime', u'updateTime']

def _getCourseShowArguments(myarg, courseShowProperties):
  if myarg in [u'alias', u'aliases']:
    courseShowProperties[u'aliases'] = True
  elif myarg == u'show':
    courseShowProperties[u'members'] = getChoice(COURSE_MEMBER_ARGUMENTS)
  elif myarg == u'fields':
    if not courseShowProperties[u'fields']:
      courseShowProperties[u'fields'] = [u'id',]
    fieldNameList = getString(OB_FIELD_NAME_LIST)
    for field in fieldNameList.lower().replace(u',', u' ').split():
      if field in [u'alias', u'aliases']:
        courseShowProperties[u'aliases'] = True
      elif field == u'teachers':
        if courseShowProperties[u'members'] in [u'none', u'all']:
          courseShowProperties[u'members'] = myarg
        elif courseShowProperties[u'members'] == u'students':
          courseShowProperties[u'members'] = u'all'
      elif field == u'students':
        if courseShowProperties[u'members'] in [u'none', u'all']:
          courseShowProperties[u'members'] = myarg
        elif courseShowProperties[u'members'] == u'teachers':
          courseShowProperties[u'members'] = u'all'
      elif field in COURSE_ARGUMENT_TO_PROPERTY_MAP:
        if field != u'id':
          courseShowProperties[u'fields'].append(COURSE_ARGUMENT_TO_PROPERTY_MAP[field])
      else:
        CLArgs.Backup()
        invalidChoiceExit(COURSE_ARGUMENT_TO_PROPERTY_MAP)
  elif myarg == u'skipfields':
    fieldNameList = getString(OB_FIELD_NAME_LIST)
    for field in fieldNameList.lower().replace(u',', u' ').split():
      if field in [u'alias', u'aliases']:
        courseShowProperties[u'aliases'] = False
      elif field == u'teachers':
        if courseShowProperties[u'members'] == u'all':
          courseShowProperties[u'members'] = u'students'
        elif courseShowProperties[u'members'] == field:
          courseShowProperties[u'members'] = u'none'
      elif field == u'students':
        if courseShowProperties[u'members'] == u'all':
          courseShowProperties[u'members'] = u'teachers'
        elif courseShowProperties[u'members'] == field:
          courseShowProperties[u'members'] = u'none'
      elif field in COURSE_ARGUMENT_TO_PROPERTY_MAP:
        if field != u'id':
          courseShowProperties[u'skips'].append(COURSE_ARGUMENT_TO_PROPERTY_MAP[field])
      else:
        CLArgs.Backup()
        invalidChoiceExit(COURSE_ARGUMENT_TO_PROPERTY_MAP)
  else:
    unknownArgumentExit()

def _doInfoCourses(entityList):
  croom = buildGAPIObject(CLASSROOM_API)
  courseShowProperties = {u'aliases': True, u'members': u'all', u'fields': [], u'skips': []}
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    _getCourseShowArguments(myarg, courseShowProperties)
  fields = u','.join(set(courseShowProperties[u'fields'])) if courseShowProperties[u'fields'] else None
  i = 0
  count = len(entityList)
  for course in entityList:
    i += 1
    courseId = addCourseIdScope(course)
    try:
      result = callGAPI(croom.courses(), u'get',
                        throw_reasons=[GAPI_NOT_FOUND],
                        id=courseId, fields=fields)
      printEntity([Entity.COURSE, result[u'id']], i, count)
      Indent.Increment()
      showJSON(None, result, skip_objects=courseShowProperties[u'skips'], time_objects=COURSE_TIME_OBJECTS)
      if courseShowProperties[u'aliases']:
        try:
          aliases = callGAPIpages(croom.courses().aliases(), u'list', u'aliases',
                                  throw_reasons=[GAPI_NOT_IMPLEMENTED],
                                  courseId=courseId, pageSize=GC_Values[GC_CLASSROOM_MAX_RESULTS])
          printKeyValueList([u'Aliases', None])
          Indent.Increment()
          for alias in aliases:
            printKeyValueList([removeCourseIdScope(alias[u'alias'])])
          Indent.Decrement()
        except GAPI_notImplemented:
          pass
      if courseShowProperties[u'members'] != u'none':
        printKeyValueList([u'Participants', None])
        Indent.Increment()
        if courseShowProperties[u'members'] != u'students':
          teachers = callGAPIpages(croom.courses().teachers(), u'list', u'teachers',
                                   throw_reasons=[GAPI_NOT_FOUND, GAPI_FORBIDDEN],
                                   courseId=courseId, pageSize=GC_Values[GC_CLASSROOM_MAX_RESULTS])
          if teachers:
            printKeyValueList([u'Teachers', None])
            Indent.Increment()
            for teacher in teachers:
              if u'emailAddress' in teacher[u'profile']:
                printKeyValueList([u'{0} - {1}'.format(teacher[u'profile'][u'name'][u'fullName'], teacher[u'profile'][u'emailAddress'])])
              else:
                printKeyValueList([teacher[u'profile'][u'name'][u'fullName']])
            Indent.Decrement()
        if courseShowProperties[u'members'] != u'teachers':
          students = callGAPIpages(croom.courses().students(), u'list', u'students',
                                   throw_reasons=[GAPI_NOT_FOUND, GAPI_FORBIDDEN],
                                   courseId=courseId, pageSize=GC_Values[GC_CLASSROOM_MAX_RESULTS])
          if students:
            printKeyValueList([u'Students', None])
            Indent.Increment()
            for student in students:
              if u'emailAddress' in student[u'profile']:
                printKeyValueList([u'{0} - {1}'.format(student[u'profile'][u'name'][u'fullName'], student[u'profile'][u'emailAddress'])])
              else:
                printKeyValueList([student[u'profile'][u'name'][u'fullName']])
            Indent.Decrement()
          Indent.Decrement()
        Indent.Decrement()
    except GAPI_notFound:
      entityActionFailedWarning([Entity.COURSE, removeCourseIdScope(courseId)], PHRASE_DOES_NOT_EXIST, i, count)
    except GAPI_forbidden:
      APIAccessDeniedExit()

# gam info courses <CourseEntity> [alias|aliases] [show none|all|students|teachers] [fields <CourseFieldNameList>] [skipfields <CourseFieldNameList>]
def doInfoCourses():
  _doInfoCourses(getEntityList(OB_COURSE_ENTITY))

# gam info course <CourseID> [alias|aliases] [show none|all|students|teachers] [fields <CourseFieldNameList>] [skipfields <CourseFieldNameList>]
def doInfoCourse():
  _doInfoCourses(getStringReturnInList(OB_COURSE_ID))

# gam print courses [todrive [<ToDriveAttributes>]] [teacher <UserItem>] [student <UserItem>]
#	[delimiter <String>] [alias|aliases] [show none|all|students|teachers] [fields <CourseFieldNameList>] [skipfields <CourseFieldNameList>]
def doPrintCourses():

  def _saveParticipants(course, participants, role):
    jcount = len(participants)
    course[role] = jcount
    addTitlesToCSVfile([role], titles)
    j = 0
    for member in participants:
      memberTitles = []
      prefix = u'{0}.{1}.'.format(role, j)
      profile = member[u'profile']
      emailAddress = profile.get(u'emailAddress')
      if emailAddress:
        memberTitle = prefix+u'emailAddress'
        course[memberTitle] = emailAddress
        memberTitles.append(memberTitle)
      memberId = profile.get(u'id')
      if memberId:
        memberTitle = prefix+u'id'
        course[memberTitle] = memberId
        memberTitles.append(memberTitle)
      fullName = profile.get(u'name', {}).get(u'fullName')
      if fullName:
        memberTitle = prefix+u'name.fullName'
        course[memberTitle] = fullName
        memberTitles.append(memberTitle)
      addTitlesToCSVfile(memberTitles, titles)
      j += 1

  croom = buildGAPIObject(CLASSROOM_API)
  courseShowProperties = {u'aliases': False, u'members': u'none', u'fields': [], u'skips': []}
  todrive = {}
  titles, csvRows = initializeTitlesCSVfile([u'id',])
  teacherId = None
  studentId = None
  delimiter = GC_Values[GC_CSV_OUTPUT_FIELD_DELIMITER]
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'teacher':
      teacherId = getEmailAddress()
    elif myarg == u'student':
      studentId = getEmailAddress()
    elif myarg == u'delimiter':
      delimiter = getDelimiter()
    else:
      _getCourseShowArguments(myarg, courseShowProperties)
  fields = u'nextPageToken,courses({0})'.format(u','.join(set(courseShowProperties[u'fields']))) if courseShowProperties[u'fields'] else None
  printGettingAccountEntitiesInfo(Entity.COURSE)
  try:
    page_message = getPageMessage()
    all_courses = callGAPIpages(croom.courses(), u'list', u'courses',
                                page_message=page_message,
                                throw_reasons=[GAPI_NOT_FOUND, GAPI_FORBIDDEN, GAPI_BAD_REQUEST],
                                teacherId=teacherId, studentId=studentId, pageSize=GC_Values[GC_CLASSROOM_MAX_RESULTS], fields=fields)
  except (GAPI_notFound, GAPI_forbidden, GAPI_badRequest):
    if (not studentId) and teacherId:
      entityUnknownWarning(Entity.TEACHER, teacherId)
      return
    if (not teacherId) and studentId:
      entityUnknownWarning(Entity.STUDENT, studentId)
      return
    if studentId and teacherId:
      entityOrEntityUnknownWarning(Entity.TEACHER, teacherId, Entity.STUDENT, studentId)
      return
    all_courses = collections.deque()
  for course in all_courses:
    for field in courseShowProperties[u'skips']:
      course.pop(field, None)
    addRowTitlesToCSVfile(flattenJSON(course, time_objects=COURSE_TIME_OBJECTS), csvRows, titles)
  if courseShowProperties[u'aliases'] or courseShowProperties[u'members'] != u'none':
    if courseShowProperties[u'aliases']:
      addTitleToCSVfile(u'Aliases', titles)
    i = 0
    count = len(csvRows)
    for course in csvRows:
      i += 1
      courseId = course[u'id']
      page_message = getPageMessageForWhom(forWhom=formatKeyValueList(u'',
                                                                      [Entity.Singular(Entity.COURSE), courseId],
                                                                      currentCount(i, count)))
      try:
        if courseShowProperties[u'aliases']:
          Entity.SetGetting(Entity.ALIAS)
          course_aliases = callGAPIpages(croom.courses().aliases(), u'list', u'aliases',
                                         page_message=page_message,
                                         throw_reasons=[GAPI_NOT_FOUND, GAPI_FORBIDDEN],
                                         courseId=courseId, pageSize=GC_Values[GC_CLASSROOM_MAX_RESULTS])
          course[u'Aliases'] = delimiter.join([removeCourseIdScope(alias[u'alias']) for alias in course_aliases])
        if courseShowProperties[u'members'] != u'none':
          if courseShowProperties[u'members'] != u'students':
            Entity.SetGetting(Entity.TEACHER)
            results = callGAPIpages(croom.courses().teachers(), u'list', u'teachers',
                                    page_message=page_message,
                                    throw_reasons=[GAPI_NOT_FOUND, GAPI_FORBIDDEN],
                                    courseId=courseId, fields=u'nextPageToken,teachers(profile)', pageSize=GC_Values[GC_CLASSROOM_MAX_RESULTS])
            _saveParticipants(course, results, u'teachers')
          if courseShowProperties[u'members'] != u'teachers':
            Entity.SetGetting(Entity.STUDENT)
            results = callGAPIpages(croom.courses().students(), u'list', u'students',
                                    page_message=page_message,
                                    throw_reasons=[GAPI_NOT_FOUND, GAPI_FORBIDDEN],
                                    courseId=courseId, fields=u'nextPageToken,students(profile)', pageSize=GC_Values[GC_CLASSROOM_MAX_RESULTS])
            _saveParticipants(course, results, u'students')
      except (GAPI_notFound, GAPI_forbidden):
        pass
  sortCSVTitles([u'id', u'name'], titles)
  writeCSVfile(csvRows, titles, u'Courses', todrive)

def checkCourseExists(croom, courseId, i=0, count=0):
  courseId = addCourseIdScope(courseId)
  try:
    return callGAPI(croom.courses(), u'get',
                    throw_reasons=[GAPI_NOT_FOUND],
                    id=courseId, fields=u'id')[u'id']
  except GAPI_notFound:
    entityActionFailedWarning([Entity.COURSE, removeCourseIdScope(courseId)], PHRASE_DOES_NOT_EXIST, i, count)
    return None

_ADD_PART_REASON_TO_MESSAGE_MAP = {GAPI_ALREADY_EXISTS: PHRASE_DUPLICATE, GAPI_FAILED_PRECONDITION: PHRASE_NOT_ALLOWED}
def _callbackAddParticipantsToCourse(request_id, response, exception):
  ri = request_id.splitlines()
  if exception is None:
    entityActionPerformed([Entity.COURSE, ri[RI_ENTITY], ri[RI_ROLE], ri[RI_ITEM]], int(ri[RI_J]), int(ri[RI_JCOUNT]))
  else:
    http_status, reason, message = checkGAPIError(exception)
    if reason in [GAPI_NOT_FOUND, GAPI_FORBIDDEN, GAPI_BACKEND_ERROR]:
      errMsg = getPhraseDNEorSNA(ri[RI_ITEM])
    else:
      errMsg = getHTTPError(_ADD_PART_REASON_TO_MESSAGE_MAP, http_status, reason, message)
    entityActionFailedWarning([Entity.COURSE, ri[RI_ENTITY], ri[RI_ROLE], ri[RI_ITEM]], errMsg, int(ri[RI_J]), int(ri[RI_JCOUNT]))

def _batchAddParticipantsToCourse(croom, courseId, i, count, addParticipants, role):
  if role == Entity.STUDENT:
    service = croom.courses().students()
    attribute = u'userId'
  elif role == Entity.TEACHER:
    service = croom.courses().teachers()
    attribute = u'userId'
  else:
    service = croom.courses().aliases()
    attribute = u'alias'
  Action.Set(Action.ADD)
  jcount = len(addParticipants)
  noScopeCourseId = removeCourseIdScope(courseId)
  entityPerformActionNumItems([Entity.COURSE, noScopeCourseId], jcount, role, i, count)
  Indent.Increment()
  svcargs = dict([(u'courseId', courseId), (u'body', {attribute: None}), (u'fields', u'')]+GM_Globals[GM_EXTRA_ARGS_LIST])
  dbatch = croom.new_batch_http_request(callback=_callbackAddParticipantsToCourse)
  bcount = 0
  j = 0
  for participant in addParticipants:
    j += 1
    svcparms = svcargs.copy()
    if role != Entity.COURSE_ALIAS:
      svcparms[u'body'][attribute] = cleanItem = normalizeEmailAddressOrUID(participant)
    else:
      svcparms[u'body'][attribute] = addCourseIdScope(participant)
      cleanItem = removeCourseIdScope(svcparms[u'body'][attribute])
    dbatch.add(service.create(**svcparms), request_id=batchRequestID(noScopeCourseId, 0, 0, j, jcount, cleanItem, role))
    bcount += 1
    if bcount >= GC_Values[GC_BATCH_SIZE]:
      dbatch.execute()
      dbatch = croom.new_batch_http_request(callback=_callbackAddParticipantsToCourse)
      bcount = 0
  if bcount > 0:
    dbatch.execute()
  Indent.Decrement()

_REMOVE_PART_REASON_TO_MESSAGE_MAP = {GAPI_NOT_FOUND: PHRASE_DOES_NOT_EXIST, GAPI_FORBIDDEN: PHRASE_FORBIDDEN}
def _callbackRemoveParticipantsFromCourse(request_id, response, exception):
  ri = request_id.splitlines()
  if exception is None:
    entityActionPerformed([Entity.COURSE, ri[RI_ENTITY], ri[RI_ROLE], ri[RI_ITEM]], int(ri[RI_J]), int(ri[RI_JCOUNT]))
  else:
    http_status, reason, message = checkGAPIError(exception)
    if reason == GAPI_NOT_FOUND and ri[RI_ROLE] != Entity.COURSE_ALIAS:
      errMsg = u'{0} {1}'.format(PHRASE_NOT_A, Entity.Singular(ri[RI_ROLE]))
    else:
      errMsg = getHTTPError(_REMOVE_PART_REASON_TO_MESSAGE_MAP, http_status, reason, message)
    entityActionFailedWarning([Entity.COURSE, ri[RI_ENTITY], ri[RI_ROLE], ri[RI_ITEM]], errMsg, int(ri[RI_J]), int(ri[RI_JCOUNT]))

def _batchRemoveParticipantsFromCourse(croom, courseId, i, count, removeParticipants, role):
  if role == Entity.STUDENT:
    service = croom.courses().students()
    attribute = u'userId'
  elif role == Entity.TEACHER:
    service = croom.courses().teachers()
    attribute = u'userId'
  else:
    service = croom.courses().aliases()
    attribute = u'alias'
  Action.Set(Action.REMOVE)
  jcount = len(removeParticipants)
  noScopeCourseId = removeCourseIdScope(courseId)
  entityPerformActionNumItems([Entity.COURSE, noScopeCourseId], jcount, role, i, count)
  Indent.Increment()
  svcargs = dict([(u'courseId', courseId), (u'fields', u''), (attribute, None)]+GM_Globals[GM_EXTRA_ARGS_LIST])
  dbatch = croom.new_batch_http_request(callback=_callbackRemoveParticipantsFromCourse)
  bcount = 0
  j = 0
  for participant in removeParticipants:
    j += 1
    svcparms = svcargs.copy()
    if role != Entity.COURSE_ALIAS:
      svcparms[attribute] = cleanItem = normalizeEmailAddressOrUID(participant)
    else:
      svcparms[attribute] = addCourseIdScope(participant)
      cleanItem = removeCourseIdScope(svcparms[attribute])
    dbatch.add(service.delete(**svcparms), request_id=batchRequestID(noScopeCourseId, 0, 0, j, jcount, cleanItem, role))
    bcount += 1
    if bcount >= GC_Values[GC_BATCH_SIZE]:
      dbatch.execute()
      dbatch = croom.new_batch_http_request(callback=_callbackRemoveParticipantsFromCourse)
      bcount = 0
  if bcount > 0:
    dbatch.execute()
  Indent.Decrement()

ADD_REMOVE_PARTICIPANT_TYPES_MAP = {
  u'alias': Entity.COURSE_ALIAS,
  u'student': Entity.STUDENT,
  u'students': Entity.STUDENT,
  u'teacher': Entity.TEACHER,
  u'teachers': Entity.TEACHER,
  }
SYNC_PARTICIPANT_TYPES_MAP = {
  u'student': Entity.STUDENT,
  u'students': Entity.STUDENT,
  u'teacher': Entity.TEACHER,
  u'teachers': Entity.TEACHER,
  }
PARTICIPANT_EN_MAP = {
  Entity.STUDENT: CL_ENTITY_STUDENTS,
  Entity.TEACHER: CL_ENTITY_TEACHERS,
  }

# gam courses <CourseEntity> add alias <CourseAliasEntity>
# gam course <CourseID> add alias <CourseAlias>
# gam courses <CourseEntity> add teachers|students <UserTypeEntity>
# gam course <CourseID> add teacher|student <EmailAddress>
def doCourseAddParticipants(courseIdList, getEntityListArg):
  croom = buildGAPIObject(CLASSROOM_API)
  role = getChoice(ADD_REMOVE_PARTICIPANT_TYPES_MAP, mapChoice=True)
  if not getEntityListArg:
    if role != Entity.COURSE_ALIAS:
      addParticipants = getStringReturnInList(OB_EMAIL_ADDRESS)
    else:
      addParticipants = getStringReturnInList(OB_COURSE_ALIAS)
    courseParticipantLists = None
  else:
    if role != Entity.COURSE_ALIAS:
      _, addParticipants = getEntityToModify(defaultEntityType=CL_ENTITY_USERS,
                                             typeMap={CL_ENTITY_COURSEPARTICIPANTS: PARTICIPANT_EN_MAP[role]},
                                             checkNotSuspended=True)
    else:
      addParticipants = getEntityList(OB_COURSE_ALIAS_ENTITY)
    courseParticipantLists = addParticipants if isinstance(addParticipants, dict) else None
  checkForExtraneousArguments()
  i = 0
  count = len(courseIdList)
  for courseId in courseIdList:
    i += 1
    if courseParticipantLists:
      addParticipants = courseParticipantLists[courseId]
    courseId = checkCourseExists(croom, courseId, i, count)
    if courseId:
      _batchAddParticipantsToCourse(croom, courseId, i, count, addParticipants, role)

# gam courses <CourseEntity> remove alias <CourseAliasEntity>
# gam course <CourseID> remove alias <CourseAlias>
# gam courses <CourseEntity> remove teachers|students <UserTypeEntity>
# gam course <CourseID> remove teacher|student <EmailAddress>
def doCourseRemoveParticipants(courseIdList, getEntityListArg):
  croom = buildGAPIObject(CLASSROOM_API)
  role = getChoice(ADD_REMOVE_PARTICIPANT_TYPES_MAP, mapChoice=True)
  if not getEntityListArg:
    if role != Entity.COURSE_ALIAS:
      removeParticipants = getStringReturnInList(OB_EMAIL_ADDRESS)
    else:
      removeParticipants = getStringReturnInList(OB_COURSE_ALIAS)
    courseParticipantLists = None
  else:
    if role != Entity.COURSE_ALIAS:
      _, removeParticipants = getEntityToModify(defaultEntityType=CL_ENTITY_USERS,
                                                typeMap={CL_ENTITY_COURSEPARTICIPANTS: PARTICIPANT_EN_MAP[role]})
    else:
      removeParticipants = getEntityList(OB_COURSE_ALIAS_ENTITY)
    courseParticipantLists = removeParticipants if isinstance(removeParticipants, dict) else None
  checkForExtraneousArguments()
  i = 0
  count = len(courseIdList)
  for courseId in courseIdList:
    i += 1
    if courseParticipantLists:
      removeParticipants = courseParticipantLists[courseId]
    courseId = checkCourseExists(croom, courseId, i, count)
    if courseId:
      _batchRemoveParticipantsFromCourse(croom, courseId, i, count, removeParticipants, role)

# gam courses <CourseEntity> sync teachers|students <UserTypeEntity>
# gam course <CourseID> sync teachers|students <UserTypeEntity>
def doCourseSyncParticipants(courseIdList, getEntityListArg):
  croom = buildGAPIObject(CLASSROOM_API)
  role = getChoice(SYNC_PARTICIPANT_TYPES_MAP, mapChoice=True)
  _, syncParticipants = getEntityToModify(defaultEntityType=CL_ENTITY_USERS,
                                          typeMap={CL_ENTITY_COURSEPARTICIPANTS: PARTICIPANT_EN_MAP[role]}, checkNotSuspended=True)
  checkForExtraneousArguments()
  courseParticipantLists = syncParticipants if isinstance(syncParticipants, dict) else None
  if not courseParticipantLists:
    syncParticipantsSet = set()
    for user in syncParticipants:
      syncParticipantsSet.add(normalizeEmailAddressOrUID(user))
  i = 0
  count = len(courseIdList)
  for courseId in courseIdList:
    i += 1
    if courseParticipantLists:
      syncParticipantsSet = set()
      for user in courseParticipantLists[courseId]:
        syncParticipantsSet.add(normalizeEmailAddressOrUID(user))
    courseId = checkCourseExists(croom, courseId, i, count)
    if courseId:
      currentParticipantsSet = set()
      for user in getUsersToModify(PARTICIPANT_EN_MAP[role], courseId):
        currentParticipantsSet.add(normalizeEmailAddressOrUID(user))
      _batchAddParticipantsToCourse(croom, courseId, i, count, list(syncParticipantsSet-currentParticipantsSet), role)
      _batchRemoveParticipantsFromCourse(croom, courseId, i, count, list(currentParticipantsSet-syncParticipantsSet), role)

# gam print course-participants [todrive [<ToDriveAttributes>]] (course|class <CourseID>)*|([teacher <UserItem>] [student <UserItem>]) [show all|students|teachers]
def doPrintCourseParticipants():
  croom = buildGAPIObject(CLASSROOM_API)
  todrive = {}
  titles, csvRows = initializeTitlesCSVfile([u'courseId',])
  courses = []
  teacherId = None
  studentId = None
  showMembers = u'all'
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg in [u'course', u'class']:
      courses.append(getCourseId())
    elif myarg == u'teacher':
      teacherId = getEmailAddress()
    elif myarg == u'student':
      studentId = getEmailAddress()
    elif myarg == u'show':
      showMembers = getChoice([u'all', u'students', u'teachers'])
    else:
      unknownArgumentExit()
  if len(courses) == 0:
    printGettingAccountEntitiesInfo(Entity.COURSE)
    page_message = getPageMessage()
    try:
      all_courses = callGAPIpages(croom.courses(), u'list', u'courses',
                                  page_message=page_message,
                                  throw_reasons=[GAPI_NOT_FOUND, GAPI_FORBIDDEN, GAPI_BAD_REQUEST],
                                  teacherId=teacherId, studentId=studentId, pageSize=GC_Values[GC_CLASSROOM_MAX_RESULTS])
    except (GAPI_notFound, GAPI_forbidden, GAPI_badRequest):
      if not studentId:
        entityUnknownWarning(Entity.TEACHER, teacherId)
      elif not teacherId:
        entityUnknownWarning(Entity.STUDENT, studentId)
      else:
        entityOrEntityUnknownWarning(Entity.TEACHER, teacherId, Entity.STUDENT, studentId)
      return
  else:
    all_courses = collections.deque()
    for course in courses:
      courseId = addCourseIdScope(course)
      try:
        info = callGAPI(croom.courses(), u'get',
                        throw_reasons=[GAPI_NOT_FOUND],
                        id=courseId)
        all_courses.append(info)
      except GAPI_notFound:
        entityDoesNotExistWarning(Entity.COURSE, courseId)
  i = 0
  count = len(all_courses)
  for course in all_courses:
    i += 1
    courseId = course[u'id']
    page_message = getPageMessageForWhom(forWhom=formatKeyValueList(u'',
                                                                    [Entity.Singular(Entity.COURSE), courseId],
                                                                    currentCount(i, count)))
    try:
      if showMembers != u'students':
        Entity.SetGetting(Entity.TEACHER)
        results = callGAPIpages(croom.courses().teachers(), u'list', u'teachers',
                                page_message=page_message,
                                throw_reasons=[GAPI_NOT_FOUND, GAPI_FORBIDDEN],
                                courseId=courseId, pageSize=GC_Values[GC_CLASSROOM_MAX_RESULTS])
        for member in results:
          addRowTitlesToCSVfile(flattenJSON(member, flattened={u'courseId': courseId, u'courseName': course[u'name'], u'userRole': u'TEACHER'}), csvRows, titles)
      if showMembers != u'teachers':
        Entity.SetGetting(Entity.STUDENT)
        results = callGAPIpages(croom.courses().students(), u'list', u'students',
                                page_message=page_message,
                                throw_reasons=[GAPI_NOT_FOUND, GAPI_FORBIDDEN],
                                courseId=courseId, pageSize=GC_Values[GC_CLASSROOM_MAX_RESULTS])
        for member in results:
          addRowTitlesToCSVfile(flattenJSON(member, flattened={u'courseId': courseId, u'courseName': course[u'name'], u'userRole': u'STUDENT'}), csvRows, titles)
    except GAPI_forbidden:
      APIAccessDeniedExit()
  writeCSVfile(csvRows, titles, u'Course Participants', todrive)

def encode_multipart(fields, files, boundary=None):
  def escape_quote(s):
    return s.replace('"', '\\"')

  def getFormDataLine(name, value, boundary):
    return '--{0}'.format(boundary), 'Content-Disposition: form-data; name="{0}"'.format(escape_quote(name)), '', str(value)

  if boundary is None:
    boundary = ''.join(random.choice(string.digits+string.ascii_letters) for i in range(30))
  lines = []
  for name, value in fields.items():
    if name == u'tags':
      for tag in value:
        lines.extend(getFormDataLine('tag', tag, boundary))
    else:
      lines.extend(getFormDataLine(name, value, boundary))
  for name, value in files.items():
    filename = value[u'filename']
    mimetype = value[u'mimetype']
    lines.extend((
      '--{0}'.format(boundary),
      'Content-Disposition: form-data; name="{0}"; filename="{1}"'.format(escape_quote(name), escape_quote(filename)),
      'Content-Type: {0}'.format(mimetype),
      '',
      value[u'content'],
    ))
  lines.extend((
    '--{0}--'.format(boundary),
    '',
  ))
  body = '\r\n'.join(lines)
  headers = {
    'Content-Type': 'multipart/form-data; boundary={0}'.format(boundary),
    'Content-Length': str(len(body)),
  }
  return (body, headers)

# gam printer register
def doPrinterRegister():
  cp = buildGAPIObject(CLOUDPRINT_API)
  form_fields = {u'name': u'GAM',
                 u'proxy': u'GAM',
                 u'uuid': cp._http.request.credentials.id_token[u'sub'],
                 u'manufacturer': __author__,
                 u'model': u'cp1',
                 u'gcp_version': u'2.0',
                 u'setup_url': GAM_URL,
                 u'support_url': u'https://groups.google.com/forum/#!forum/google-apps-manager',
                 u'update_url': GAM_RELEASES,
                 u'firmware': __version__,
                 u'semantic_state': {"version": "1.0", "printer": {"state": "IDLE",}},
                 u'use_cdd': True,
                 u'capabilities': {"version": "1.0",
                                   "printer": {"supported_content_type": [{"content_type": "application/pdf", "min_version": "1.5"},
                                                                          {"content_type": "image/jpeg"},
                                                                          {"content_type": "text/plain"},
                                                                         ],
                                               "copies": {"default": 1, "max": 100},
                                               "media_size": {"option": [{"name": "ISO_A4", "width_microns": 210000, "height_microns": 297000},
                                                                         {"name": "NA_LEGAL", "width_microns": 215900, "height_microns": 355600},
                                                                         {"name": "NA_LETTER", "width_microns": 215900, "height_microns": 279400, "is_default": True},
                                                                        ],
                                                             },
                                              },
                                  },
                 u'tags': [u'GAM', GAM_URL],
                }
  body, headers = encode_multipart(form_fields, {})
  #Get the printer first to make sure our OAuth access token is fresh
  callGAPI(cp.printers(), u'list')
  _, result = cp._http.request(uri='https://www.google.com/cloudprint/register', method='POST', body=body, headers=headers)
  result = checkCloudPrintResult(result)
  entityActionPerformed([Entity.PRINTER, result[u'printers'][0][u'id']])
#
PRINTER_UPDATE_ITEMS_CHOICES_MAP = {
  u'currentquota': u'currentQuota',
  u'dailyquota': u'dailyQuota',
  u'defaultdisplayname': u'defaultDisplayName',
  u'description': u'description',
  u'displayname': u'displayName',
  u'firmware': u'firmware',
  u'gcpversion': u'gcpVersion',
  u'istosaccepted': u'isTosAccepted',
  u'manufacturer': u'manufacturer',
  u'model': u'model',
  u'name': u'name',
  u'ownerid': u'ownerId',
  u'proxy': u'proxy',
  u'public': u'public',
  u'quotaenabled': u'quotaEnabled',
  u'setupurl': u'setupUrl',
  u'status': u'status',
  u'supporturl': u'supportUrl',
  u'type': u'type',
  u'updateurl': u'updateUrl',
  u'uuid': u'uuid',
  }

# gam update printer|printers <PrinterIDEntity> <PrinterAttributes>
def doUpdatePrinters():
  cp = buildGAPIObject(CLOUDPRINT_API)
  entityList = getEntityList(OB_PRINTER_ID_ENTITY)
  kwargs = {}
  while CLArgs.ArgumentsRemaining():
    item = getChoice(PRINTER_UPDATE_ITEMS_CHOICES_MAP, mapChoice=True)
    if item in [u'isTosAccepted', u'public', u'quotaEnabled']:
      kwargs[item] = getBoolean()
    elif item in [u'currentQuota', u'dailyQuota', u'status']:
      kwargs[item] = getInteger(minVal=0)
    elif item in [u'displayName', u'defaultDisplayName']:
      kwargs[item] = getString(OB_STRING, minLen=0)
    else:
      kwargs[item] = getString(OB_STRING)
  i = 0
  count = len(entityList)
  for printerId in entityList:
    i += 1
    try:
      callGCP(cp.printers(), u'update',
              throw_messages=[GCP_UNKNOWN_PRINTER],
              printerid=printerId, **kwargs)
      entityActionPerformed([Entity.PRINTER, printerId], i, count)
    except GCP_unknownPrinter as e:
      entityActionFailedWarning([Entity.PRINTER, printerId], e.message, i, count)

# gam delete printer|printers <PrinterIDEntity>
def doDeletePrinters():
  cp = buildGAPIObject(CLOUDPRINT_API)
  entityList = getEntityList(OB_PRINTER_ID_ENTITY)
  checkForExtraneousArguments()
  i = 0
  count = len(entityList)
  for printerId in entityList:
    i += 1
    try:
      callGCP(cp.printers(), u'delete',
              throw_messages=[GCP_UNKNOWN_PRINTER],
              printerid=printerId)
      entityActionPerformed([Entity.PRINTER, printerId], i, count)
    except GCP_unknownPrinter as e:
      entityActionFailedWarning([Entity.PRINTER, printerId], e.message, i, count)

# gam info printers <PrinterIDEntity> [everything]
def doInfoPrinters():
  cp = buildGAPIObject(CLOUDPRINT_API)
  entityList = getEntityList(OB_PRINTER_ID_ENTITY)
  everything = False
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'everything':
      everything = True
    else:
      unknownArgumentExit()
  i = 0
  count = len(entityList)
  for printerId in entityList:
    i += 1
    try:
      result = callGCP(cp.printers(), u'get',
                       throw_messages=[GCP_UNKNOWN_PRINTER],
                       printerid=printerId)
      printEntity([Entity.PRINTER, printerId], i, count)
      Indent.Increment()
      printer_info = result[u'printers'][0]
      printer_info[u'createTime'] = formatLocalTimestamp(printer_info[u'createTime'])
      printer_info[u'accessTime'] = formatLocalTimestamp(printer_info[u'accessTime'])
      printer_info[u'updateTime'] = formatLocalTimestamp(printer_info[u'updateTime'])
      printer_info[u'tags'] = u' '.join(printer_info[u'tags'])
      if not everything:
        del printer_info[u'capabilities']
        del printer_info[u'access']
      showJSON(None, printer_info)
      Indent.Decrement()
    except GCP_unknownPrinter as e:
      entityActionFailedWarning([Entity.PRINTER, printerId], e.message, i, count)

# gam print printers [todrive [<ToDriveAttributes>]] [query <QueryPrintJob>] [type <String>] [status <String>] [extrafields <String>] [delimiter <String>]
def doPrintPrinters():
  cp = buildGAPIObject(CLOUDPRINT_API)
  todrive = {}
  titles, csvRows = initializeTitlesCSVfile([u'id',])
  query = None
  printer_type = None
  connection_status = None
  extra_fields = None
  delimiter = GC_Values[GC_CSV_OUTPUT_FIELD_DELIMITER]
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'query':
      query = getString(OB_QUERY)
    elif myarg == u'type':
      printer_type = getString(OB_STRING)
    elif myarg == u'status':
      connection_status = getString(OB_STRING)
    elif myarg == u'extrafields':
      extra_fields = getString(OB_STRING)
    elif myarg == u'delimiter':
      delimiter = getDelimiter()
    else:
      unknownArgumentExit()
  printers = callGCP(cp.printers(), u'list',
                     q=query, type=printer_type, connection_status=connection_status, extra_fields=extra_fields)
  for printer in printers[u'printers']:
    printer[u'createTime'] = formatLocalTimestamp(printer[u'createTime'])
    printer[u'accessTime'] = formatLocalTimestamp(printer[u'accessTime'])
    printer[u'updateTime'] = formatLocalTimestamp(printer[u'updateTime'])
    printer[u'tags'] = delimiter.join(printer[u'tags'])
    addRowTitlesToCSVfile(flattenJSON(printer), csvRows, titles)
  writeCSVfile(csvRows, titles, u'Printers', todrive)

def normalizePrinterScopeList(rawScopeList):
  scopeList = []
  for scope in rawScopeList:
    scope = scope.lower()
    if scope != u'public':
      if scope == u'domain':
        scope = u'/hd/domain/{0}'.format(GC_Values[GC_DOMAIN])
      elif scope.startswith(u'domain:'):
        scope = u'/hd/domain/{0}'.format(scope[7:])
      else:
        scope = normalizeEmailAddressOrUID(scope, noUid=True)
    scopeList.append(scope)
  return scopeList

def getPrinterACLScopeEntity():
  _, scopeList = getEntityToModify(defaultEntityType=CL_ENTITY_USERS, groupUserMembersOnly=False)
  printerScopeLists = scopeList if isinstance(scopeList, dict) else None
  if not printerScopeLists:
    scopeList = normalizePrinterScopeList(scopeList)
  return scopeList, printerScopeLists

def _batchAddACLsToPrinter(cp, printerId, i, count, scopeList, role):
  Action.Set(Action.ADD)
  jcount = len(scopeList)
  entityPerformActionNumItems([Entity.PRINTER, printerId], jcount, role, i, count)
  Indent.Increment()
  j = 0
  for scope in scopeList:
    j += 1
    if scope.lower() == u'public':
      public = True
      scope = None
      roleForScope = None
      skip_notification = None
    else:
      public = None
      roleForScope = role
      skip_notification = True
    try:
      callGCP(cp.printers(), u'share',
              throw_messages=[GCP_UNKNOWN_PRINTER, GCP_FAILED_TO_SHARE_THE_PRINTER, GCP_USER_IS_NOT_AUTHORIZED],
              printerid=printerId, role=roleForScope, scope=scope, public=public, skip_notification=skip_notification)
      if scope is None:
        scope = u'public'
        roleForScope = Entity.ROLE_USER
      entityActionPerformed([Entity.PRINTER, printerId, roleForScope, scope], j, jcount)
    except GCP_userIsNotAuthorized:
      entityActionFailedWarning([Entity.PRINTER, printerId, roleForScope, scope], PHRASE_ONLY_ONE_OWNER_ALLOWED, j, jcount)
    except GCP_failedToShareThePrinter:
      entityActionFailedWarning([Entity.PRINTER, printerId, roleForScope, scope], PHRASE_INVALID_SCOPE, j, jcount)
    except GCP_unknownPrinter as e:
      entityActionFailedWarning([Entity.PRINTER, printerId], e.message, i, count)
      break
  Indent.Decrement()

PRINTER_ROLE_MAP = {u'manager': Entity.ROLE_MANAGER, u'owner': Entity.ROLE_OWNER, u'user': Entity.ROLE_USER,}

# gam printer|printers <PrinterIDEntity> add user|manager|owner <PrinterACLScopeEntity>
def doPrinterAddACL(printerIdList):
  cp = buildGAPIObject(CLOUDPRINT_API)
  role = getChoice(PRINTER_ROLE_MAP, mapChoice=True)
  scopeList, printerScopeLists = getPrinterACLScopeEntity()
  checkForExtraneousArguments()
  i = 0
  count = len(printerIdList)
  for printerId in printerIdList:
    i += 1
    if printerScopeLists:
      scopeList = normalizePrinterScopeList(printerScopeLists[printerId])
    _batchAddACLsToPrinter(cp, printerId, i, count, scopeList, role)

def _batchDeleteACLsFromPrinter(cp, printerId, i, count, scopeList, role):
  Action.Set(Action.DELETE)
  jcount = len(scopeList)
  entityPerformActionNumItems([Entity.PRINTER, printerId], jcount, role, i, count)
  Indent.Increment()
  j = 0
  for scope in scopeList:
    j += 1
    if scope.lower() == u'public':
      public = True
      scope = None
    else:
      public = None
    try:
      callGCP(cp.printers(), u'unshare',
              throw_messages=[GCP_UNKNOWN_PRINTER],
              printerid=printerId, scope=scope, public=public)
      if scope is None:
        scope = u'public'
      entityActionPerformed([Entity.PRINTER, printerId, Entity.SCOPE, scope], j, jcount)
    except GCP_unknownPrinter as e:
      entityActionFailedWarning([Entity.PRINTER, printerId], e.message, i, count)
      break
  Indent.Decrement()

# gam printer|printers <PrinterIDEntity> delete <PrinterACLScopeEntity>
def doPrinterDeleteACLs(printerIdList):
  cp = buildGAPIObject(CLOUDPRINT_API)
  scopeList, printerScopeLists = getPrinterACLScopeEntity()
  checkForExtraneousArguments()
  i = 0
  count = len(printerIdList)
  for printerId in printerIdList:
    i += 1
    if printerScopeLists:
      scopeList = normalizePrinterScopeList(printerScopeLists[printerId])
    _batchDeleteACLsFromPrinter(cp, printerId, i, count, scopeList, Entity.SCOPE)

def getPrinterScopeListsForRole(cp, printerId, i, count, role):
  try:
    result = callGCP(cp.printers(), u'get',
                     throw_messages=[GCP_UNKNOWN_PRINTER],
                     printerid=printerId)
    try:
      jcount = len(result[u'printers'][0][u'access'])
    except KeyError:
      jcount = 0
    scopeList = []
    if jcount > 0:
      for acl in result[u'printers'][0][u'access']:
        if acl[u'role'] == role:
          scopeList.append(acl[u'scope'].lower())
    return scopeList
  except GCP_unknownPrinter as e:
    entityActionFailedWarning([Entity.PRINTER, printerId], e.message, i, count)
    return None

# gam printer|printers <PrinterIDEntity> sync user|manager|owner <PrinterACLScopeEntity>
def doPrinterSyncACLs(printerIdList):
  cp = buildGAPIObject(CLOUDPRINT_API)
  role = getChoice(PRINTER_ROLE_MAP, mapChoice=True)
  scopeList, printerScopeLists = getPrinterACLScopeEntity()
  checkForExtraneousArguments()
  i = 0
  count = len(printerIdList)
  for printerId in printerIdList:
    i += 1
    if printerScopeLists:
      scopeList = normalizePrinterScopeList(printerScopeLists[printerId])
    currentScopeList = getPrinterScopeListsForRole(cp, printerId, i, count, role)
    if currentScopeList is not None:
      _batchAddACLsToPrinter(cp, printerId, i, count, list(set(scopeList) - set(currentScopeList)), role)
      _batchDeleteACLsFromPrinter(cp, printerId, i, count, list(set(currentScopeList) - set(scopeList)), role)

# gam printer|printers <PrinterIDEntity> wipe user|manager|owner
def doPrinterWipeACLs(printerIdList):
  cp = buildGAPIObject(CLOUDPRINT_API)
  role = getChoice(PRINTER_ROLE_MAP, mapChoice=True)
  checkForExtraneousArguments()
  i = 0
  count = len(printerIdList)
  for printerId in printerIdList:
    i += 1
    currentScopeList = getPrinterScopeListsForRole(cp, printerId, i, count, role)
    if currentScopeList is not None:
      _batchDeleteACLsFromPrinter(cp, printerId, i, count, currentScopeList, role)

# gam printer|printers <PrinterIDEntity> printacls [todrive [<ToDriveAttributes>]]
def doPrinterPrintACLs(printerIdList):
  doPrinterPrintShowACLs(printerIdList, True)

# gam printer|printers <PrinterIDEntity> showacls
def doPrinterShowACLs(printerIdList):
  doPrinterPrintShowACLs(printerIdList, False)

def doPrinterPrintShowACLs(printerIdList, csvFormat):
  cp = buildGAPIObject(CLOUDPRINT_API)
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile([u'id',])
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    else:
      unknownArgumentExit()
  i = 0
  count = len(printerIdList)
  for printerId in printerIdList:
    i += 1
    try:
      result = callGCP(cp.printers(), u'get',
                       throw_messages=[GCP_UNKNOWN_PRINTER],
                       printerid=printerId)
      try:
        jcount = len(result[u'printers'][0][u'access'])
      except KeyError:
        jcount = 0
      if not csvFormat:
        entityPerformActionNumItems([Entity.PRINTER, printerId], jcount, Entity.PRINTER_ACL, i, count)
      if jcount == 0:
        setSysExitRC(NO_ENTITIES_FOUND)
        continue
      if not csvFormat:
        Indent.Increment()
        for acl in result[u'printers'][0][u'access']:
          if u'key' in acl:
            acl[u'accessURL'] = CLOUDPRINT_ACCESS_URL.format(printerId, acl[u'key'])
          showJSON(None, acl)
          printBlankLine()
        Indent.Decrement()
      else:
        for acl in result[u'printers'][0][u'access']:
          if u'key' in acl:
            acl[u'accessURL'] = CLOUDPRINT_ACCESS_URL.format(printerId, acl[u'key'])
          addRowTitlesToCSVfile(flattenJSON(acl, flattened={u'id': printerId}), csvRows, titles)
    except GCP_unknownPrinter as e:
      entityActionFailedWarning([Entity.PRINTER, printerId], e.message, i, count)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'PrinterACLs', todrive)

# gam printjob|printjobs <PrintJobEntity> cancel
def doPrintJobCancel(jobIdList):
  cp = buildGAPIObject(CLOUDPRINT_API)
  checkForExtraneousArguments()
  ssd = u'{"state": {"type": "ABORTED", "user_action_cause": {"action_code": "CANCELLED"}}}'
  i = 0
  count = len(jobIdList)
  for jobId in jobIdList:
    i += 1
    try:
      callGCP(cp.jobs(), u'update',
              throw_messages=[GCP_UNKNOWN_JOB_ID],
              jobid=jobId, semantic_state_diff=ssd)
      entityActionPerformed([Entity.PRINTJOB, jobId], i, count)
    except GCP_unknownJobId as e:
      entityActionFailedWarning([Entity.PRINTJOB, jobId], e.message, i, count)

# gam printjob|printjobs <PrintJobEntity> delete
def doPrintJobDelete(jobIdList):
  cp = buildGAPIObject(CLOUDPRINT_API)
  checkForExtraneousArguments()
  i = 0
  count = len(jobIdList)
  for jobId in jobIdList:
    i += 1
    try:
      callGCP(cp.jobs(), u'delete',
              throw_messages=[GCP_UNKNOWN_JOB_ID],
              jobid=jobId)
      entityActionPerformed([Entity.PRINTJOB, jobId], i, count)
    except GCP_unknownJobId as e:
      entityActionFailedWarning([Entity.PRINTJOB, jobId], e.message, i, count)

# gam printjob|printjobs <PrintJobEntity> resubmit <PrinterID>
def doPrintJobResubmit(jobIdList):
  cp = buildGAPIObject(CLOUDPRINT_API)
  printerId = getString(OB_PRINTER_ID)
  ssd = u'{"state": {"type": "HELD"}}'
  i = 0
  count = len(jobIdList)
  for jobId in jobIdList:
    i += 1
    try:
      result = callGCP(cp.jobs(), u'update',
                       throw_messages=[GCP_UNKNOWN_JOB_ID, GCP_CANT_MODIFY_FINISHED_JOB],
                       jobid=jobId, semantic_state_diff=ssd)
      ticket = callGCP(cp.jobs(), u'getticket',
                       throw_messages=[GCP_UNKNOWN_JOB_ID, GCP_CANT_MODIFY_FINISHED_JOB],
                       jobid=jobId, use_cjt=True)
      result = callGCP(cp.jobs(), u'resubmit',
                       throw_messages=[GCP_UNKNOWN_PRINTER, GCP_UNKNOWN_JOB_ID, GCP_CANT_MODIFY_FINISHED_JOB],
                       printerid=printerId, jobid=jobId, ticket=ticket)
      entityActionPerformed([Entity.PRINTJOB, result[u'job'][u'id'], Entity.PRINTER, printerId], i, count)
    except GCP_unknownJobId as e:
      entityActionFailedWarning([Entity.PRINTJOB, jobId], e.message, count)
    except (GCP_cantModifyFinishedJob, GCP_unknownPrinter) as e:
      entityActionFailedWarning([Entity.PRINTJOB, jobId, Entity.PRINTER, printerId], e.message, i, count)
#
PRINTJOB_STATUS_MAP = {
  u'done': u'DONE',
  u'error': u'ERROR',
  u'held': u'HELD',
  u'inprogress': u'IN_PROGRESS',
  u'queued': u'QUEUED',
  u'submitted': u'SUBMITTED',
  }
# Map argument to API value
PRINTJOB_ASCENDINGORDER_MAP = {
  u'createtime': u'CREATE_TIME',
  u'status': u'STATUS',
  u'title': u'TITLE',
  }
# Map API value from ascending to descending
PRINTJOB_DESCENDINGORDER_MAP = {
  u'CREATE_TIME': u'CREATE_TIME_DESC',
  u'STATUS':  u'STATUS_DESC',
  u'TITLE': u'TITLE_DESC',
  }

PRINTJOBS_DEFAULT_JOB_LIMIT = 25
PRINTJOBS_DEFAULT_MAX_RESULTS = 100

def initPrintjobListParameters():
  return {u'older_or_newer': 0,
          u'age': None,
          u'sortorder': None,
          u'owner': None,
          u'query': None,
          u'status': None,
          u'jobLimit': PRINTJOBS_DEFAULT_JOB_LIMIT,
         }

def getPrintjobListParameters(myarg, parameters):
  if myarg == u'olderthan':
    parameters[u'older_or_newer'] = 1
    parameters[u'age'] = getAgeTime()
  elif myarg == u'newerthan':
    parameters[u'older_or_newer'] = -1
    parameters[u'age'] = getAgeTime()
  elif myarg == u'query':
    parameters[u'query'] = getString(OB_QUERY)
  elif myarg == u'status':
    parameters[u'status'] = getChoice(PRINTJOB_STATUS_MAP, mapChoice=True)
  elif myarg == u'orderby':
    parameters[u'sortorder'] = getChoice(PRINTJOB_ASCENDINGORDER_MAP, mapChoice=True)
    if getChoice(SORTORDER_CHOICES_MAP, defaultChoice=u'ascending', mapChoice=True) == u'DESCENDING':
      parameters[u'sortorder'] = PRINTJOB_DESCENDINGORDER_MAP[parameters[u'sortorder']]
  elif myarg in [u'owner', u'user']:
    parameters[u'owner'] = getEmailAddress(noUid=True)
  elif myarg == u'limit':
    parameters[u'jobLimit'] = getInteger(minVal=0)
  else:
    unknownArgumentExit()

# gam printjob <PrinterID>|any fetch
#	[olderthan|newerthan <PrintJobAge>] [query <QueryPrintJob>]
#	[status done|error|held|in_progress|queued|submitted]
#	[orderby <PrintJobOrderByFieldName> [ascending|descending]]
#	[owner|user <EmailAddress>]
#	[limit <Number>] [drivedir|(targetfolder <FilePath>)]
def doPrintJobFetch(printerIdList):
  cp = buildGAPIObject(CLOUDPRINT_API)
  printerId = printerIdList[0]
  if printerId.lower() == u'any':
    printerId = None
  parameters = initPrintjobListParameters()
  targetFolder = os.getcwd()
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'drivedir':
      targetFolder = GC_Values[GC_DRIVE_DIR]
    elif myarg == u'targetfolder':
      targetFolder = os.path.expanduser(getString(OB_FILE_PATH))
      if not os.path.isdir(targetFolder):
        os.makedirs(targetFolder)
    else:
      getPrintjobListParameters(myarg, parameters)
  if printerId:
    try:
      callGCP(cp.printers(), u'get',
              throw_messages=[GCP_UNKNOWN_PRINTER],
              printerid=printerId)
    except GCP_unknownPrinter as e:
      entityActionFailedWarning([Entity.PRINTER, printerId], e.message)
      return
  ssd = u'{"state": {"type": "DONE"}}'
  jobCount = offset = 0
  while True:
    if parameters[u'jobLimit'] == 0:
      limit = PRINTJOBS_DEFAULT_MAX_RESULTS
    else:
      limit = min(PRINTJOBS_DEFAULT_MAX_RESULTS, parameters[u'jobLimit']-jobCount)
      if limit == 0:
        break
    result = callGCP(cp.jobs(), u'list',
                     throw_messages=[GCP_UNKNOWN_PRINTER, GCP_NO_PRINT_JOBS],
                     printerid=printerId, q=parameters[u'query'], status=parameters[u'status'], sortorder=parameters[u'sortorder'],
                     owner=parameters[u'owner'], offset=offset, limit=limit)
    newJobs = result[u'range'][u'jobsCount']
    if newJobs == 0:
      break
    jobCount += newJobs
    offset += newJobs
    for job in result[u'jobs']:
      createTime = int(job[u'createTime'])
      if parameters[u'older_or_newer'] > 0:
        if createTime > parameters[u'age']:
          continue
      elif parameters[u'older_or_newer'] < 0:
        if createTime < parameters[u'age']:
          continue
      jobId = job[u'id']
      fileName = os.path.join(targetFolder, u'{0}-{1}'.format(cleanFilename(job[u'title']), jobId))
      _, content = cp._http.request(job[u'fileUrl'], method='GET')
      if writeFile(fileName, content, continueOnError=True):
#        ticket = callGCP(cp.jobs(), u'getticket',
#                         jobid=jobId, use_cjt=True)
        result = callGCP(cp.jobs(), u'update',
                         jobid=jobId, semantic_state_diff=ssd)
        entityModifierNewValueActionPerformed([Entity.PRINTER, printerId, Entity.PRINTJOB, jobId], Action.MODIFIER_TO, fileName)
  if jobCount == 0:
    entityActionFailedWarning([Entity.PRINTER, printerId, Entity.PRINTJOB, u''], PHRASE_NO_PRINT_JOBS)

# gam print printjobs [todrive [<ToDriveAttributes>]] [printer|printerid <PrinterID>]
#	[olderthan|newerthan <PrintJobAge>] [query <QueryPrintJob>]
#	[status <PrintJobStatus>]
#	[orderby <PrintJobOrderByFieldName> [ascending|descending]]
#	[owner|user <EmailAddress>]
#	[limit <Number>] [delimiter <String>]
def doPrintPrintJobs():
  cp = buildGAPIObject(CLOUDPRINT_API)
  todrive = {}
  titles, csvRows = initializeTitlesCSVfile([u'printerid', u'id'])
  printerId = None
  parameters = initPrintjobListParameters()
  delimiter = GC_Values[GC_CSV_OUTPUT_FIELD_DELIMITER]
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg in [u'printer', u'printerid']:
      printerId = getString(OB_PRINTER_ID)
    elif myarg == u'delimiter':
      delimiter = getDelimiter()
    else:
      getPrintjobListParameters(myarg, parameters)
  if printerId:
    try:
      callGCP(cp.printers(), u'get',
              throw_messages=[GCP_UNKNOWN_PRINTER],
              printerid=printerId)
    except GCP_unknownPrinter as e:
      entityActionFailedWarning([Entity.PRINTER, printerId], e.message)
      return
  jobCount = offset = 0
  while True:
    if parameters[u'jobLimit'] == 0:
      limit = PRINTJOBS_DEFAULT_MAX_RESULTS
    else:
      limit = min(PRINTJOBS_DEFAULT_MAX_RESULTS, parameters[u'jobLimit']-jobCount)
      if limit == 0:
        break
    result = callGCP(cp.jobs(), u'list',
                     printerid=printerId, q=parameters[u'query'], status=parameters[u'status'], sortorder=parameters[u'sortorder'],
                     owner=parameters[u'owner'], offset=offset, limit=limit)
    newJobs = result[u'range'][u'jobsCount']
    if newJobs == 0:
      break
    jobCount += newJobs
    offset += newJobs
    for job in result[u'jobs']:
      createTime = int(job[u'createTime'])
      if parameters[u'older_or_newer'] > 0:
        if createTime > parameters[u'age']:
          continue
      elif parameters[u'older_or_newer'] < 0:
        if createTime < parameters[u'age']:
          continue
      job[u'createTime'] = formatLocalTimestamp(job[u'createTime'])
      job[u'updateTime'] = formatLocalTimestamp(job[u'updateTime'])
      job[u'tags'] = delimiter.join(job[u'tags'])
      addRowTitlesToCSVfile(flattenJSON(job), csvRows, titles)
  writeCSVfile(csvRows, titles, u'Print Jobs', todrive)

# gam printjob <PrinterID> submit <FileName>|<URL> [name|title <String>] (tag <String>)*
def doPrintJobSubmit(printerIdList):
  cp = buildGAPIObject(CLOUDPRINT_API)
  printerId = printerIdList[0]
  content = getString(OB_FILE_NAME_OR_URL)
  form_fields = {u'printerid': printerId,
                 u'title': content,
                 u'ticket': u'{"version": "1.0"}',
                 u'tags': [u'GAM', GAM_URL]}
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'tag':
      form_fields[u'tags'].append(getString(OB_STRING))
    elif myarg in [u'name', u'title']:
      form_fields[u'title'] = getString(OB_STRING)
    else:
      unknownArgumentExit()
  form_files = {}
  if content[:4] == u'http':
    form_fields[u'content'] = content
    form_fields[u'contentType'] = u'url'
  else:
    filepath = content
    content = os.path.basename(content)
    mimetype = mimetypes.guess_type(filepath)[0]
    if mimetype is None:
      mimetype = u'application/octet-stream'
    filecontent = readFile(filepath, mode=u'rb')
    form_files[u'content'] = {u'filename': content, u'content': filecontent, u'mimetype': mimetype}
#  result = callGCP(cp.printers(), u'submit',
#                   body=body)
  body, headers = encode_multipart(form_fields, form_files)
  try:
    #Get the printer first to make sure our OAuth access token is fresh
    callGCP(cp.printers(), u'get',
            throw_messages=[GCP_UNKNOWN_PRINTER],
            printerid=printerId)
    _, result = cp._http.request(uri='https://www.google.com/cloudprint/submit', method='POST', body=body, headers=headers)
    result = checkCloudPrintResult(result)
    entityActionPerformed([Entity.PRINTER, printerId, Entity.PRINTJOB, result[u'job'][u'id']])
  except GCP_unknownPrinter as e:
    entityActionFailedWarning([Entity.PRINTER, printerId], e.message)

def _showASPs(user, asps, i=0, count=0):
  Action.Set(Action.SHOW)
  jcount = len(asps)
  entityPerformActionNumItems([Entity.USER, user], jcount, Entity.APPLICATION_SPECIFIC_PASSWORD, i, count)
  if jcount == 0:
    setSysExitRC(NO_ENTITIES_FOUND)
    return
  Indent.Increment()
  for asp in asps:
    if asp[u'creationTime'] == u'0':
      created_date = u'Unknown'
    else:
      created_date = formatLocalTimestamp(asp[u'creationTime'])
    if asp[u'lastTimeUsed'] == u'0':
      used_date = NEVER
    else:
      used_date = formatLocalTimestamp(asp[u'lastTimeUsed'])
    printKeyValueList([u'ID', asp[u'codeId']])
    Indent.Increment()
    printKeyValueList([u'Name', asp[u'name']])
    printKeyValueList([u'Created', created_date])
    printKeyValueList([u'Last Used', used_date])
    Indent.Decrement()
  Indent.Decrement()

# gam <UserTypeEntity> delete asps|applicationspecificpasswords <AspID>
def deleteASP(users):
  cd = buildGAPIObject(DIRECTORY_API)
  codeId = getString(OB_ASP_ID)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      callGAPI(cd.asps(), u'delete',
               throw_reasons=[GAPI_USER_NOT_FOUND, GAPI_INVALID],
               userKey=user, codeId=codeId)
      entityActionPerformed([Entity.USER, user, Entity.APPLICATION_SPECIFIC_PASSWORD, codeId], i, count)
    except GAPI_userNotFound:
      entityUnknownWarning(Entity.USER, user, i, count)
    except GAPI_invalid:
      entityActionFailedWarning([Entity.USER, user, Entity.APPLICATION_SPECIFIC_PASSWORD, codeId], PHRASE_DOES_NOT_EXIST, i, count)

# gam <UserTypeEntity> show asps|applicationspecificpasswords
def showASPs(users):
  cd = buildGAPIObject(DIRECTORY_API)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      asps = callGAPIitems(cd.asps(), u'list', u'items',
                           throw_reasons=[GAPI_USER_NOT_FOUND],
                           userKey=user)
      _showASPs(user, asps, i, count)
    except GAPI_userNotFound:
      entityUnknownWarning(Entity.USER, user, i, count)

def _showBackupCodes(user, codes, i, count):
  Action.Set(Action.SHOW)
  jcount = len(codes)
  entityPerformActionNumItems([Entity.USER, user], jcount, Entity.BACKUP_VERIFICATION_CODES, i, count)
  if jcount == 0:
    setSysExitRC(NO_ENTITIES_FOUND)
    return
  Indent.Increment()
  j = 0
  for code in codes:
    j += 1
    printKeyValueList([u'{0:2}'.format(j), code[u'verificationCode']])
  Indent.Decrement()

# gam <UserTypeEntity> update backupcodes|verificationcodes
def updateBackupCodes(users):
  cd = buildGAPIObject(DIRECTORY_API)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      callGAPI(cd.verificationCodes(), u'generate',
               throw_reasons=[GAPI_USER_NOT_FOUND],
               userKey=user)
      codes = callGAPIitems(cd.verificationCodes(), u'list', u'items',
                            throw_reasons=[GAPI_USER_NOT_FOUND],
                            userKey=user, fields=u'items(verificationCode)')
      _showBackupCodes(user, codes, i, count)
    except GAPI_userNotFound:
      entityUnknownWarning(Entity.USER, user, i, count)

# gam <UserTypeEntity> delete backupcodes|verificationcodes
def deleteBackupCodes(users):
  cd = buildGAPIObject(DIRECTORY_API)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      callGAPI(cd.verificationCodes(), u'invalidate',
               throw_reasons=[GAPI_USER_NOT_FOUND],
               userKey=user)
      printEntityKVList([Entity.USER, user], [Entity.Plural(Entity.BACKUP_VERIFICATION_CODES), u'', u'Invalidated'], i, count)
    except GAPI_userNotFound:
      entityUnknownWarning(Entity.USER, user, i, count)

# gam <UserTypeEntity> show backupcodes|verificationcodes
def showBackupCodes(users):
  cd = buildGAPIObject(DIRECTORY_API)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      codes = callGAPIitems(cd.verificationCodes(), u'list', u'items',
                            throw_reasons=[GAPI_USER_NOT_FOUND],
                            userKey=user, fields=u'items(verificationCode)')
      _showBackupCodes(user, codes, i, count)
    except GAPI_userNotFound:
      entityUnknownWarning(Entity.USER, user, i, count)

def _getCalendarSelectProperty(myarg, kwargs):
  if myarg == u'minaccessrole':
    kwargs[u'minAccessRole'] = getChoice(CALENDAR_ACL_ROLES_MAP, mapChoice=True)
  elif myarg == u'showdeleted':
    kwargs[u'showDeleted'] = True
  elif myarg == u'showhidden':
    kwargs[u'showHidden'] = True
  else:
    return False
  return True

def initCalendarEntity():
  return {u'list': [], u'kwargs': {}, u'dict': None, u'all': False, u'primary': False, u'resourceIds': []}

def getCalendarEntity(default=u'primary', noSelectionKwargs=None):

  def _noSelectionMade():
    return not calendarEntity[u'list'] and not calendarEntity[u'kwargs'] and calendarEntity[u'dict'] is None and not calendarEntity[u'all'] and not calendarEntity[u'primary'] and not calendarEntity[u'resourceIds']

  calendarEntity = initCalendarEntity()
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in [u'calendar', u'calendars']:
      entitySelector = getEntitySelector()
      if entitySelector:
        entityList = getEntitySelection(entitySelector, False)
        if isinstance(entityList, dict):
          calendarEntity[u'dict'] = entityList
        else:
          calendarEntity[u'list'] = entityList
      else:
        calendarEntity[u'list'].extend(convertEntityToList(getString(OB_EMAIL_ADDRESS)))
    elif myarg == u'allcalendars':
      calendarEntity[u'all'] = True
    elif myarg == u'primary':
      calendarEntity[u'primary'] = True
    elif _getCalendarSelectProperty(myarg, calendarEntity[u'kwargs']):
      pass
    elif myarg == u'resource':
      calendarEntity[u'resourceIds'].append(getString(OB_RESOURCE_ID))
    elif myarg == u'resources':
      calendarEntity[u'resourceIds'].extend(convertEntityToList(getString(OB_RESOURCE_ID, minLen=0), shlexSplit=True))
    elif _noSelectionMade() and myarg.find(u'@') != -1:
      calendarEntity[u'list'].extend(convertEntityToList(CLArgs.Previous().lower()))
    else:
      CLArgs.Backup()
      break
  if _noSelectionMade():
    if not noSelectionKwargs:
      calendarEntity[default] = True
    else:
      calendarEntity[u'all'] = True
      calendarEntity[u'kwargs'].update(noSelectionKwargs)
  return calendarEntity

def _validateUserGetCalendarIds(user, i, count, calendarEntity, itemType=None, modifier=None, showAction=True, setRC=True, newCalId=None):
  if calendarEntity[u'dict']:
    calIds = calendarEntity[u'dict'][user][:]
  else:
    calIds = calendarEntity[u'list'][:]
  user, cal = validateCalendar(user, i, count)
  if not cal:
    return (user, None, None, 0)
  if calendarEntity[u'resourceIds']:
    cd = buildGAPIObject(DIRECTORY_API)
    for resourceId in calendarEntity[u'resourceIds']:
      try:
        calIds.append(callGAPI(cd.resources().calendars(), u'get',
                               throw_reasons=[GAPI_BAD_REQUEST, GAPI_RESOURCE_NOT_FOUND, GAPI_FORBIDDEN],
                               customer=GC_Values[GC_CUSTOMER_ID], calendarResourceId=resourceId, fields=u'resourceEmail')[u'resourceEmail'])
      except (GAPI_badRequest, GAPI_resourceNotFound, GAPI_forbidden):
        checkEntityAFDNEorAccessErrorExit(cd, Entity.RESOURCE_CALENDAR, resourceId, i, count)
        return (user, None, None, 0)
  if calendarEntity[u'primary']:
    calIds.append(user)
  try:
    if calendarEntity[u'kwargs'] or calendarEntity[u'all']:
      result = callGAPIpages(cal.calendarList(), u'list', u'items',
                             throw_reasons=GAPI_CALENDAR_THROW_REASONS,
                             fields=u'nextPageToken,items/id', **calendarEntity[u'kwargs'])
      calIds.extend([calId[u'id'] for calId in result])
    else:
      callGAPI(cal.calendars(), u'get',
               throw_reasons=GAPI_CALENDAR_THROW_REASONS,
               calendarId=u'primary', fields=u'')
  except GAPI_notACalendarUser as e:
    entityActionFailedWarning([Entity.USER, user], e.message, i, count)
    return (user, None, None, 0)
  except (GAPI_serviceNotAvailable, GAPI_authError):
    entityServiceNotApplicableWarning(Entity.USER, user, i, count)
    return (user, None, None, 0)
  if newCalId:
    newcal = buildGAPIObject(CALENDAR_API)
    if not checkCalendarExists(newcal, newCalId):
      entityActionFailedWarning([Entity.USER, user, Entity.CALENDAR, newCalId], PHRASE_DOES_NOT_EXIST, i, count)
      return (user, None, None, 0)
  jcount = len(calIds)
  if setRC and jcount == 0:
    setSysExitRC(NO_ENTITIES_FOUND)
  if showAction:
    if not itemType:
      entityPerformActionNumItems([Entity.USER, user], jcount, Entity.CALENDAR, i, count)
    elif not newCalId:
      entityPerformActionSubItemModifierNumItems([Entity.USER, user], itemType, modifier, jcount, Entity.CALENDAR, i, count)
    else:
      entityPerformActionSubItemModifierNumItemsModifierNewValue([Entity.USER, user], itemType, modifier, jcount, Entity.CALENDAR, Action.MODIFIER_TO, newCalId, i, count)
  return (user, cal, calIds, jcount)

CALENDAR_NOTIFICATION_METHODS = [u'email', u'sms',]
CALENDAR_NOTIFICATION_TYPES_MAP = {
  u'eventcreation': u'eventCreation',
  u'eventchange': u'eventChange',
  u'eventcancellation': u'eventCancellation',
  u'eventresponse': u'eventResponse',
  u'agenda': u'agenda',
  }

def _getCalendarAttributes(body):
  colorRgbFormat = False
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'selected':
      body[u'selected'] = getBoolean()
    elif myarg == u'hidden':
      body[u'hidden'] = getBoolean()
    elif myarg == u'summary':
      body[u'summaryOverride'] = getString(OB_STRING)
    elif myarg in [u'colorindex', u'colorid']:
      body[u'colorId'] = str(getInteger(minVal=CALENDAR_MIN_COLOR_INDEX, maxVal=CALENDAR_MAX_COLOR_INDEX))
    elif myarg == u'backgroundcolor':
      body[u'backgroundColor'] = getColorHexAttribute()
      body.setdefault(u'foregroundColor', u'#000000')
      colorRgbFormat = True
    elif myarg == u'foregroundcolor':
      body[u'foregroundColor'] = getColorHexAttribute()
      colorRgbFormat = True
    elif myarg == u'reminder':
      body.setdefault(u'defaultReminders', [])
      if not checkArgumentPresent(CLEAR_NONE_ARGUMENT):
        body[u'defaultReminders'].append(getCalendarReminder(True))
    elif myarg == u'notification':
      body.setdefault(u'notificationSettings', {u'notifications': []})
      method = getChoice(CALENDAR_NOTIFICATION_METHODS+CLEAR_NONE_ARGUMENT)
      if method not in CLEAR_NONE_ARGUMENT:
        body[u'notificationSettings'][u'notifications'].append({u'method': method,
                                                                u'type': getChoice(CALENDAR_NOTIFICATION_TYPES_MAP, mapChoice=True)})
    else:
      unknownArgumentExit()
  return colorRgbFormat

def _showCalendar(userCalendar, j, jcount, acls=None):
  printEntity([Entity.CALENDAR, userCalendar[u'id']], j, jcount)
  Indent.Increment()
  printKeyValueList([u'Summary', userCalendar.get(u'summaryOverride', userCalendar[u'summary'])])
  printKeyValueList([u'Description', convertCRsNLs(userCalendar.get(u'description', u''))])
  printKeyValueList([u'Location', userCalendar.get(u'location', u'')])
  printKeyValueList([u'Timezone', userCalendar[u'timeZone']])
  printKeyValueList([u'Primary', userCalendar.get(u'primary', FALSE)])
  printKeyValueList([u'Access Level', userCalendar[u'accessRole']])
  printKeyValueList([u'Hidden', userCalendar.get(u'hidden', FALSE)])
  printKeyValueList([u'Selected', userCalendar.get(u'selected', FALSE)])
  printKeyValueList([u'Color ID', userCalendar[u'colorId'], u'Background Color', userCalendar[u'backgroundColor'], u'Foreground Color', userCalendar[u'foregroundColor']])
  printKeyValueList([u'Default Reminders', None])
  Indent.Increment()
  for reminder in userCalendar.get(u'defaultReminders', []):
    printKeyValueList([u'Method', reminder[u'method'], u'Minutes', reminder[u'minutes']])
  Indent.Decrement()
  printKeyValueList([u'Notifications', None])
  Indent.Increment()
  if u'notificationSettings' in userCalendar:
    for notification in userCalendar[u'notificationSettings'].get(u'notifications', []):
      printKeyValueList([u'Method', notification[u'method'], u'Type', notification[u'type']])
  Indent.Decrement()
  if acls:
    printKeyValueList([u'ACLs', None])
    Indent.Increment()
    for rule in acls:
      printKeyValueList(ACLRoleKeyValueList(rule))
    Indent.Decrement()
  Indent.Decrement()

# Process CalendarList functions
def _processCalendarList(user, calId, j, jcount, cal, function, **kwargs):
  try:
    result = callGAPI(cal.calendarList(), function,
                      throw_reasons=[GAPI_NOT_FOUND, GAPI_DUPLICATE, GAPI_CANNOT_CHANGE_OWN_ACL],
                      **kwargs)
    if function == u'get':
      _showCalendar(result, j, jcount)
    else:
      entityActionPerformed([Entity.USER, user, Entity.CALENDAR, calId], j, jcount)
  except (GAPI_notFound, GAPI_duplicate, GAPI_cannotChangeOwnAcl) as e:
    entityActionFailedWarning([Entity.USER, user, Entity.CALENDAR, calId], e.message, j, jcount)

# gam <UserTypeEntity> add calendars <CalendarAddEntity> <CalendarAttributes>
def addCalendars(users):
  calendarEntity = getCalendarEntity()
  body = {u'selected': True, u'hidden': False}
  colorRgbFormat = _getCalendarAttributes(body)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity)
    if jcount == 0:
      continue
    Indent.Increment()
    j = 0
    for calId in calIds:
      j += 1
      body[u'id'] = calId = normalizeCalendarId(calId, user)
      _processCalendarList(user, calId, j, jcount, cal, u'insert',
                           body=body, colorRgbFormat=colorRgbFormat, fields=u'')
    Indent.Decrement()

def _updateDeleteCalendars(users, calendarEntity, function, **kwargs):
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity)
    if jcount == 0:
      continue
    Indent.Increment()
    j = 0
    for calId in calIds:
      j += 1
      calId = normalizeCalendarId(calId, user)
      _processCalendarList(user, calId, j, jcount, cal, function,
                           calendarId=calId, **kwargs)
    Indent.Decrement()

# gam <UserTypeEntity> update calendars <CalendarEntity> <CalendarAttributes>
def updateCalendars(users):
  calendarEntity = getCalendarEntity()
  body = {}
  colorRgbFormat = _getCalendarAttributes(body)
  _updateDeleteCalendars(users, calendarEntity, u'update', body=body, colorRgbFormat=colorRgbFormat, fields=u'')

# gam <UserTypeEntity> delete calendars <CalendarEntity>
def deleteCalendars(users):
  calendarEntity = getCalendarEntity()
  checkForExtraneousArguments()
  _updateDeleteCalendars(users, calendarEntity, u'delete')

# gam <UserTypeEntity> info calendars <CalendarEntity>
def infoCalendars(users):
  calendarEntity = getCalendarEntity()
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity)
    if jcount == 0:
      continue
    Indent.Increment()
    j = 0
    for calId in calIds:
      j += 1
      calId = normalizeCalendarId(calId, user)
      _processCalendarList(user, calId, j, jcount, cal, u'get',
                           calendarId=calId)
    Indent.Decrement()

# <CalendarSettings> ::==
#	[description <String>] [location <String>] [summary <String>] [timezone <String>]
def _getCalendarSettings(summaryRequired=False):
  body = {}
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'description':
      body[u'description'] = getString(OB_STRING, minLen=0).replace(u'\\n', u'\n')
    elif myarg == u'location':
      body[u'location'] = getString(OB_STRING, minLen=0)
    elif myarg == u'summary':
      body[u'summary'] = getString(OB_STRING)
    elif myarg == u'timezone':
      body[u'timeZone'] = getString(OB_STRING)
    else:
      unknownArgumentExit()
  if summaryRequired and not body.get(u'summary', None):
    missingArgumentExit(u'summary <String>')
  return body

# gam <UserTypeEntity> create calendars <CalendarSettings>
def createCalendar(users):
  calendarEntity = initCalendarEntity()
  body = _getCalendarSettings(summaryRequired=True)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cal, _, _ = _validateUserGetCalendarIds(user, i, count, calendarEntity, showAction=False, setRC=False)
    if not cal:
      continue
    try:
      calId = callGAPI(cal.calendars(), u'insert',
                       throw_reasons=GAPI_CALENDAR_THROW_REASONS+[GAPI_FORBIDDEN],
                       body=body, fields=u'id')[u'id']
      entityActionPerformed([Entity.USER, user, Entity.CALENDAR, calId], i, count)
    except (GAPI_notACalendarUser, GAPI_forbidden) as e:
      entityActionFailedWarning([Entity.USER, user], e.message, i, count)
    except (GAPI_serviceNotAvailable, GAPI_authError):
      entityServiceNotApplicableWarning(Entity.USER, user, i, count)

def _modifyRemoveCalendars(users, calendarEntity, function, **kwargs):
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity)
    if jcount == 0:
      continue
    Indent.Increment()
    j = 0
    for calId in calIds:
      j += 1
      calId = normalizeCalendarId(calId, user)
      try:
        callGAPI(cal.calendars(), function,
                 throw_reasons=GAPI_CALENDAR_THROW_REASONS+[GAPI_NOT_FOUND, GAPI_CANNOT_DELETE_PRIMARY_CALENDAR, GAPI_FORBIDDEN],
                 calendarId=calId, **kwargs)
        entityActionPerformed([Entity.USER, user, Entity.CALENDAR, calId], j, jcount)
      except (GAPI_notFound, GAPI_cannotDeletePrimaryCalendar, GAPI_forbidden) as e:
        entityActionFailedWarning([Entity.USER, user, Entity.CALENDAR, calId], e.message, j, jcount)
      except GAPI_notACalendarUser as e:
        entityActionFailedWarning([Entity.USER, user], e.message, i, count)
        break
      except (GAPI_serviceNotAvailable, GAPI_authError):
        entityServiceNotApplicableWarning(Entity.USER, user, i, count)
        break
    Indent.Decrement()

# gam <UserTypeEntity> modify calendars <CalendarEntity> <CalendarSettings>
def modifyCalendars(users):
  calendarEntity = getCalendarEntity()
  body = _getCalendarSettings(summaryRequired=False)
  _modifyRemoveCalendars(users, calendarEntity, u'patch', body=body)

# gam <UserTypeEntity> remove calendars <CalendarEntity>
def removeCalendars(users):
  calendarEntity = getCalendarEntity()
  checkForExtraneousArguments()
  _modifyRemoveCalendars(users, calendarEntity, u'delete')

def _printShowCalendars(users, csvFormat):

  def _getPermissions(cal, userCalendar):
    if userCalendar[u'accessRole'] == u'owner':
      try:
        return callGAPIpages(cal.acl(), u'list', u'items',
                             throw_reasons=GAPI_CALENDAR_THROW_REASONS+[GAPI_NOT_FOUND],
                             calendarId=userCalendar[u'id'], fields=u'nextPageToken,items(id,role,scope)')
      except (GAPI_serviceNotAvailable, GAPI_authError, GAPI_notACalendarUser, GAPI_notFound):
        pass
    return collections.deque()

  acls = collections.deque()
  primary = showPermissions = False
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile(None)
  kwargs = {}
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg in [CL_OB_ACLS, CL_OB_CALENDARACLS, CL_OB_PERMISSIONS]:
      showPermissions = True
    elif myarg == u'allcalendars':
      pass
    elif myarg == u'primary':
      primary = True
    elif not _getCalendarSelectProperty(myarg, kwargs):
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cal = validateCalendar(user, i, count)
    if not cal:
      continue
    try:
      calendars = callGAPIpages(cal.calendarList(), u'list', u'items',
                                throw_reasons=GAPI_CALENDAR_THROW_REASONS,
                                **kwargs)
      if primary:
        for calendar in calendars:
          if calendar.get(u'primary', False):
            calendars = collections.deque([calendar])
            break
        else:
          calendars = collections.deque()
      jcount = len(calendars)
      if not csvFormat:
        entityPerformActionNumItems([Entity.USER, user], jcount, Entity.CALENDAR, i, count)
        if jcount == 0:
          continue
        Indent.Increment()
        j = 0
        for calendar in calendars:
          j += 1
          if showPermissions:
            acls = _getPermissions(cal, calendar)
          _showCalendar(calendar, j, jcount, acls)
        Indent.Decrement()
      else:
        for calendar in calendars:
          row = {u'primaryEmail': user, u'calendarId': calendar[u'id']}
          if showPermissions:
            flattenJSON(_getPermissions(cal, calendar), key=u'permissions', flattened=row)
          calendar.pop(u'id', None)
          addRowTitlesToCSVfile(flattenJSON(calendar, flattened=row), csvRows, titles)
    except GAPI_notACalendarUser as e:
      entityActionFailedWarning([Entity.USER, user], e.message, i, count)
    except (GAPI_serviceNotAvailable, GAPI_authError):
      entityServiceNotApplicableWarning(Entity.USER, user, i, count)
  if csvFormat:
    sortCSVTitles([u'primaryEmail', u'calendarId'], titles)
    writeCSVfile(csvRows, titles, u'Calendars', todrive)

# gam <UserTypeEntity> print calendars [allcalendars] [primary] <CalendarSelectProperties>* [todrive [<ToDriveAttributes>]] [permissions]
def printCalendars(users):
  _printShowCalendars(users, True)

# gam <UserTypeEntity> show calendars [allcalendars] [primary] <CalendarSelectProperties>* [permissions]
def showCalendars(users):
  _printShowCalendars(users, False)

# gam <UserTypeEntity> show calsettings
def showCalSettings(users):
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cal = validateCalendar(user, i, count)
    if not cal:
      continue
    try:
      feed = callGAPIpages(cal.settings(), u'list', u'items',
                           throw_reasons=GAPI_CALENDAR_THROW_REASONS)
      jcount = len(feed)
      printEntityKVList([Entity.USER, user], [Entity.Plural(Entity.CALENDAR_SETTINGS), None], i, count)
      if jcount > 0:
        Indent.Increment()
        settings = {}
        for setting in feed:
          settings[setting[u'id']] = setting[u'value']
        for attr, value in sorted(settings.items()):
          printKeyValueList([attr, value])
        printBlankLine()
        Indent.Decrement()
    except GAPI_notACalendarUser as e:
      entityActionFailedWarning([Entity.USER, user], e.message, i, count)
    except (GAPI_serviceNotAvailable, GAPI_authError):
      entityServiceNotApplicableWarning(Entity.USER, user, i, count)

# gam <UserTypeEntity> add calendaracls <CalendarEntity> <CalendarACLRole> <ACLScopeEntity>
def addCalendarACLs(users):
  calendarEntity = getCalendarEntity()
  role = getChoice(CALENDAR_ACL_ROLES_MAP, mapChoice=True)
  ACLScopeEntity = getCalendarSiteACLScopeEntity()
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity, Entity.CALENDAR_ACL, Action.MODIFIER_TO)
    if jcount == 0:
      continue
    Indent.Increment()
    _doCalendarsAddACLs(origUser, user, cal, calIds, jcount, role, ACLScopeEntity)
    Indent.Decrement()

def updateDeleteCalendarACLs(users, calendarEntity, function, modifier, role, body):
  ACLScopeEntity = getCalendarSiteACLScopeEntity()
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity, Entity.CALENDAR_ACL, modifier)
    if jcount == 0:
      continue
    Indent.Increment()
    _doUpdateDeleteCalendarACLs(origUser, user, cal, function, calIds, jcount, ACLScopeEntity, role, body)
    Indent.Decrement()

# gam <UserTypeEntity> update calendaracls <CalendarEntity> <CalendarACLRole> <ACLScopeEntity>
def updateCalendarACLs(users):
  calendarEntity = getCalendarEntity()
  role = getChoice(CALENDAR_ACL_ROLES_MAP, mapChoice=True)
  body = {u'role': role}
  updateDeleteCalendarACLs(users, calendarEntity, u'patch', Action.MODIFIER_IN, role, body)

# gam <UserTypeEntity> delete calendaracls <CalendarEntity> [<CalendarACLRole>] <ACLScopeEntity>
def deleteCalendarACLs(users):
  calendarEntity = getCalendarEntity()
  role = getChoice(CALENDAR_ACL_ROLES_MAP, defaultChoice=None, mapChoice=True)
  body = {}
  updateDeleteCalendarACLs(users, calendarEntity, u'delete', Action.MODIFIER_FROM, role, body)

# gam <UserTypeEntity> info calendaracls <CalendarEntity> <ACLScopeEntity>
def infoCalendarACLs(users):
  calendarEntity = getCalendarEntity()
  ACLScopeEntity = getCalendarSiteACLScopeEntity()
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity, Entity.CALENDAR_ACL, Action.MODIFIER_FROM)
    if jcount == 0:
      continue
    Indent.Increment()
    _doInfoCalendarACLs(origUser, user, cal, calIds, jcount, ACLScopeEntity)
    Indent.Decrement()

def printShowCalendarACLs(users, csvFormat):
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile(None)
  else:
    titles = csvRows = None
  calendarEntity = getCalendarEntity(default=u'all')
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity, Entity.CALENDAR_ACL, Action.MODIFIER_FROM, showAction=not csvFormat)
    if jcount == 0:
      continue
    Indent.Increment()
    _doPrintShowCalendarACLs(user, cal, calIds, jcount, csvFormat, csvRows, titles)
    Indent.Decrement()
  if csvFormat:
    sortCSVTitles([u'primaryEmail', u'calendarId'], titles)
    writeCSVfile(csvRows, titles, u'Calendar ACLs', todrive)

# gam <UserTypeEntity> print calendaracls <CalendarEntity> [todrive [<ToDriveAttributes>]]
def printCalendarACLs(users):
  printShowCalendarACLs(users, True)

# gam <UserTypeEntity> show calendaracls <CalendarEntity>
def showCalendarACLs(users):
  printShowCalendarACLs(users, False)

# gam <UserTypeEntity> transfer calendars <UserItem> <CalendarEntity> [keepuser] [retainrole <CalendarACLRole>]
def transferCalendars(users):
  targetUser = getEmailAddress()
  calendarEntity = getCalendarEntity(noSelectionKwargs={u'minAccessRole': u'owner', u'showHidden': True})
  giveForbiddenWarnings = not calendarEntity[u'all']
  retainSourceRoleBody = {}
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'keepuser':
      retainSourceRoleBody = {u'role': u'owner'}
    elif myarg == u'retainrole':
      retainSourceRoleBody[u'role'] = getChoice(CALENDAR_ACL_ROLES_MAP, mapChoice=True)
    else:
      unknownArgumentExit()
  targetUser, targetCal = validateCalendar(targetUser)
  if not targetCal:
    return
  targetRoleBody = {u'role': u'owner', u'scope': {u'type': u'user', u'value': targetUser}}
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    Action.Set(Action.TRANSFER_OWNERSHIP)
    user, sourceCal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity)
    if jcount == 0:
      continue
    sourceRuleId = u'{0}:{1}'.format(u'user', user)
    Indent.Increment()
    j = 0
    for calId in calIds:
      j += 1
      Action.Set(Action.TRANSFER_OWNERSHIP)
      if calId.find(u'@group.calendar.google.com') == -1:
        entityActionNotPerformedWarning([Entity.CALENDAR, calId], [None, PHRASE_FORBIDDEN][giveForbiddenWarnings], j, jcount)
        continue
      try:
        callGAPI(sourceCal.acl(), u'insert',
                 throw_reasons=[GAPI_NOT_FOUND, GAPI_INVALID, GAPI_FORBIDDEN],
                 calendarId=calId, body=targetRoleBody, fields=u'')
        entityModifierNewValueItemValueActionPerformed([Entity.CALENDAR, calId], Action.MODIFIER_TO, None, Entity.USER, targetUser, j, jcount)
      except GAPI_forbidden as e:
        entityActionFailedWarning([Entity.CALENDAR, calId], e.message, j, jcount)
        continue
      except (GAPI_notFound, GAPI_invalid):
        entityUnknownWarning(Entity.CALENDAR, calId, j, jcount)
        continue
      if retainSourceRoleBody:
        Action.Set(Action.RETAIN)
        try:
          callGAPI(targetCal.acl(), u'patch',
                   throw_reasons=[GAPI_NOT_FOUND, GAPI_INVALID, GAPI_INVALID_PARAMETER, GAPI_INVALID_SCOPE_VALUE, GAPI_ILLEGAL_ACCESS_ROLE_FOR_DEFAULT, GAPI_CANNOT_CHANGE_OWN_ACL, GAPI_CANNOT_CHANGE_OWNER_ACL, GAPI_FORBIDDEN],
                   calendarId=calId, ruleId=sourceRuleId, body=retainSourceRoleBody, fields=u'')
          entityActionPerformed([Entity.CALENDAR, calId, Entity.CALENDAR_ACL, formatACLScopeRole(sourceRuleId, retainSourceRoleBody[u'role'])], j, jcount)
        except GAPI_notFound as e:
          if not checkCalendarExists(targetCal, calId):
            entityUnknownWarning(Entity.CALENDAR, calId, j, jcount)
          else:
            entityActionFailedWarning([Entity.CALENDAR, calId, Entity.CALENDAR_ACL, formatACLScopeRole(sourceRuleId, retainSourceRoleBody[u'role'])], e.message, j, jcount)
        except (GAPI_invalid, GAPI_invalidParameter, GAPI_invalidScopeValue, GAPI_illegalAccessRoleForDefault, GAPI_forbidden, GAPI_cannotChangeOwnAcl, GAPI_cannotChangeOwnerAcl) as e:
          entityActionFailedWarning([Entity.CALENDAR, calId, Entity.CALENDAR_ACL, formatACLScopeRole(sourceRuleId, retainSourceRoleBody[u'role'])], e.message, j, jcount)
      else:
        Action.Set(Action.DELETE)
        try:
          callGAPI(targetCal.acl(), u'delete',
                   throw_reasons=[GAPI_NOT_FOUND, GAPI_INVALID],
                   calendarId=calId, ruleId=sourceRuleId)
          entityActionPerformed([Entity.CALENDAR, calId, Entity.CALENDAR_ACL, formatACLScopeRole(sourceRuleId, None)], j, jcount)
        except (GAPI_notFound, GAPI_invalid):
          entityUnknownWarning(Entity.CALENDAR, calId, j, jcount)
    Indent.Decrement()

# gam <UserTypeEntity> add event <CalendarEntity> [id <String>] <EventAddAttributes>+
def addCalendarEvent(users):
  calendarEntity = getCalendarEntity()
  body = {}
  parameters = {u'sendNotifications': None}
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if not _getCalendarEventAttribute(myarg, body, parameters, False):
      unknownArgumentExit()
  eventRecurrenceTimeZoneRequired = _checkIfEventRecurrenceTimeZoneRequired(body, parameters)
  sendNotifications = parameters[u'sendNotifications']
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity, Entity.EVENT, Action.MODIFIER_TO)
    if jcount == 0:
      continue
    Indent.Increment()
    status = _addCalendarEvents(user, cal, calIds, jcount,
                                eventRecurrenceTimeZoneRequired, sendNotifications, body)
    Indent.Decrement()
    if not status:
      return

# gam <UserTypeEntity> update events <CalendarEntity> <EventEntity> <EventUpdateAttributes>+
def updateCalendarEvents(users):
  calendarEntity = getCalendarEntity()
  calendarEventEntity = getCalendarEventEntity()
  body = {}
  parameters = {u'sendNotifications': None}
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if _getCalendarEventAttribute(myarg, body, parameters, True):
      pass
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity, Entity.EVENT, Action.MODIFIER_IN)
    if jcount == 0:
      continue
    Indent.Increment()
    status = _updateDeleteCalendarEvents(origUser, user, cal, calIds, jcount, u'patch', calendarEventEntity, True,
                                         _checkIfEventRecurrenceTimeZoneRequired(body, parameters), body,
                                         {u'body': body, u'sendNotifications': parameters[u'sendNotifications'], u'fields': u''})
    Indent.Decrement()
    if not status:
      return

# gam <UserTypeEntity> delete events <CalendarEntity> <EventEntity> [doit] [notifyattendees]
def deleteCalendarEvents(users):
  calendarEntity = getCalendarEntity()
  calendarEventEntity = getCalendarEventEntity()
  doIt = sendNotifications = False
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'notifyattendees':
      sendNotifications = True
    elif myarg == u'doit':
      doIt = True
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity, Entity.EVENT, Action.MODIFIER_FROM)
    if jcount == 0:
      continue
    Indent.Increment()
    _updateDeleteCalendarEvents(origUser, user, cal, calIds, jcount, u'delete', calendarEventEntity, doIt,
                                False, {}, {u'sendNotifications': sendNotifications})
    Indent.Decrement()

# gam <UserTypeEntity> wipe events <CalendarEntity>
def wipeCalendarEvents(users):
  calendarEntity = getCalendarEntity()
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity, Entity.EVENT, Action.MODIFIER_FROM)
    if jcount == 0:
      continue
    Indent.Increment()
    _wipeCalendarEvents(user, cal, calIds, jcount)
    Indent.Decrement()

# gam <UserTypeEntity> move events <CalendarEntity> <EventEntity> to <CalendarItem> [notifyattendees]
def moveCalendarEvents(users):
  calendarEntity = getCalendarEntity()
  calendarEventEntity = getCalendarEventEntity()
  checkArgumentPresent(TO_ARGUMENT)
  newCalId = convertUserUIDtoEmailAddress(getString(OB_CALENDAR_ITEM))
  sendNotifications = False
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'notifyattendees':
      sendNotifications = True
    else:
      unknownArgumentExit()
  if not checkCalendarExists(None, newCalId, True):
    return
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity, Entity.EVENT, Action.MODIFIER_FROM, newCalId=newCalId)
    if jcount == 0:
      continue
    Indent.Increment()
    _moveCalendarEvents(origUser, user, cal, calIds, jcount, calendarEventEntity, newCalId, sendNotifications)
    Indent.Decrement()

# gam <UserTypeEntity> update calattendees <CalendarEntity> <EventEntity> [anyorganizer] [csv <FileName>] (replace <EmailAddress> <EmailAddress>)* [doit]
def updateCalendarAttendees(users):
  calendarEntity = getCalendarEntity()
  calendarEventEntity = getCalendarEventEntity()
  csv_file = None
  anyOrganizer = doIt = False
  attendee_map = {}
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'csv':
      csv_file = getString(OB_FILE_NAME)
    elif myarg == u'replace':
      origAttendee = getEmailAddress(noUid=True)
      attendee_map[origAttendee] = getEmailAddress(noUid=True)
    elif myarg == u'doit':
      doIt = True
    elif myarg == u'anyorganizer':
      anyOrganizer = True
    else:
      unknownArgumentExit()
  if not attendee_map:
    missingChoiceExit([u'csv <FileName>', u'replace <EmailAddress> <EmailAddress>'])
  if csv_file:
    f = openFile(csv_file)
    csvFile = csv.reader(f)
    for row in csvFile:
      if len(row) >= 2:
        attendee_map[row[0].lower()] = row[1].lower()
    closeFile(f)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity)
    if jcount == 0:
      continue
    Indent.Increment()
    j = 0
    for calId in calIds:
      j += 1
      Action.Set(Action.UPDATE)
      calId, cal, events, kcount = _validateCalendarGetEvents(user, cal, calId, j, jcount, calendarEventEntity, True)
      if kcount == 0:
        continue
      Indent.Increment()
      k = 0
      for event in events:
        k += 1
        Action.Set(Action.REPLACE)
        if event[u'status'] == u'cancelled':
          continue
        event_summary = convertUTF8(event.get(u'summary', event[u'id']))
        if not anyOrganizer and not event.get(u'organizer', {}).get(u'self'):
          continue
        needs_update = False
        for attendee in event.get(u'attendees', []):
          if u'email' in attendee:
            old_email = attendee[u'email'].lower()
            new_email = attendee_map.get(old_email)
            if new_email:
              entityModifierNewValueActionPerformed([Entity.EVENT, event_summary, Entity.ATTENDEE, old_email], Action.MODIFIER_WITH, new_email, k, kcount)
              event[u'attendees'].remove(attendee)
              event[u'attendees'].append({u'email': new_email})
              needs_update = True
        if needs_update:
          Action.Set(Action.UPDATE)
          if doIt:
            try:
              callGAPI(cal.events(), u'patch',
                       throw_reasons=GAPI_CALENDAR_THROW_REASONS+[GAPI_NOT_FOUND, GAPI_FORBIDDEN],
                       calendarId=calId, eventId=event[u'id'], sendNotifications=False, body={u'attendees': event[u'attendees']}, fields=u'')
              entityActionPerformed([Entity.EVENT, event_summary], j, jcount)
            except GAPI_notFound as e:
              if not checkCalendarExists(cal, calId):
                entityUnknownWarning(Entity.CALENDAR, calId, j, jcount)
                break
              else:
                entityActionFailedWarning([Entity.CALENDAR, calId, Entity.EVENT, event_summary], e.message, k, kcount)
            except (GAPI_notACalendarUser, GAPI_forbidden) as e:
              entityActionFailedWarning([Entity.CALENDAR, calId], e.message, j, jcount)
              break
            except (GAPI_serviceNotAvailable, GAPI_authError):
              entityServiceNotApplicableWarning(Entity.CALENDAR, calId, j, jcount)
              break
          else:
            entityActionNotPerformedWarning([Entity.EVENT, event_summary], PHRASE_USE_DOIT_ARGUMENT_TO_PERFORM_ACTION, j, jcount)
      Indent.Decrement()
    Indent.Decrement()

# gam <UserTypeEntity> info events <CalendarEntity> <EventEntity>
def infoCalendarEvents(users):
  calendarEntity = getCalendarEntity()
  calendarEventEntity = getCalendarEventEntity()
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity, Entity.EVENT, Action.MODIFIER_IN)
    if jcount == 0:
      continue
    Indent.Increment()
    _infoCalendarEvents(origUser, user, cal, calIds, jcount, calendarEventEntity)
    Indent.Decrement()

def printShowCalendarEvents(users, csvFormat):
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile([u'primaryEmail', u'calendarId']+EVENT_PRINT_ORDER)
  else:
    titles = csvRows = None
  calendarEntity = getCalendarEntity()
  calendarEventEntity = getCalendarEventEntity(noIds=True)
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif _getCalendarListEventsDisplayProperty(myarg, calendarEventEntity):
      pass
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity, Entity.EVENT, Action.MODIFIER_FROM, showAction=not csvFormat)
    if jcount == 0:
      continue
    Indent.Increment()
    _printShowCalendarEvents(user, cal, calIds, jcount, calendarEventEntity, csvFormat, csvRows, titles)
    Indent.Decrement()
  if csvFormat:
    sortCSVTitles([u'primaryEmail', u'calendarId']+EVENT_PRINT_ORDER, titles)
    writeCSVfile(csvRows, titles, u'Calendar Events', todrive)

# gam <UserTypeEntity> print events <CalendarPrintShowEntity> ([allevents] <EventSelectProperties>*) [todrive [<ToDriveAttributes>]] <EventDisplayProperties>*
def printCalendarEvents(users):
  printShowCalendarEvents(users, True)

# gam <UserTypeEntity> show events <CalendarPrintShowEntity> ([allevents] <EventSelectProperties>*) <EventDisplayProperties>*
def showCalendarEvents(users):
  printShowCalendarEvents(users, False)

def doDriveSearch(drive, user, i, count, query=None):
  if GC_Values[GC_SHOW_GETTINGS]:
    printGettingAllEntityItemsForWhom(Entity.DRIVE_FILE_OR_FOLDER, user, i, count, qualifier=queryQualifier(query))
  page_message = getPageMessageForWhom(noNL=True)
  try:
    files = callGAPIpages(drive.files(), u'list', DRIVE_FILES_LIST,
                          page_message=page_message,
                          throw_reasons=GAPI_DRIVE_THROW_REASONS+[GAPI_INVALID_QUERY, GAPI_FILE_NOT_FOUND],
                          q=query, fields=u'nextPageToken,{0}(id)'.format(DRIVE_FILES_LIST), maxResults=GC_Values[GC_DRIVE_MAX_RESULTS])
    return [f_file[u'id'] for f_file in files]
  except GAPI_invalidQuery:
    entityActionFailedWarning([Entity.USER, user, Entity.DRIVE_FILE, PHRASE_LIST], invalidQuery(query), i, count)
  except GAPI_fileNotFound:
    printGettingEntityItemsForWhomDoneInfo(0)
  except (GAPI_serviceNotAvailable, GAPI_authError):
    entityServiceNotApplicableWarning(Entity.USER, user, i, count)
  return None

def cleanFileIDsList(fileIdEntity, fileIds):
  fileIdEntity[u'list'] = []
  fileIdEntity[u'root'] = []
  i = 0
  for fileId in fileIds:
    if fileId[:8].lower() == u'https://' or fileId[:7].lower() == u'http://':
      loc = fileId.find(u'/d/')
      if loc > 0:
        fileId = fileId[loc+3:]
        loc = fileId.find(u'/')
        if loc != -1:
          fileId = fileId[:loc]
      else:
        loc = fileId.find(u'/folderview?id=')
        if loc > 0:
          fileId = fileId[loc+15:]
          loc = fileId.find(u'&')
          if loc != -1:
            fileId = fileId[:loc]
        else:
          continue
    elif fileId.lower() == u'root':
      fileIdEntity[u'root'].append(i)
      fileId = fileId.lower()
    fileIdEntity[u'list'].append(fileId)
    i += 1

def initDriveFileEntity():
  return {u'list': [], u'query': None, u'dict': None, u'root': []}

def getDriveFileEntity(orphansOK=False):
  fileIdEntity = initDriveFileEntity()
  entitySelector = getEntitySelector()
  if entitySelector:
    entityList = getEntitySelection(entitySelector, False)
    if isinstance(entityList, dict):
      fileIdEntity[u'dict'] = entityList
    else:
      cleanFileIDsList(fileIdEntity, entityList)
  else:
    myarg = getString(OB_DRIVE_FILE_ID, checkBlank=True)
    mycmd = myarg.lower()
    if mycmd == u'id':
      cleanFileIDsList(fileIdEntity, getStringReturnInList(OB_DRIVE_FILE_ID))
    elif mycmd[:3] == u'id:':
      cleanFileIDsList(fileIdEntity, [myarg[3:]])
    elif mycmd == u'ids':
      cleanFileIDsList(fileIdEntity, getString(OB_DRIVE_FILE_ID).replace(u',', u' ').split())
    elif mycmd[:4] == u'ids:':
      cleanFileIDsList(fileIdEntity, myarg[4:].replace(u',', u' ').split())
    elif mycmd == u'query':
      fileIdEntity[u'query'] = getString(OB_QUERY)
    elif mycmd[:6] == u'query:':
      fileIdEntity[u'query'] = myarg[6:]
    elif mycmd == u'drivefilename':
      fileIdEntity[u'query'] = ME_IN_OWNERS_AND+u"{0} = '{1}'".format(DRIVE_FILE_NAME, getString(OB_DRIVE_FILE_NAME))
    elif mycmd[:14] == u'drivefilename:':
      fileIdEntity[u'query'] = ME_IN_OWNERS_AND+u"{0} = '{1}'".format(DRIVE_FILE_NAME, myarg[14:])
    elif mycmd == u'anydrivefilename':
      fileIdEntity[u'query'] = u"{0} = '{1}'".format(DRIVE_FILE_NAME, getString(OB_DRIVE_FILE_NAME))
    elif mycmd[:17] == u'anydrivefilename:':
      fileIdEntity[u'query'] = u"{0} = '{1}'".format(DRIVE_FILE_NAME, myarg[17:])
    elif mycmd == u'root':
      cleanFileIDsList(fileIdEntity, [mycmd,])
    elif orphansOK and mycmd == u'orphans':
      cleanFileIDsList(fileIdEntity, [mycmd,])
    else:
      cleanFileIDsList(fileIdEntity, [myarg,])
  return fileIdEntity

def _validateUserGetFileIDs(user, i, count, fileIdEntity, body, parameters, drive=None, entityType=None):
  if fileIdEntity[u'dict']:
    cleanFileIDsList(fileIdEntity, fileIdEntity[u'dict'][user])
  if not drive:
    user, drive = buildGAPIServiceObject(DRIVE_API, user)
    if not drive:
      return (user, None, 0)
  else:
    user = convertUserUIDtoEmailAddress(user)
  if parameters[DFA_PARENTQUERY]:
    more_parents = doDriveSearch(drive, user, i, count, query=parameters[DFA_PARENTQUERY])
    if more_parents is None:
      setSysExitRC(NO_ENTITIES_FOUND)
      return (user, None, 0)
    body.setdefault(u'parents', [])
    for a_parent in more_parents:
      body[u'parents'].append({u'id': a_parent})
  if fileIdEntity[u'query']:
    fileIdEntity[u'list'] = doDriveSearch(drive, user, i, count, query=fileIdEntity[u'query'])
    if fileIdEntity[u'list'] is None:
      setSysExitRC(NO_ENTITIES_FOUND)
      return (user, None, 0)
  elif fileIdEntity[u'root']:
    try:
      rootFolderId = callGAPI(drive.files(), u'get',
                              throw_reasons=GAPI_DRIVE_THROW_REASONS,
                              fileId=u'root', fields=u'id')[u'id']
    except (GAPI_serviceNotAvailable, GAPI_authError):
      entityServiceNotApplicableWarning(Entity.USER, user, i, count)
      return (user, None, 0)
    for j in fileIdEntity[u'root']:
      fileIdEntity[u'list'][j] = rootFolderId
  l = len(fileIdEntity[u'list'])
  if l == 0:
    setSysExitRC(NO_ENTITIES_FOUND)
  if entityType:
    entityPerformActionNumItems([Entity.USER, user], l, entityType, i, count)
  return (user, drive, l)

DRIVEFILE_LABEL_CHOICES_MAP = {
  u'restricted': DRIVE_FILE_LABEL_RESTRICTED,
  u'restrict': DRIVE_FILE_LABEL_RESTRICTED,
  u'starred': u'starred',
  u'star': u'starred',
  u'trashed': u'trashed',
  u'trash': u'trashed',
  u'viewed': DRIVE_FILE_LABEL_VIEWED,
  u'view': DRIVE_FILE_LABEL_VIEWED,
  }

MODIFIED_DATE_BEHAVIOR_CHOICES_MAP = {
  u'frombody': u'fromBody',
  u'frombodyifneeded': u'fromBodyIfNeeded',
  u'frombodyornow': u'fromBodyOrNow',
  u'nochange': u'noChange',
  u'now': u'now',
  u'nowifneeded': u'nowIfNeeded',
  }

MIMETYPE_CHOICES_MAP = {
  u'gdoc': MIMETYPE_GA_DOCUMENT,
  u'gdocument': MIMETYPE_GA_DOCUMENT,
  u'gdrawing': MIMETYPE_GA_DRAWING,
  u'gfolder': MIMETYPE_GA_FOLDER,
  u'gdirectory': MIMETYPE_GA_FOLDER,
  u'gform': MIMETYPE_GA_FORM,
  u'gfusion': MIMETYPE_GA_FUSIONTABLE,
  u'gpresentation': MIMETYPE_GA_PRESENTATION,
  u'gscript': MIMETYPE_GA_SCRIPT,
  u'gsite': MIMETYPE_GA_SITES,
  u'gsheet': MIMETYPE_GA_SPREADSHEET,
  u'gspreadsheet': MIMETYPE_GA_SPREADSHEET,
  }

def initializeDriveFileAttributes():
  return ({}, {DFA_LOCALFILEPATH: None, DFA_LOCALFILENAME: None, DFA_LOCALMIMETYPE: None,
               DFA_CONVERT: None, DFA_OCR: None, DFA_OCRLANGUAGE: None,
               DFA_PARENTQUERY: None, DFA_ADD_PARENTS: [], DFA_REMOVE_PARENTS: [],
               DFA_IGNORE_DEFAULT_VISIBILITY: u'DEFAULT', DFA_KEEP_REVISION_FOREVER: False, DFA_USE_CONTENT_AS_INDEXABLE_TEXT: False})

def getDriveFileAttribute(body, parameters, myarg, updateCmd, kwargs):
  if myarg == u'localfile':
    parameters[DFA_LOCALFILEPATH] = getString(OB_FILE_NAME)
    try:
      f = open(os.path.expanduser(parameters[DFA_LOCALFILEPATH]), u'rb')
      f.close()
    except IOError as e:
      CLArgs.Backup()
      usageErrorExit(u'{0}: {1}'.format(parameters[DFA_LOCALFILEPATH], e.strerror))
    parameters[DFA_LOCALFILENAME] = os.path.basename(parameters[DFA_LOCALFILEPATH])
    body.setdefault(DRIVE_FILE_NAME, parameters[DFA_LOCALFILENAME])
    body[u'mimeType'] = mimetypes.guess_type(parameters[DFA_LOCALFILEPATH])[0]
    if body[u'mimeType'] is None:
      body[u'mimeType'] = u'application/octet-stream'
    parameters[DFA_LOCALMIMETYPE] = body[u'mimeType']
  elif myarg == u'convert':
    parameters[DFA_CONVERT] = True
  elif myarg == u'ocr':
    parameters[DFA_OCR] = True
  elif myarg == u'ocrlanguage':
    parameters[DFA_OCRLANGUAGE] = getChoice(LANGUAGE_CODES_MAP, mapChoice=True)
  elif myarg in DRIVEFILE_LABEL_CHOICES_MAP:
    body.setdefault(u'labels', {})
    body[u'labels'][DRIVEFILE_LABEL_CHOICES_MAP[myarg]] = getBoolean(True)
  elif myarg in [u'lastviewedbyme', u'lastviewedbyuser', u'lastviewedbymedate', u'lastviewedbymetime']:
    body[DRIVE_FILE_LAST_VIEWED_BY_ME_DATE_TIME] = getFullTime()
  elif updateCmd and myarg == u'modifieddatebehavior':
    kwargs[u'modifiedDateBehavior'] = getChoice(MODIFIED_DATE_BEHAVIOR_CHOICES_MAP, mapChoice=True)
  elif updateCmd and myarg in [u'modifieddate', u'modifiedtime']:
    body[DRIVE_FILE_MODIFIED_DATE_TIME] = getFullTime()
    kwargs[u'setModifiedDate'] = True
  elif myarg == u'description':
    body[u'description'] = getString(OB_STRING, minLen=0)
  elif myarg == u'mimetype':
    body[u'mimeType'] = getChoice(MIMETYPE_CHOICES_MAP, mapChoice=True)
  elif myarg == u'parentid':
    body.setdefault(u'parents', [])
    body[u'parents'].append({u'id': getString(OB_DRIVE_FOLDER_ID)})
  elif myarg == u'parentname':
    parameters[DFA_PARENTQUERY] = ME_IN_OWNERS_AND+u"mimeType = '{0}' and {1} = '{2}'".format(MIMETYPE_GA_FOLDER, DRIVE_FILE_NAME, getString(OB_DRIVE_FOLDER_NAME))
  elif myarg == u'addparents':
    parameters[DFA_ADD_PARENTS].extend(getString(OB_DRIVE_FOLDER_ID_LIST).replace(u',', u' ').split())
  elif myarg == u'removeparents':
    parameters[DFA_REMOVE_PARENTS].extend(getString(OB_DRIVE_FOLDER_ID_LIST).replace(u',', u' ').split())
  elif myarg == u'writerscantshare':
    body[u'writersCanShare'] = False
  elif myarg == u'viewerscancopycontent':
    body[u'labels'][DRIVE_FILE_LABEL_RESTRICTED] = not getBoolean(False)
  elif myarg == u'ignoredefaultvisibility':
    parameters[DFA_IGNORE_DEFAULT_VISIBILITY] = [u'DEFAULT', u'PRIVATE'][getBoolean(True)]
  elif myarg in [u'keeprevisionforever', u'pinned']:
    parameters[DFA_KEEP_REVISION_FOREVER] = getBoolean(True)
  elif myarg == u'usecontentasindexabletext':
    parameters[DFA_USE_CONTENT_AS_INDEXABLE_TEXT] = getBoolean(True)
  elif myarg == u'indexabletext':
    body[u'indexableText'] = getString(OB_STRING)
  else:
    unknownArgumentExit()

# gam <UserTypeEntity> print|show driveactivity [todrive [<ToDriveAttributes>]] [fileid <DriveFileID>] [folderid <DriveFolderID>]
def printDriveActivity(users):
  drive_ancestorId = u'root'
  drive_fileId = None
  todrive = {}
  titles, csvRows = initializeTitlesCSVfile([u'user.name', u'user.permissionId', u'target.id', u'target.name', u'target.mimeType'])
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'fileid':
      drive_fileId = getString(OB_DRIVE_FILE_ID)
      drive_ancestorId = None
    elif myarg == u'folderid':
      drive_ancestorId = getString(OB_DRIVE_FOLDER_ID)
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, activity = buildGAPIServiceObject(APPSACTIVITY_API, user)
    if not activity:
      continue
    try:
      printGettingAllEntityItemsForWhom(Entity.ACTIVITY, user, i, count)
      page_message = getPageMessageForWhom(noNL=True)
      feed = callGAPIpages(activity.activities(), u'list', u'activities',
                           page_message=page_message,
                           throw_reasons=GAPI_ACTIVITY_THROW_REASONS,
                           source=u'drive.google.com', userId=u'me',
                           drive_ancestorId=drive_ancestorId, groupingStrategy=u'none',
                           drive_fileId=drive_fileId, pageSize=GC_Values[GC_ACTIVITY_MAX_RESULTS])
      while feed:
        event = feed.popleft()[u'combinedEvent']
        event[u'eventTime'] = formatLocalTimestamp(event[u'eventTimeMillis'])
        addRowTitlesToCSVfile(flattenJSON(event), csvRows, titles)
    except GAPI_serviceNotAvailable:
      entityServiceNotApplicableWarning(Entity.USER, user, i, count)
  sortCSVTitles([u'user.name', u'user.permissionId', u'target.id', u'target.name', u'target.mimeType'], titles)
  writeCSVfile(csvRows, titles, u'Drive Activity', todrive)

# gam <UserTypeEntity> print|show drivesettings [todrive [<ToDriveAttributes>]]
def printDriveSettings(users):
  todrive = {}
  titles, csvRows = initializeTitlesCSVfile([u'email',])
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'todrive':
      todrive = getTodriveParameters()
    else:
      unknownArgumentExit()
  dont_show = [u'kind', u'etag', u'selfLink', u'additionalRoleInfo', u'exportFormats', u'features',
               u'importFormats', u'isCurrentAppInstalled', u'maxUploadSizes', u'user']
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive = buildGAPIServiceObject(DRIVE_API, user)
    if not drive:
      continue
    printGettingEntityItemForWhom(Entity.DRIVE_SETTINGS, user, i, count)
    try:
      feed = callGAPI(drive.about(), u'get',
                      throw_reasons=GAPI_DRIVE_THROW_REASONS)
      if feed:
        row = {u'email': user}
        for setting in feed:
          if setting in dont_show:
            continue
          if setting == u'quotaBytesByService':
            for subsetting in feed[setting]:
              my_name = subsetting[u'serviceName']
              row[my_name] = formatFileSize(int(subsetting[u'bytesUsed']))
              if my_name not in titles[u'set']:
                addTitleToCSVfile(my_name, titles)
          else:
            row[setting] = feed[setting]
            if setting not in titles[u'set']:
              addTitleToCSVfile(setting, titles)
        csvRows.append(row)
    except (GAPI_serviceNotAvailable, GAPI_authError):
      entityServiceNotApplicableWarning(Entity.USER, user, i, count)
  writeCSVfile(csvRows, titles, u'User Drive Settings', todrive)

def initFilePathInfo():
  return {u'ids': {}, u'allPaths': {}, u'localPaths': None}

def getFilePaths(drive, fileTree, initialResult, filePathInfo):
  def _followParent(paths, parentId):
    paths.setdefault(parentId, {})
    if fileTree:
      parentEntry = fileTree.get(parentId)
      if parentEntry:
        if parentEntry[u'info'][DRIVE_FILE_NAME] == parentEntry[u'info'][u'id']:
          try:
            result = callGAPI(drive.files(), u'get',
                              throw_reasons=GAPI_DRIVE_THROW_REASONS+[GAPI_FILE_NOT_FOUND],
                              fileId=parentId, fields=u'{0},{1}'.format(DRIVE_FILE_NAME, DRIVE_PARENTS_ID))
            parentEntry[u'info'][DRIVE_FILE_NAME] = result[DRIVE_FILE_NAME]
            parentEntry[u'info'][u'parents'] = result.get(u'parents', [])
          except (GAPI_fileNotFound, GAPI_serviceNotAvailable, GAPI_authError):
            pass
        filePathInfo[u'ids'][parentId] = parentEntry[u'info'][DRIVE_FILE_NAME]
        parents = parentEntry[u'info'].get(u'parents', [])
      else:
        return
    else:
      try:
        result = callGAPI(drive.files(), u'get',
                          throw_reasons=GAPI_DRIVE_THROW_REASONS+[GAPI_FILE_NOT_FOUND],
                          fileId=parentId, fields=u'{0},{1}'.format(DRIVE_FILE_NAME, DRIVE_PARENTS_ID))
        filePathInfo[u'ids'][parentId] = result[DRIVE_FILE_NAME]
        parents = result.get(u'parents', [])
      except (GAPI_fileNotFound, GAPI_serviceNotAvailable, GAPI_authError):
        return
    if parents:
      for lparent in parents:
        lparentId = lparent[u'id']
        if lparentId not in filePathInfo[u'allPaths']:
          _followParent(paths[parentId], lparentId)
          filePathInfo[u'allPaths'][lparentId] = paths[parentId][lparentId]
        else:
          paths[parentId][lparentId] = filePathInfo[u'allPaths'][lparentId]

  def _makeFilePaths(localPaths, fplist, filePaths, name):
    for k, v in localPaths.items():
      fplist.append(filePathInfo[u'ids'].get(k, u''))
      if not v:
        fp = fplist[:]
        fp.reverse()
        fp.append(name)
        filePaths.append(os.path.join(*fp))
        fplist.pop()
        return
      _makeFilePaths(v, fplist, filePaths, name)
      fplist.pop()
    return

  filePaths = []
  parents = initialResult.get(u'parents', [])
  if parents:
    filePathInfo[u'localPaths'] = {}
    for parent in parents:
      parentId = parent[u'id']
      if parentId not in filePathInfo[u'allPaths']:
        _followParent(filePathInfo[u'allPaths'], parentId)
      filePathInfo[u'localPaths'][parentId] = filePathInfo[u'allPaths'][parentId]
    fplist = []
    _makeFilePaths(filePathInfo[u'localPaths'], fplist, filePaths, initialResult[DRIVE_FILE_NAME])
  return ([Entity.DRIVE_FOLDER, Entity.DRIVE_FILE][initialResult[u'mimeType'] != MIMETYPE_GA_FOLDER], filePaths)

DRIVEFILE_FIELDS_CHOICES_MAP = {
  u'alternatelink': DRIVE_FILE_VIEW_LINK,
  u'appdatacontents': u'appDataContents',
  u'cancomment': u'canComment',
  u'canreadrevisions': u'canReadRevisions',
  u'copyable': u'copyable',
  u'createddate': DRIVE_FILE_CREATED_DATE_TIME,
  u'createdtime': DRIVE_FILE_CREATED_DATE_TIME,
  u'description': u'description',
  u'editable': u'editable',
  u'explicitlytrashed': u'explicitlyTrashed',
  u'fileextension': u'fileExtension',
  u'filesize': DRIVE_FILE_SIZE,
  u'foldercolorrgb': u'folderColorRgb',
  u'fullfileextension': u'fullFileExtension',
  u'headrevisionid': u'headRevisionId',
  u'iconlink': u'iconLink',
  u'id': u'id',
  u'lastmodifyinguser': u'lastModifyingUser',
  u'lastmodifyingusername': u'lastModifyingUserName',
  u'lastviewedbyme': DRIVE_FILE_LAST_VIEWED_BY_ME_DATE_TIME,
  u'lastviewedbymedate': DRIVE_FILE_LAST_VIEWED_BY_ME_DATE_TIME,
  u'lastviewedbymetime': DRIVE_FILE_LAST_VIEWED_BY_ME_DATE_TIME,
  u'lastviewedbyuser': DRIVE_FILE_LAST_VIEWED_BY_ME_DATE_TIME,
  u'md5': u'md5Checksum',
  u'md5checksum': u'md5Checksum',
  u'md5sum': u'md5Checksum',
  u'mime': u'mimeType',
  u'mimetype': u'mimeType',
  u'modifiedbyme': DRIVE_FILE_MODIFIED_BY_ME_DATE_TIME,
  u'modifiedbymedate': DRIVE_FILE_MODIFIED_BY_ME_DATE_TIME,
  u'modifiedbymetime': DRIVE_FILE_MODIFIED_BY_ME_DATE_TIME,
  u'modifiedbyuser': DRIVE_FILE_MODIFIED_BY_ME_DATE_TIME,
  u'modifieddate': DRIVE_FILE_MODIFIED_DATE_TIME,
  u'modifiedtime': DRIVE_FILE_MODIFIED_DATE_TIME,
  u'name': DRIVE_FILE_NAME,
  u'originalfilename': u'originalFilename',
  u'ownedbyme': u'ownedByMe',
  u'ownernames': u'ownerNames',
  u'owners': u'owners',
  u'parents': u'parents',
  u'permissions': u'permissions',
  u'quotabytesused': u'quotaBytesUsed',
  u'quotaused': u'quotaBytesUsed',
  u'shareable': u'shareable',
  u'shared': u'shared',
  u'sharedwithmedate': DRIVE_FILE_SHARED_WITH_ME_DATE_TIME,
  u'sharedwithmetime': DRIVE_FILE_SHARED_WITH_ME_DATE_TIME,
  u'sharinguser': u'sharingUser',
  u'size': DRIVE_FILE_SIZE,
  u'spaces': u'spaces',
  u'thumbnaillink': u'thumbnailLink',
  u'title': DRIVE_FILE_NAME,
  u'userpermission': u'userPermission',
  u'version': u'version',
  u'viewedbyme': u'labels(viewed)',
  u'viewedbymedate': DRIVE_FILE_LAST_VIEWED_BY_ME_DATE_TIME,
  u'viewedbymetime': DRIVE_FILE_LAST_VIEWED_BY_ME_DATE_TIME,
  u'viewerscancopycontent': u'labels(restricted)',
  u'webcontentlink': u'webContentLink',
  u'webviewlink': DRIVE_FILE_VIEW_LINK,
  u'writerscanshare': u'writersCanShare',
  }

DRIVEFILE_TIME_OBJECTS = [DRIVE_FILE_CREATED_DATE_TIME, DRIVE_FILE_LAST_VIEWED_BY_ME_DATE_TIME, DRIVE_FILE_MARKED_VIEWED_BY_ME_DATE_TIME, DRIVE_FILE_MODIFIED_BY_ME_DATE_TIME, DRIVE_FILE_MODIFIED_DATE_TIME, DRIVE_FILE_SHARED_WITH_ME_DATE_TIME, DRIVE_PERMISSIONS_EXPIRATION_DATE_TIME]

FILEINFO_FIELDS_TITLES = [DRIVE_FILE_NAME, u'mimeType']
FILEPATH_TITLES = [DRIVE_FILE_NAME, u'id', u'mimeType', u'parents']
FILEPATH_FIELDS = [DRIVE_FILE_NAME, u'id', u'mimeType', u'parents(id)']

# gam <UserTypeEntity> show fileinfo <DriveFileEntity> [filepath] [allfields|<DriveFieldName>*|(fields <DriveFieldNameList>)]
def showDriveFileInfo(users):
  def _setSelectionFields():
    skip_objects.extend([field for field in FILEINFO_FIELDS_TITLES if field not in fieldsList])
    fieldsList.extend(FILEINFO_FIELDS_TITLES)
    if filepath:
      skip_objects.extend([field for field in FILEPATH_TITLES if field not in fieldsList])
      fieldsList.extend(FILEPATH_FIELDS)

  filepath = False
  fieldsList = []
  labelsList = []
  skip_objects = []
  fileIdEntity = getDriveFileEntity()
  body, parameters = initializeDriveFileAttributes()
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'filepath':
      filepath = True
    elif myarg == u'allfields':
      fieldsList = []
    elif myarg in DRIVEFILE_FIELDS_CHOICES_MAP:
      fieldsList.append(DRIVEFILE_FIELDS_CHOICES_MAP[myarg])
    elif myarg in DRIVEFILE_LABEL_CHOICES_MAP:
      labelsList.append(DRIVEFILE_LABEL_CHOICES_MAP[myarg])
    elif myarg == u'fields':
      for field in getString(OB_FIELD_NAME_LIST).lower().replace(u',', u' ').split():
        if field in DRIVEFILE_FIELDS_CHOICES_MAP:
          fieldsList.append(DRIVEFILE_FIELDS_CHOICES_MAP[field])
        elif field in DRIVEFILE_LABEL_CHOICES_MAP:
          labelsList.append(DRIVEFILE_LABEL_CHOICES_MAP[field])
        else:
          CLArgs.Backup()
          invalidChoiceExit(DRIVEFILE_FIELDS_CHOICES_MAP.keys()+DRIVEFILE_LABEL_CHOICES_MAP.keys())
    else:
      unknownArgumentExit()
  if fieldsList or labelsList:
    _setSelectionFields()
    fields = u','.join(set(fieldsList))
    if labelsList:
      fields += u',labels({0})'.format(u','.join(set(labelsList)))
  else:
    fields = u'*'
    skip_objects.extend([u'kind', u'etag'])
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, body, parameters, entityType=Entity.DRIVE_FILE_OR_FOLDER)
    if jcount == 0:
      continue
    if filepath:
      filePathInfo = initFilePathInfo()
    Indent.Increment()
    j = 0
    for fileId in fileIdEntity[u'list']:
      j += 1
      try:
        result = callGAPI(drive.files(), u'get',
                          throw_reasons=GAPI_DRIVE_THROW_REASONS+[GAPI_FILE_NOT_FOUND, GAPI_FORBIDDEN, GAPI_INTERNAL_ERROR],
                          fileId=fileId, fields=fields)
        printEntity([[Entity.DRIVE_FOLDER, Entity.DRIVE_FILE][result[u'mimeType'] != MIMETYPE_GA_FOLDER], u'{0} ({1})'.format(result[DRIVE_FILE_NAME], fileId)], j, jcount)
        Indent.Increment()
        if filepath:
          _, paths = getFilePaths(drive, None, result, filePathInfo)
          kcount = len(paths)
          printKeyValueList([u'paths', kcount])
          Indent.Increment()
          for path in paths:
            printKeyValueList([u'path', path])
          Indent.Decrement()
        showJSON(None, result, skip_objects, DRIVEFILE_TIME_OBJECTS)
        Indent.Decrement()
      except (GAPI_fileNotFound, GAPI_forbidden, GAPI_internalError) as e:
        entityActionFailedWarning([Entity.USER, user, Entity.DRIVE_FILE_OR_FOLDER_ID, fileId], e.message, j, jcount)
      except (GAPI_serviceNotAvailable, GAPI_authError):
        entityServiceNotApplicableWarning(Entity.USER, user, i, count)
        break
    Indent.Decrement()

# gam <UserTypeEntity> show filerevisions <DriveFileEntity>
def showDriveFileRevisions(users):
  fileIdEntity = getDriveFileEntity()
  body, parameters = initializeDriveFileAttributes()
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, body, parameters, entityType=Entity.DRIVE_FILE_OR_FOLDER)
    if jcount == 0:
      continue
    Indent.Increment()
    j = 0
    for fileId in fileIdEntity[u'list']:
      j += 1
      try:
        result = callGAPI(drive.revisions(), u'list',
                          throw_reasons=GAPI_DRIVE_THROW_REASONS+[GAPI_FILE_NOT_FOUND, GAPI_FORBIDDEN, GAPI_INTERNAL_ERROR, GAPI_BAD_REQUEST],
                          fileId=fileId, fields=DRIVE_REVISIONS_LIST)
        printEntity([Entity.DRIVE_FILE_ID, fileId], j, jcount)
        Indent.Increment()
        for revision in result[DRIVE_REVISIONS_LIST]:
          printEntity([Entity.REVISION_ID, revision[u'id']])
          Indent.Increment()
          showJSON(None, revision, [u'id',], DRIVEFILE_TIME_OBJECTS)
          Indent.Decrement()
        Indent.Decrement()
      except (GAPI_fileNotFound, GAPI_forbidden, GAPI_internalError, GAPI_badRequest) as e:
        entityActionFailedWarning([Entity.USER, user, Entity.DRIVE_FILE_OR_FOLDER_ID, fileId], e.message, j, jcount)
      except (GAPI_serviceNotAvailable, GAPI_authError):
        entityServiceNotApplicableWarning(Entity.USER, user, i, count)
        break
    Indent.Decrement()

def _stripMeInOwners(query):
  if not query:
    return query
  query = query.replace(ME_IN_OWNERS_AND, u'')
  query = query.replace(AND_ME_IN_OWNERS, u'')
  return query.replace(ME_IN_OWNERS, u'').strip() or None

def _stripNotMeInOwners(query):
  if not query:
    return query
  query = query.replace(NOT_ME_IN_OWNERS_AND, u'')
  query = query.replace(AND_NOT_ME_IN_OWNERS, u'')
  return query.replace(NOT_ME_IN_OWNERS, u'').strip() or None

def _convertReaderToCommenter(permission):
  if permission[u'role'] == u'reader' and permission.get(u'additionalRoles') and permission[u'additionalRoles'][0] == u'commenter':
    permission[u'role'] = permission[u'additionalRoles'].pop(0)
    if not permission[u'additionalRoles']:
      del permission[u'additionalRoles']

def _setRoleConvertCommenterToReader(body, role):
  body[u'role'] = role
  if role == u'commenter':
    body[u'role'] = u'reader'
    body[u'additionalRoles'] = [role]

OWNED_BY_ME_FIELDS_TITLES = [u'ownedByMe',]

def buildFileTree(feed, drive):
  fileTree = {u'orphans': {u'info': {u'id': u'orphans', DRIVE_FILE_NAME: u'orphans', u'mimeType': MIMETYPE_GA_FOLDER, u'ownedByMe': True}, u'children': []}}
  try:
    f_file = callGAPI(drive.files(), u'get',
                      throw_reasons=GAPI_DRIVE_THROW_REASONS,
                      fileId=u'root', fields=u','.join(FILEPATH_FIELDS+OWNED_BY_ME_FIELDS_TITLES))
    fileTree[f_file[u'id']] = {u'info': f_file, u'children': []}
  except (GAPI_serviceNotAvailable, GAPI_authError):
    pass
  for f_file in feed:
    fileId = f_file[u'id']
    if fileId not in fileTree:
      fileTree[fileId] = {u'info': f_file, u'children': []}
    else:
      fileTree[fileId][u'info'] = f_file
    parents = f_file.get(u'parents', [])
    if not parents:
      parents = [{u'id': u'orphans'}]
    for parent in parents:
      parentId = parent[u'id']
      if parentId not in fileTree:
        fileTree[parentId] = {u'info': {u'id': parentId, DRIVE_FILE_NAME: parentId, u'mimeType': MIMETYPE_GA_FOLDER}, u'children': []}
      fileTree[parentId][u'children'].append(fileId)
  return fileTree

def addFilePathsToRow(drive, fileTree, fileEntryInfo, filePathInfo, row, titles):
  _, paths = getFilePaths(drive, fileTree, fileEntryInfo, filePathInfo)
  kcount = len(paths)
  row[u'paths'] = kcount
  k = 0
  for path in paths:
    key = u'path.{0}'.format(k)
    if key not in titles[u'set']:
      addTitleToCSVfile(key, titles)
    row[key] = path
    k += 1

DRIVEFILE_ORDERBY_CHOICES_MAP = {
  u'createddate': DRIVE_FILE_CREATED_DATE_TIME,
  u'createdtime': DRIVE_FILE_CREATED_DATE_TIME,
  u'folder': u'folder',
  u'lastviewedbyme': DRIVE_FILE_LAST_VIEWED_BY_ME_DATE_TIME,
  u'lastviewedbymedate': DRIVE_FILE_LAST_VIEWED_BY_ME_DATE_TIME,
  u'lastviewedbymetime': DRIVE_FILE_LAST_VIEWED_BY_ME_DATE_TIME,
  u'lastviewedbyuser': DRIVE_FILE_LAST_VIEWED_BY_ME_DATE_TIME,
  u'modifiedbyme': DRIVE_FILE_MODIFIED_BY_ME_DATE_TIME,
  u'modifiedbymedate': DRIVE_FILE_MODIFIED_BY_ME_DATE_TIME,
  u'modifiedbymetime': DRIVE_FILE_MODIFIED_BY_ME_DATE_TIME,
  u'modifiedbyuser': DRIVE_FILE_MODIFIED_BY_ME_DATE_TIME,
  u'modifieddate': DRIVE_FILE_MODIFIED_DATE_TIME,
  u'modifiedtime': DRIVE_FILE_MODIFIED_DATE_TIME,
  u'name': DRIVE_FILE_NAME,
  u'quotabytesused': u'quotaBytesUsed',
  u'quotaused': u'quotaBytesUsed',
  u'recency': u'recency',
  u'sharedwithmedate': DRIVE_FILE_SHARED_WITH_ME_DATE_TIME,
  u'sharedwithmetime': DRIVE_FILE_SHARED_WITH_ME_DATE_TIME,
  u'starred': u'starred',
  u'title': DRIVE_FILE_NAME,
  u'viewedbymedate': DRIVE_FILE_LAST_VIEWED_BY_ME_DATE_TIME,
  u'viewedbymetime': DRIVE_FILE_LAST_VIEWED_BY_ME_DATE_TIME,
  }

SHOW_OWNED_BY_CHOICES_MAP = {u'any': None, u'me': True, u'others': False}
FILELIST_TITLES = [u'id', u'mimeType', u'parents']
FILELIST_FIELDS = [u'id', u'mimeType', u'parents(id)']

# gam <UserTypeEntity> print|show filelist [todrive [<ToDriveAttributes>]] [anyowner|(showownedby any|me|others)] [query <QueryDriveFile>] [fullquery <QueryDriveFile>] [select <DriveFileEntity>|orphans] [depth <Number>]
#	[filepath] [allfields|<DriveFieldName>*|(fields <DriveFieldNameList>)] (orderby <DriveOrderByFieldName> [ascending|descending])* [delimiter <String>]
def printDriveFileList(users):
  def _setSelectionFields():
    if fileIdEntity:
      skip_objects.extend([field for field in FILELIST_TITLES if field not in fieldsList])
      fieldsList.extend(FILELIST_FIELDS)
    if filepath:
      skip_objects.extend([field for field in FILEPATH_TITLES if field not in fieldsList])
      fieldsList.extend(FILEPATH_FIELDS)
    if showOwnedBy is not None:
      skip_objects.extend([field for field in OWNED_BY_ME_FIELDS_TITLES if field not in fieldsList])
      fieldsList.extend(OWNED_BY_ME_FIELDS_TITLES)

  def _printFileInfo(drive, f_file):
    if f_file.get(u'prnt'):
      return
    if showOwnedBy is not None and f_file[u'ownedByMe'] != showOwnedBy:
      return
    f_file[u'prnt'] = True
    row = {u'Owner': user}
    if filepath:
      addFilePathsToRow(drive, fileTree, f_file, filePathInfo, row, titles)
    for permission in f_file.get(u'permissions', []):
      _convertReaderToCommenter(permission)
    for attrib in f_file:
      if attrib in skip_objects:
        continue
      if not isinstance(f_file[attrib], dict):
        if isinstance(f_file[attrib], list):
          if f_file[attrib]:
            if attrib not in titles[u'set']:
              addTitleToCSVfile(attrib, titles)
            if isinstance(f_file[attrib][0], (str, unicode, int, bool)):
              row[attrib] = delimiter.join(f_file[attrib])
            else:
              row[attrib] = len(f_file[attrib])
              for j, l_attrib in enumerate(f_file[attrib]):
                for list_attrib in l_attrib:
                  if list_attrib in [u'kind', u'etag', u'selfLink']:
                    continue
                  x_attrib = u'{0}.{1}.{2}'.format(attrib, j, list_attrib)
                  row[x_attrib] = l_attrib[list_attrib]
                  if x_attrib not in titles[u'set']:
                    addTitleToCSVfile(x_attrib, titles)
        elif isinstance(f_file[attrib], (str, unicode, int, bool)):
          if attrib not in DRIVEFILE_TIME_OBJECTS:
            row[attrib] = f_file[attrib]
          else:
            row[attrib] = formatLocalTime(f_file[attrib])
          if attrib not in titles[u'set']:
            addTitleToCSVfile(attrib, titles)
        else:
          writeStderr(u'{0}: {1}, Attribute: {2}, Unknown type: {3}\n'.format(Entity.Singular(Entity.DRIVE_FILE_ID), f_file[u'id'], attrib, type(f_file[attrib])))
      elif attrib == u'labels':
        for dict_attrib in f_file[attrib]:
          row[dict_attrib] = f_file[attrib][dict_attrib]
          if dict_attrib not in titles[u'set']:
            addTitleToCSVfile(dict_attrib, titles)
      else:
        for dict_attrib in f_file[attrib]:
          if dict_attrib in [u'kind', u'etag']:
            continue
          x_attrib = u'{0}.{1}'.format(attrib, dict_attrib)
          row[x_attrib] = f_file[attrib][dict_attrib]
          if x_attrib not in titles[u'set']:
            addTitleToCSVfile(x_attrib, titles)
    csvRows.append(row)

  def _printDriveFolderContents(drive, fileEntry, depth):
    for childId in fileEntry[u'children']:
      childEntry = fileTree.get(childId)
      if childEntry:
        _printFileInfo(drive, childEntry[u'info'])
        if maxdepth == -1 or depth < maxdepth:
          _printDriveFolderContents(drive, childEntry, depth+1)

  allfields = filepath = False
  todrive = {}
  maxdepth = -1
  fieldsList = []
  fieldsTitles = {}
  labelsList = []
  orderByList = []
  skip_objects = [u'prnt',]
  titles, csvRows = initializeTitlesCSVfile([u'Owner',])
  query = ME_IN_OWNERS
  fileIdEntity = showOwnedBy = fileTree = None
  body, parameters = initializeDriveFileAttributes()
  delimiter = GC_Values[GC_CSV_OUTPUT_FIELD_DELIMITER]
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'filepath':
      filepath = True
    elif myarg == u'orderby':
      fieldName = getChoice(DRIVEFILE_ORDERBY_CHOICES_MAP, mapChoice=True)
      if getChoice(SORTORDER_CHOICES_MAP, defaultChoice=None, mapChoice=True) != u'DESCENDING':
        orderByList.append(fieldName)
      else:
        orderByList.append(u'{0} desc'.format(fieldName))
    elif myarg == u'query':
      if query:
        query += u' and '+getString(OB_QUERY)
      else:
        query = getString(OB_QUERY)
    elif myarg == u'fullquery':
      query = getString(OB_QUERY, minLen=0)
      if not query:
        query = None
    elif myarg == u'select':
      fileIdEntity = getDriveFileEntity(orphansOK=True)
    elif myarg == u'depth':
      maxdepth = getInteger(minVal=-1)
    elif myarg == u'allfields':
      fieldsList = []
      allfields = True
    elif myarg in DRIVEFILE_FIELDS_CHOICES_MAP:
      addFieldToCSVfile(myarg, {myarg: [DRIVEFILE_FIELDS_CHOICES_MAP[myarg]]}, fieldsList, fieldsTitles, titles)
    elif myarg in DRIVEFILE_LABEL_CHOICES_MAP:
      addFieldToCSVfile(myarg, {myarg: [DRIVEFILE_LABEL_CHOICES_MAP[myarg]]}, labelsList, fieldsTitles, titles)
    elif myarg == u'fields':
      for field in getString(OB_FIELD_NAME_LIST).lower().replace(u',', u' ').split():
        if field in DRIVEFILE_FIELDS_CHOICES_MAP:
          addFieldToCSVfile(field, {field: [DRIVEFILE_FIELDS_CHOICES_MAP[field]]}, fieldsList, fieldsTitles, titles)
        elif field in DRIVEFILE_LABEL_CHOICES_MAP:
          addFieldToCSVfile(field, {field: [DRIVEFILE_LABEL_CHOICES_MAP[field]]}, labelsList, fieldsTitles, titles)
        else:
          CLArgs.Backup()
          invalidChoiceExit(DRIVEFILE_FIELDS_CHOICES_MAP.keys()+DRIVEFILE_LABEL_CHOICES_MAP.keys())
    elif myarg == u'anyowner':
      query = _stripMeInOwners(query)
      query = _stripNotMeInOwners(query)
    elif myarg == u'showownedby':
      showOwnedBy = getChoice(SHOW_OWNED_BY_CHOICES_MAP, mapChoice=True)
      if showOwnedBy is None:
        query = _stripMeInOwners(query)
        query = _stripNotMeInOwners(query)
      elif not showOwnedBy:
        query = _stripMeInOwners(query)
        if query:
          if query.find(NOT_ME_IN_OWNERS) == -1:
            query = NOT_ME_IN_OWNERS_AND+query
        else:
          query = NOT_ME_IN_OWNERS
      else:
        query = _stripNotMeInOwners(query)
        if query:
          if query.find(ME_IN_OWNERS) == -1:
            query = ME_IN_OWNERS_AND+query
        else:
          query = ME_IN_OWNERS
    elif myarg == u'delimiter':
      delimiter = getDelimiter()
    else:
      unknownArgumentExit()
  if not fileIdEntity and maxdepth != -1:
    fileIdEntity = initDriveFileEntity()
    cleanFileIDsList(fileIdEntity, [u'root',])
  if fieldsList or labelsList:
    _setSelectionFields()
    fields = u'nextPageToken,{0}('.format(DRIVE_FILES_LIST)
    if fieldsList:
      fields += u','.join(set(fieldsList))
      if labelsList:
        fields += u','
    if labelsList:
      fields += u'labels({0})'.format(u','.join(set(labelsList)))
    fields += u')'
  elif not allfields:
    for field in [u'name', DRIVE_FILE_VIEW_LINK]:
      addFieldToCSVfile(field, {field: [DRIVEFILE_FIELDS_CHOICES_MAP[field.lower()]]}, fieldsList, fieldsTitles, titles)
    _setSelectionFields()
    fields = u'nextPageToken,{0}({1})'.format(DRIVE_FILES_LIST, u','.join(set(fieldsList)))
  else:
    fields = u'*'
    skip_objects.extend([u'kind', u'etag'])
  orderBy = u','.join(orderByList) if orderByList else None
  if filepath:
    addTitlesToCSVfile([u'paths',], titles)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, drive = buildGAPIServiceObject(DRIVE_API, user)
    if not drive:
      continue
    if filepath:
      filePathInfo = initFilePathInfo()
    try:
      printGettingAllEntityItemsForWhom(Entity.DRIVE_FILE_OR_FOLDER, user, i, count, qualifier=queryQualifier(query))
      page_message = getPageMessageForWhom()
      feed = callGAPIpages(drive.files(), u'list', DRIVE_FILES_LIST,
                           page_message=page_message,
                           throw_reasons=GAPI_DRIVE_THROW_REASONS+[GAPI_INVALID_QUERY, GAPI_FILE_NOT_FOUND],
                           q=query, orderBy=orderBy, fields=fields, maxResults=GC_Values[GC_DRIVE_MAX_RESULTS])
      if not fileIdEntity:
        if filepath:
          fileTree = buildFileTree(feed, drive)
          for f_file in feed:
            _printFileInfo(drive, f_file)
        else:
          while feed:
            _printFileInfo(drive, feed.popleft())
      else:
        user, drive, jcount = _validateUserGetFileIDs(origUser, i, count, fileIdEntity, body, parameters, drive=drive)
        if jcount == 0:
          continue
        fileTree = buildFileTree(feed, drive)
        j = 0
        for fileId in fileIdEntity[u'list']:
          j += 1
          fileEntry = fileTree.get(fileId)
          if fileEntry:
            _printDriveFolderContents(drive, fileEntry, 0)
          else:
            entityActionFailedWarning([Entity.USER, user, Entity.DRIVE_FILE_OR_FOLDER, fileId], PHRASE_NOT_FOUND, j, jcount)
    except GAPI_invalidQuery:
      entityActionFailedWarning([Entity.USER, user, Entity.DRIVE_FILE, PHRASE_LIST], invalidQuery(query), i, count)
      break
    except GAPI_fileNotFound:
      printGettingEntityItemsForWhomDoneInfo(0)
    except (GAPI_serviceNotAvailable, GAPI_authError):
      entityServiceNotApplicableWarning(Entity.USER, user, i, count)
  if allfields:
    sortCSVTitles([u'Owner', u'id', DRIVE_FILE_NAME], titles)
  writeCSVfile(csvRows, titles,
               u'{0} {1} Drive Files'.format(CLArgs.Argument(GM_Globals[GM_ENTITY_CL_START]),
                                             CLArgs.Argument(GM_Globals[GM_ENTITY_CL_START]+1)),
               todrive)

# gam <UserTypeEntity> show filepath <DriveFileEntity>
def showDriveFilePath(users):
  fileIdEntity = getDriveFileEntity()
  body, parameters = initializeDriveFileAttributes()
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, body, parameters, entityType=Entity.DRIVE_FILE_OR_FOLDER)
    if jcount == 0:
      continue
    filePathInfo = initFilePathInfo()
    Indent.Increment()
    j = 0
    for fileId in fileIdEntity[u'list']:
      j += 1
      try:
        result = callGAPI(drive.files(), u'get',
                          throw_reasons=GAPI_DRIVE_THROW_REASONS+[GAPI_FILE_NOT_FOUND],
                          fileId=fileId, fields=u'{0},{1},mimeType'.format(DRIVE_FILE_NAME, DRIVE_PARENTS_ID))
        entityType, paths = getFilePaths(drive, None, result, filePathInfo)
        kcount = len(paths)
        entityPerformActionNumItems([entityType, u'{0} ({1})'.format(result[DRIVE_FILE_NAME], fileId)], kcount, Entity.DRIVE_PATH, j, jcount)
        Indent.Increment()
        k = 0
        for path in paths:
          k += 1
          printEntity([Entity.DRIVE_PATH, path], k, kcount)
        Indent.Decrement()
      except GAPI_fileNotFound:
        entityActionFailedWarning([Entity.USER, user, Entity.DRIVE_FILE_OR_FOLDER_ID, fileId], PHRASE_DOES_NOT_EXIST, j, jcount)
      except (GAPI_serviceNotAvailable, GAPI_authError):
        entityServiceNotApplicableWarning(Entity.USER, user, i, count)
        break
    Indent.Decrement()

# gam <UserTypeEntity> show filetree [anyowner|(showownedby any|me|others)] [select <DriveFileEntity>|orphans] (orderby <DriveOrderByFieldName> [ascending|descending])* [depth <Number>]
def showDriveFileTree(users):
  def _showDriveFolderContents(fileEntry, depth):
    for childId in fileEntry[u'children']:
      childEntry = fileTree.get(childId)
      if childEntry:
        printKeyValueList([childEntry[u'info'][DRIVE_FILE_NAME]])
        if maxdepth == -1 or depth < maxdepth:
          Indent.Increment()
          _showDriveFolderContents(childEntry, depth+1)
          Indent.Decrement()

  maxdepth = -1
  query = ME_IN_OWNERS
  fileIdEntity = showOwnedBy = fileTree = None
  body, parameters = initializeDriveFileAttributes()
  orderByList = []
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'select':
      fileIdEntity = getDriveFileEntity(orphansOK=True)
    elif myarg == u'orderby':
      fieldName = getChoice(DRIVEFILE_ORDERBY_CHOICES_MAP, mapChoice=True)
      if getChoice(SORTORDER_CHOICES_MAP, defaultChoice=None, mapChoice=True) != u'DESCENDING':
        orderByList.append(fieldName)
      else:
        orderByList.append(u'{0} desc'.format(fieldName))
    elif myarg == u'depth':
      maxdepth = getInteger(minVal=-1)
    elif myarg == u'anyowner':
      query = None
    elif myarg == u'showownedby':
      showOwnedBy = getChoice(SHOW_OWNED_BY_CHOICES_MAP, mapChoice=True)
      if showOwnedBy is None:
        query = None
      elif not showOwnedBy:
        query = NOT_ME_IN_OWNERS
      else:
        query = ME_IN_OWNERS
    else:
      unknownArgumentExit()
  if not fileIdEntity:
    fileIdEntity = initDriveFileEntity()
    cleanFileIDsList(fileIdEntity, [u'root',])
  orderBy = u','.join(orderByList) if orderByList else None
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, drive = buildGAPIServiceObject(DRIVE_API, user)
    if not drive:
      continue
    try:
      printGettingAllEntityItemsForWhom(Entity.DRIVE_FILE_OR_FOLDER, user, i, count, qualifier=queryQualifier(query))
      page_message = getPageMessageForWhom()
      feed = callGAPIpages(drive.files(), u'list', DRIVE_FILES_LIST,
                           page_message=page_message,
                           throw_reasons=GAPI_DRIVE_THROW_REASONS,
                           q=query, orderBy=orderBy, fields=u'nextPageToken,{0}(id,{1},{2},mimeType)'.format(DRIVE_FILES_LIST, DRIVE_FILE_NAME, DRIVE_PARENTS_ID), maxResults=GC_Values[GC_DRIVE_MAX_RESULTS])
      user, drive, jcount = _validateUserGetFileIDs(origUser, i, count, fileIdEntity, body, parameters, drive=drive, entityType=Entity.DRIVE_FOLDER)
      if jcount == 0:
        continue
      j = 0
      fileTree = buildFileTree(feed, drive)
      Indent.Increment()
      for fileId in fileIdEntity[u'list']:
        j += 1
        fileEntry = fileTree.get(fileId)
        if fileEntry:
          fileEntryInfo = fileEntry[u'info']
          printEntity([[Entity.DRIVE_FILE, Entity.DRIVE_FOLDER][fileEntryInfo[u'mimeType'] == MIMETYPE_GA_FOLDER], fileEntryInfo[DRIVE_FILE_NAME]], j, jcount)
          Indent.Increment()
          _showDriveFolderContents(fileEntry, 0)
          Indent.Decrement()
        else:
          entityActionFailedWarning([Entity.DRIVE_FILE_OR_FOLDER, fileId], PHRASE_NOT_FOUND, j, jcount)
      Indent.Decrement()
    except (GAPI_serviceNotAvailable, GAPI_authError):
      entityServiceNotApplicableWarning(Entity.USER, user, i, count)

# gam <UserTypeEntity> add drivefile [drivefilename <DriveFileName>] [<DriveFileAttributes>]
def addDriveFile(users):
  media_body = None
  fileIdEntity = initDriveFileEntity()
  body, parameters = initializeDriveFileAttributes()
  kwargs = {}
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'drivefilename':
      body[DRIVE_FILE_NAME] = getString(OB_DRIVE_FILE_NAME)
    else:
      getDriveFileAttribute(body, parameters, myarg, False, kwargs)
  Action.Set(Action.CREATE)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive, _ = _validateUserGetFileIDs(user, i, count, fileIdEntity, body, parameters)
    if not drive:
      continue
    if parameters[DFA_LOCALFILEPATH]:
      try:
        media_body = googleapiclient.http.MediaFileUpload(parameters[DFA_LOCALFILEPATH], mimetype=parameters[DFA_LOCALMIMETYPE], resumable=True)
      except IOError as e:
        systemErrorExit(FILE_ERROR_RC, e)
    try:
      result = callGAPI(drive.files(), DRIVE_CREATE_FILE,
                        throw_reasons=GAPI_DRIVE_THROW_REASONS,
                        convert=parameters[DFA_CONVERT], ocr=parameters[DFA_OCR], ocrLanguage=parameters[DFA_OCRLANGUAGE],
                        visibility=parameters[DFA_IGNORE_DEFAULT_VISIBILITY],
                        pinned=parameters[DFA_KEEP_REVISION_FOREVER],
                        useContentAsIndexableText=parameters[DFA_USE_CONTENT_AS_INDEXABLE_TEXT],
                        media_body=media_body, body=body, fields=u'id,{0},mimeType'.format(DRIVE_FILE_NAME))
      if parameters[DFA_LOCALFILENAME]:
        entityModifierNewValueActionPerformed([Entity.USER, user, Entity.DRIVE_FILE, result[DRIVE_FILE_NAME]], Action.MODIFIER_WITH_CONTENT_FROM, parameters[DFA_LOCALFILENAME], i, count)
      elif result[u'mimeType'] != MIMETYPE_GA_FOLDER:
        entityActionPerformed([Entity.USER, user, Entity.DRIVE_FILE, result[DRIVE_FILE_NAME]], i, count)
      else:
        entityActionPerformed([Entity.USER, user, Entity.DRIVE_FOLDER, result[DRIVE_FILE_NAME]], i, count)
    except (GAPI_serviceNotAvailable, GAPI_authError):
      entityServiceNotApplicableWarning(Entity.USER, user, i, count)

# gam <UserTypeEntity> update drivefile <DriveFileEntity> [copy] [newfilename <DriveFileName>] [<DriveFileUpdateAttributes>]
def updateDriveFile(users):
  fileIdEntity = getDriveFileEntity()
  body, parameters = initializeDriveFileAttributes()
  kwargs = {}
  media_body = None
  operation = u'update'
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'copy':
      operation = u'copy'
      Action.Set(Action.COPY)
    elif myarg == u'newfilename':
      body[DRIVE_FILE_NAME] = getString(OB_DRIVE_FILE_NAME)
    else:
      getDriveFileAttribute(body, parameters, myarg, True, kwargs)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, body, parameters, entityType=Entity.DRIVE_FILE_OR_FOLDER)
    if jcount == 0:
      continue
    if operation == u'update':
      if parameters[DFA_LOCALFILEPATH]:
        try:
          media_body = googleapiclient.http.MediaFileUpload(parameters[DFA_LOCALFILEPATH], mimetype=parameters[DFA_LOCALMIMETYPE], resumable=True)
        except IOError as e:
          systemErrorExit(FILE_ERROR_RC, e)
      Indent.Increment()
      j = 0
      for fileId in fileIdEntity[u'list']:
        j += 1
        try:
          if media_body:
            result = callGAPI(drive.files(), DRIVE_UPDATE_FILE,
                              throw_reasons=GAPI_DRIVE_THROW_REASONS+[GAPI_FILE_NOT_FOUND, GAPI_FORBIDDEN, GAPI_INTERNAL_ERROR],
                              fileId=fileId, ocr=parameters[DFA_OCR], ocrLanguage=parameters[DFA_OCRLANGUAGE],
                              pinned=parameters[DFA_KEEP_REVISION_FOREVER],
                              useContentAsIndexableText=parameters[DFA_USE_CONTENT_AS_INDEXABLE_TEXT],
                              addParents=u','.join(parameters[DFA_ADD_PARENTS]), removeParents=u','.join(parameters[DFA_REMOVE_PARENTS]),
                              media_body=media_body, body=body, fields=u'id,{0},mimeType'.format(DRIVE_FILE_NAME), **kwargs)
            entityModifierNewValueActionPerformed([Entity.USER, user, Entity.DRIVE_FILE, result[DRIVE_FILE_NAME]], Action.MODIFIER_WITH_CONTENT_FROM, parameters[DFA_LOCALFILENAME], j, jcount)
          else:
            result = callGAPI(drive.files(), DRIVE_PATCH_FILE,
                              throw_reasons=GAPI_DRIVE_THROW_REASONS+[GAPI_FILE_NOT_FOUND, GAPI_FORBIDDEN, GAPI_INTERNAL_ERROR],
                              fileId=fileId, ocr=parameters[DFA_OCR], ocrLanguage=parameters[DFA_OCRLANGUAGE],
                              pinned=parameters[DFA_KEEP_REVISION_FOREVER],
                              useContentAsIndexableText=parameters[DFA_USE_CONTENT_AS_INDEXABLE_TEXT],
                              addParents=u','.join(parameters[DFA_ADD_PARENTS]), removeParents=u','.join(parameters[DFA_REMOVE_PARENTS]),
                              body=body, fields=u'id,{0},mimeType'.format(DRIVE_FILE_NAME), **kwargs)
            entityActionPerformed([Entity.USER, user, [Entity.DRIVE_FOLDER, Entity.DRIVE_FILE][result[u'mimeType'] != MIMETYPE_GA_FOLDER], result[DRIVE_FILE_NAME]], j, jcount)
        except (GAPI_fileNotFound, GAPI_forbidden, GAPI_internalError) as e:
          entityActionFailedWarning([Entity.USER, user, Entity.DRIVE_FILE_OR_FOLDER_ID, fileId], e.message, j, jcount)
        except (GAPI_serviceNotAvailable, GAPI_authError):
          entityServiceNotApplicableWarning(Entity.USER, user, i, count)
          break
      Indent.Decrement()
    else:
      Indent.Increment()
      j = 0
      for fileId in fileIdEntity[u'list']:
        j += 1
        try:
          result = callGAPI(drive.files(), u'copy',
                            throw_reasons=GAPI_DRIVE_THROW_REASONS+[GAPI_FILE_NOT_FOUND, GAPI_FORBIDDEN, GAPI_INTERNAL_ERROR],
                            fileId=fileId, convert=parameters[DFA_CONVERT], ocr=parameters[DFA_OCR], ocrLanguage=parameters[DFA_OCRLANGUAGE],
                            visibility=parameters[DFA_IGNORE_DEFAULT_VISIBILITY],
                            pinned=parameters[DFA_KEEP_REVISION_FOREVER],
                            body=body, fields=u'id,{0}'.format(DRIVE_FILE_NAME))
          entityModifierNewValueItemValueActionPerformed([Entity.USER, user, Entity.DRIVE_FILE, fileId], Action.MODIFIER_TO, result[DRIVE_FILE_NAME], Entity.DRIVE_FILE_ID, result[u'id'], j, jcount)
        except (GAPI_fileNotFound, GAPI_forbidden, GAPI_internalError) as e:
          entityActionFailedWarning([Entity.USER, user, Entity.DRIVE_FILE, fileId], e.message, j, jcount)
        except (GAPI_serviceNotAvailable, GAPI_authError):
          entityServiceNotApplicableWarning(Entity.USER, user, i, count)
          break
      Indent.Decrement()

# gam <UserTypeEntity> copy drivefile <DriveFileEntity> [newfilename <DriveFileName>] [recursive] [parentid <DriveFolderID>] [parentname <DriveFolderName>]
def copyDriveFile(users):
  def _recursiveFolderCopy(drive, user, i, count, folderId, folderTitle, newFolderTitle, parentId):
    body = {DRIVE_FILE_NAME: newFolderTitle, u'mimeType': MIMETYPE_GA_FOLDER, u'parents': []}
    if parentId:
      body[u'parents'].append({u'id': parentId})
    result = callGAPI(drive.files(), DRIVE_CREATE_FILE, body=body, fields=u'id')
    newFolderId = result[u'id']
    Action.Set(Action.CREATE)
    entityActionPerformed([Entity.USER, user, Entity.DRIVE_FOLDER, newFolderTitle, Entity.DRIVE_FOLDER_ID, newFolderId], i, count)
    Action.Set(Action.COPY)
    source_children = callGAPI(drive.children(), u'list', folderId=folderId, fields=u'{0}(id)'.format(DRIVE_FILES_LIST))
    jcount = len(source_children[DRIVE_FILES_LIST]) if (source_children and (DRIVE_FILES_LIST in source_children)) else 0
    if jcount > 0:
      Indent.Increment()
      j = 0
      for child in source_children[DRIVE_FILES_LIST]:
        j += 1
        metadata = callGAPI(drive.files(), u'get', fileId=child[u'id'], fields=u'id,{0},mimeType'.format(DRIVE_FILE_NAME))
        if metadata[u'mimeType'] == MIMETYPE_GA_FOLDER:
          _recursiveFolderCopy(drive, user, j, jcount, child[u'id'], metadata[DRIVE_FILE_NAME], metadata[DRIVE_FILE_NAME], newFolderId)
        else:
          fileId = metadata[u'id']
          body = {DRIVE_FILE_NAME: metadata[DRIVE_FILE_NAME], u'parents': []}
          body[u'parents'].append({u'id': newFolderId})
          result = callGAPI(drive.files(), u'copy', fileId=fileId, body=body, fields=u'id,{0}'.format(DRIVE_FILE_NAME))
          entityModifierNewValueItemValueActionPerformed([Entity.USER, user, Entity.DRIVE_FILE, metadata[DRIVE_FILE_NAME]], Action.MODIFIER_TO, result[DRIVE_FILE_NAME], Entity.DRIVE_FILE_ID, result[u'id'], j, jcount)
      Indent.Decrement()
      entityModifierNewValueItemValueActionPerformed([Entity.USER, user, Entity.DRIVE_FOLDER, folderTitle], Action.MODIFIER_TO, newFolderTitle, Entity.DRIVE_FOLDER_ID, newFolderId, i, count)

  fileIdEntity = getDriveFileEntity()
  body, parameters = initializeDriveFileAttributes()
  parentid = newfilename = None
  recursive = False
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'newfilename':
      newfilename = getString(OB_DRIVE_FILE_NAME)
      body[DRIVE_FILE_NAME] = newfilename
    elif myarg == u'recursive':
      recursive = True
    elif myarg == u'parentid':
      body.setdefault(u'parents', [])
      body[u'parents'].append({u'id': getString(OB_DRIVE_FILE_ID)})
    elif myarg == u'parentname':
      parameters[DFA_PARENTQUERY] = ME_IN_OWNERS_AND+u"mimeType = '{0}' and {1} = '{2}'".format(MIMETYPE_GA_FOLDER, DRIVE_FILE_NAME, getString(OB_DRIVE_FOLDER_NAME))
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, body, parameters, entityType=Entity.DRIVE_FILE_OR_FOLDER)
    if jcount == 0:
      continue
    Indent.Increment()
    j = 0
    for fileId in fileIdEntity[u'list']:
      j += 1
      try:
        metadata = callGAPI(drive.files(), u'get',
                            throw_reasons=GAPI_DRIVE_THROW_REASONS+[GAPI_FILE_NOT_FOUND, GAPI_FORBIDDEN, GAPI_INTERNAL_ERROR],
                            fileId=fileId, fields=u'id,{0},mimeType'.format(DRIVE_FILE_NAME))
        if metadata[u'mimeType'] == MIMETYPE_GA_FOLDER:
          if recursive:
            destFilename = newfilename or u'Copy of {0}'.format(metadata[DRIVE_FILE_NAME])
            _recursiveFolderCopy(drive, user, j, jcount, fileId, metadata[DRIVE_FILE_NAME], destFilename, parentid)
          else:
            entityActionNotPerformedWarning([Entity.USER, user, Entity.DRIVE_FOLDER, metadata[DRIVE_FILE_NAME]],
                                            PHRASE_USE_RECURSIVE_ARGUMENT_TO_COPY_FOLDERS, j, jcount)
        else:
          result = callGAPI(drive.files(), u'copy',
                            throw_reasons=[GAPI_FILE_NOT_FOUND, GAPI_FORBIDDEN, GAPI_INTERNAL_ERROR],
                            fileId=fileId, convert=parameters[DFA_CONVERT], ocr=parameters[DFA_OCR], ocrLanguage=parameters[DFA_OCRLANGUAGE],
                            visibility=parameters[DFA_IGNORE_DEFAULT_VISIBILITY],
                            pinned=parameters[DFA_KEEP_REVISION_FOREVER],
                            body=body, fields=u'id,{0}'.format(DRIVE_FILE_NAME))
          entityModifierNewValueItemValueActionPerformed([Entity.USER, user, Entity.DRIVE_FILE, metadata[DRIVE_FILE_NAME]], Action.MODIFIER_TO, result[DRIVE_FILE_NAME], Entity.DRIVE_FILE_ID, result[u'id'], j, jcount)
      except (GAPI_fileNotFound, GAPI_forbidden, GAPI_internalError) as e:
        entityActionFailedWarning([Entity.USER, user, Entity.DRIVE_FILE_OR_FOLDER_ID, fileId], e.message, j, jcount)
      except (GAPI_serviceNotAvailable, GAPI_authError):
        entityServiceNotApplicableWarning(Entity.USER, user, i, count)
        break
    Indent.Decrement()
#
DELETE_DRIVEFILE_CHOICES_MAP = {u'purge': u'delete', u'trash': u'trash', u'untrash': u'untrash',}
DELETE_DRIVEFILE_FUNCTION_TO_ACTION_MAP = {u'delete': Action.PURGE, u'trash': Action.TRASH, u'untrash': Action.UNTRASH,}

# gam <UserTypeEntity> delete drivefile <DriveFileEntity> [purge|trash|untrash]
def deleteDriveFile(users, function=None):
  fileIdEntity = getDriveFileEntity()
  body, parameters = initializeDriveFileAttributes()
  if not function:
    function = getChoice(DELETE_DRIVEFILE_CHOICES_MAP, defaultChoice=u'trash', mapChoice=True)
  checkForExtraneousArguments()
  Action.Set(DELETE_DRIVEFILE_FUNCTION_TO_ACTION_MAP[function])
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, body, parameters, entityType=Entity.DRIVE_FILE_OR_FOLDER)
    if jcount == 0:
      continue
    Indent.Increment()
    j = 0
    for fileId in fileIdEntity[u'list']:
      j += 1
      try:
        result = callGAPI(drive.files(), function,
                          throw_reasons=GAPI_DRIVE_THROW_REASONS+[GAPI_FILE_NOT_FOUND, GAPI_FORBIDDEN, GAPI_INTERNAL_ERROR],
                          fileId=fileId, fields=DRIVE_FILE_NAME)
        if result and DRIVE_FILE_NAME in result:
          fileName = result[DRIVE_FILE_NAME]
        else:
          fileName = fileId
        entityActionPerformed([Entity.USER, user, Entity.DRIVE_FILE_OR_FOLDER, fileName], j, jcount)
      except (GAPI_fileNotFound, GAPI_forbidden, GAPI_internalError) as e:
        entityActionFailedWarning([Entity.USER, user, Entity.DRIVE_FILE_OR_FOLDER_ID, fileId], e.message, j, jcount)
      except (GAPI_serviceNotAvailable, GAPI_authError):
        entityServiceNotApplicableWarning(Entity.USER, user, i, count)
        break
    Indent.Decrement()

# gam <UserTypeEntity> purge drivefile <DriveFileEntity>
def purgeDriveFile(users):
  deleteDriveFile(users, u'delete')

# gam <UserTypeEntity> trash drivefile <DriveFileEntity>
def trashDriveFile(users):
  deleteDriveFile(users, u'trash')

# gam <UserTypeEntity> untrash drivefile <DriveFileEntity>
def untrashDriveFile(users):
  deleteDriveFile(users, u'untrash')
#
DOCUMENT_FORMATS_MAP = {
  u'csv': [{u'mime': u'text/csv', u'ext': u'.csv'}],
  u'html': [{u'mime': u'text/html', u'ext': u'.html'}],
  u'txt': [{u'mime': u'text/plain', u'ext': u'.txt'}],
  u'tsv': [{u'mime': u'text/tsv', u'ext': u'.tsv'}],
  u'jpeg': [{u'mime': u'image/jpeg', u'ext': u'.jpeg'}],
  u'jpg': [{u'mime': u'image/jpeg', u'ext': u'.jpg'}],
  u'png': [{u'mime': u'image/png', u'ext': u'.png'}],
  u'svg': [{u'mime': u'image/svg+xml', u'ext': u'.svg'}],
  u'pdf': [{u'mime': u'application/pdf', u'ext': u'.pdf'}],
  u'rtf': [{u'mime': u'application/rtf', u'ext': u'.rtf'}],
  u'zip': [{u'mime': u'application/zip', u'ext': u'.zip'}],
  u'pptx': [{u'mime': u'application/vnd.openxmlformats-officedocument.presentationml.presentation', u'ext': u'.pptx'}],
  u'xlsx': [{u'mime': u'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', u'ext': u'.xlsx'}],
  u'docx': [{u'mime': u'application/vnd.openxmlformats-officedocument.wordprocessingml.document', u'ext': u'.docx'}],
  u'ms': [{u'mime': u'application/vnd.openxmlformats-officedocument.presentationml.presentation', u'ext': u'.pptx'},
          {u'mime': u'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', u'ext': u'.xlsx'},
          {u'mime': u'application/vnd.openxmlformats-officedocument.wordprocessingml.document', u'ext': u'.docx'}],
  u'microsoft': [{u'mime': u'application/vnd.openxmlformats-officedocument.presentationml.presentation', u'ext': u'.pptx'},
                 {u'mime': u'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', u'ext': u'.xlsx'},
                 {u'mime': u'application/vnd.openxmlformats-officedocument.wordprocessingml.document', u'ext': u'.docx'}],
  u'micro$oft': [{u'mime': u'application/vnd.openxmlformats-officedocument.presentationml.presentation', u'ext': u'.pptx'},
                 {u'mime': u'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', u'ext': u'.xlsx'},
                 {u'mime': u'application/vnd.openxmlformats-officedocument.wordprocessingml.document', u'ext': u'.docx'}],
  u'odt': [{u'mime': u'application/vnd.oasis.opendocument.text', u'ext': u'.odt'}],
  u'ods': [{u'mime': u'application/x-vnd.oasis.opendocument.spreadsheet', u'ext': u'.ods'}],
  u'openoffice': [{u'mime': u'application/vnd.oasis.opendocument.text', u'ext': u'.odt'},
                  {u'mime': u'application/x-vnd.oasis.opendocument.spreadsheet', u'ext': u'.ods'}],
  }

# gam <UserTypeEntity> get drivefile <DriveFileEntity> [format <FileFormatList>] [targetfolder <FilePath>] [revision <Number>]
def getDriveFile(users):
  fileIdEntity = getDriveFileEntity()
  body, parameters = initializeDriveFileAttributes()
  revisionId = None
  exportFormatName = u'openoffice'
  exportFormats = DOCUMENT_FORMATS_MAP[exportFormatName]
  targetFolder = GC_Values[GC_DRIVE_DIR]
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'format':
      exportFormatChoices = getString(OB_FORMAT_LIST).replace(u',', u' ').lower().split()
      exportFormats = []
      for exportFormat in exportFormatChoices:
        if exportFormat in DOCUMENT_FORMATS_MAP:
          exportFormats.extend(DOCUMENT_FORMATS_MAP[exportFormat])
        else:
          CLArgs.Backup()
          invalidChoiceExit(DOCUMENT_FORMATS_MAP)
    elif myarg == u'targetfolder':
      targetFolder = os.path.expanduser(getString(OB_FILE_PATH))
      if not os.path.isdir(targetFolder):
        os.makedirs(targetFolder)
    elif myarg == u'revision':
      revisionId = getInteger(minVal=1)
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, body, parameters, entityType=Entity.DRIVE_FILE)
    if jcount == 0:
      continue
    Indent.Increment()
    j = 0
    for fileId in fileIdEntity[u'list']:
      j += 1
      extension = None
      try:
        result = callGAPI(drive.files(), u'get',
                          throw_reasons=GAPI_DRIVE_THROW_REASONS+[GAPI_FILE_NOT_FOUND],
                          fileId=fileId, fields=u'{0},mimeType,{1},downloadUrl,exportLinks'.format(DRIVE_FILE_NAME, DRIVE_FILE_SIZE))
        if result[u'mimeType'] == MIMETYPE_GA_FOLDER:
          entityActionNotPerformedWarning([Entity.USER, user, Entity.DRIVE_FOLDER, result[DRIVE_FILE_NAME]], PHRASE_CAN_NOT_BE_DOWNLOADED, j, jcount)
          continue
        if DRIVE_FILE_SIZE in result:
          my_line = [u'Size', formatFileSize(int(result[DRIVE_FILE_SIZE]))]
        else:
          my_line = [u'Type', u'Google Doc']
        if u'downloadUrl' in result:
          download_url = result[u'downloadUrl']
        elif u'exportLinks' in result:
          for exportFormat in exportFormats:
            if exportFormat[u'mime'] in result[u'exportLinks']:
              download_url = result[u'exportLinks'][exportFormat[u'mime']]
              extension = exportFormat[u'ext']
              break
          else:
            entityActionNotPerformedWarning([Entity.USER, user, Entity.DRIVE_FILE, result[DRIVE_FILE_NAME]],
                                            PHRASE_FORMAT_NOT_AVAILABLE.format(u','.join(exportFormatChoices)), j, jcount)
            continue
        else:
          entityActionNotPerformedWarning([Entity.USER, user, Entity.DRIVE_FILE, result[DRIVE_FILE_NAME]],
                                          PHRASE_FORMAT_NOT_DOWNLOADABLE, j, jcount)
          continue
        safe_file_title = cleanFilename(result[DRIVE_FILE_NAME])
        filename = os.path.join(targetFolder, safe_file_title)
        y = 0
        while True:
          if extension and filename.lower()[-len(extension):] != extension:
            filename += extension
          if not os.path.isfile(filename):
            break
          y += 1
          filename = os.path.join(targetFolder, u'({0})-{1}'.format(y, safe_file_title))
        if revisionId:
          download_url = u'{0}&revision={1}'.format(download_url, revisionId)
        _, content = drive._http.request(download_url)
        status, e = writeFileReturnError(filename, content)
        if status:
          entityModifierNewValueKeyValueActionPerformed([Entity.USER, user, Entity.DRIVE_FILE, result[DRIVE_FILE_NAME]], Action.MODIFIER_TO, filename, my_line[0], my_line[1], j, jcount)
        else:
          entityModifierNewValueActionFailedWarning([Entity.USER, user, Entity.DRIVE_FILE, result[DRIVE_FILE_NAME]], Action.MODIFIER_TO, filename, e.strerror, j, jcount)
      except GAPI_fileNotFound:
        entityActionFailedWarning([Entity.USER, user, Entity.DRIVE_FILE_OR_FOLDER_ID, fileId], PHRASE_DOES_NOT_EXIST, j, jcount)
      except (GAPI_serviceNotAvailable, GAPI_authError):
        entityServiceNotApplicableWarning(Entity.USER, user, i, count)
        break
    Indent.Decrement()

# gam <UserTypeEntity> transfer drive <UserItem> [keepuser] [retainrole reader|commenter|writer|owner|editor] (orderby <DriveOrderByFieldName> [ascending|descending])*
def transferDriveFiles(users):

  def _newParents(oldParents, rootId):
    parents = []
    for parent in oldParents:
      parentId = parent[u'id']
      if parentId == rootId:
        parents.append({u'id': targetParentId})
      else:
        parents.append({u'id': parentIdMap.get(parentId, parentId)})
    if not parents:
      parents.append({u'id': targetParentId})
    return parents

  def _transferDriveFiles(fileEntry, rootId):
    jcount = len(fileEntry[u'children'])
    if jcount == 0:
      return
    j = 0
    for childId in fileEntry[u'children']:
      j += 1
      childEntry = fileTree.get(childId)
      if not childEntry or childEntry.get(u'xfer'):
        continue
      childEntry[u'xfer'] = True
      childFileName = childEntry[u'info'][DRIVE_FILE_NAME]
      childFileType = [Entity.DRIVE_FOLDER, Entity.DRIVE_FILE][childEntry[u'info'][u'mimeType'] != MIMETYPE_GA_FOLDER]
      if childEntry[u'info'][u'ownedByMe']:
        try:
          Action.Set(Action.TRANSFER_OWNERSHIP)
          callGAPI(sourceDrive.permissions(), DRIVE_CREATE_PERMISSIONS,
                   throw_reasons=GAPI_DRIVE_THROW_REASONS+[GAPI_FILE_NOT_FOUND, GAPI_INVALID_SHARING_REQUEST, GAPI_FORBIDDEN],
                   fileId=childId, sendNotificationEmails=False, body=targetPermissionsBody)
          entityModifierNewValueItemValueActionPerformed([Entity.USER, sourceUser, childFileType, childFileName], Action.MODIFIER_TO, None, Entity.USER, targetUser, j, jcount)
          callGAPI(targetDrive.files(), DRIVE_PATCH_FILE,
                   throw_reasons=GAPI_DRIVE_THROW_REASONS, retry_reasons=[GAPI_FILE_NOT_FOUND],
                   fileId=childId, body={u'parents': _newParents(childEntry[u'info'][u'parents'], rootId)}, fields=u'')
          if retainSourceRoleBody:
            if retainSourceRoleBody[u'role'] != u'writer':
              Action.Set(Action.UPDATE)
              callGAPI(targetDrive.permissions(), DRIVE_PATCH_PERMISSIONS,
                       throw_reasons=GAPI_DRIVE_THROW_REASONS+[GAPI_FILE_NOT_FOUND, GAPI_PERMISSION_NOT_FOUND, GAPI_BAD_REQUEST, GAPI_FORBIDDEN],
                       fileId=childId, permissionId=sourcePermissionId, body=retainSourceRoleBody)
            entityModifierNewValueActionPerformed([Entity.USER, sourceUser, childFileType, childFileName, Entity.ROLE, u'owner'], Action.MODIFIER_TO, retainSourceRoleBody[u'role'], j, jcount)
          else:
            Action.Set(Action.DELETE)
            callGAPI(targetDrive.permissions(), u'delete',
                     throw_reasons=GAPI_DRIVE_THROW_REASONS+[GAPI_FILE_NOT_FOUND, GAPI_PERMISSION_NOT_FOUND, GAPI_BAD_REQUEST, GAPI_FORBIDDEN],
                     fileId=childId, permissionId=sourcePermissionId)
            entityActionPerformed([Entity.USER, sourceUser, childFileType, childFileName, Entity.ROLE, u'owner'], j, jcount)
        except (GAPI_fileNotFound, GAPI_forbidden, GAPI_internalError, GAPI_badRequest) as e:
          entityActionFailedWarning([Entity.USER, sourceUser, childFileType, childFileName], e.message, j, jcount)
        except GAPI_permissionNotFound:
          entityDoesNotHaveItemWarning([Entity.USER, sourceUser, childFileType, childFileName, Entity.PERMISSION_ID, sourcePermissionId], j, jcount)
        except (GAPI_invalidSharingRequest) as e:
          entityActionFailedWarning([Entity.USER, sourceUser, childFileType, childFileName], entityTypeNameMessage(Entity.PERMISSION_ID, sourcePermissionId, e.message), j, jcount)
        except (GAPI_serviceNotAvailable, GAPI_authError):
          entityServiceNotApplicableWarning(Entity.USER, sourceUser, 0, 0)
      else:
        if childFileType == Entity.DRIVE_FILE:
          continue
### Skip if no children??
        try:
          result = callGAPIpages(targetDrive.files(), u'list', DRIVE_FILES_LIST,
                                 throw_reasons=GAPI_DRIVE_THROW_REASONS,
                                 q=ME_IN_OWNERS_AND+u"mimeType = '{0}' and {1} = '{2}'".format(MIMETYPE_GA_FOLDER, DRIVE_FILE_NAME, childFileName),
                                 fields=u'nextPageToken,{0}(id)'.format(DRIVE_FILES_LIST))
          if len(result) > 0:
            parentIdMap[childId] = result[0][u'id']
          else:
            parentIdMap[childId] = callGAPI(targetDrive.files(), DRIVE_CREATE_FILE,
                                            throw_reasons=GAPI_DRIVE_THROW_REASONS,
                                            body={u'parents': _newParents(childEntry[u'info'][u'parents'], rootId), DRIVE_FILE_NAME: childFileName, u'mimeType': MIMETYPE_GA_FOLDER}, fields=u'id')[u'id']
        except (GAPI_serviceNotAvailable, GAPI_authError):
          entityServiceNotApplicableWarning(Entity.USER, sourceUser, 0, 0)
      if childEntry[u'info'][u'mimeType'] == MIMETYPE_GA_FOLDER:
        Indent.Increment()
        _transferDriveFiles(childEntry, rootId)
        Indent.Decrement()

  targetUser = getEmailAddress()
  orderByList = []
  retainSourceRoleBody = {}
  targetFolderId = targetFolderName = None
  targetUserFolderPattern = u'#user# old files'
  parentIdMap = {}
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'keepuser':
      retainSourceRoleBody[u'body'] = u'writer'
    elif myarg == u'retainrole':
      retainSourceRole = getChoice(DRIVEFILE_ACL_ROLES_MAP, mapChoice=True)
      if retainSourceRole == u'owner':
        retainSourceRole = u'writer'
      _setRoleConvertCommenterToReader(retainSourceRoleBody, retainSourceRole)
    elif myarg == u'orderby':
      fieldName = getChoice(DRIVEFILE_ORDERBY_CHOICES_MAP, mapChoice=True)
      if getChoice(SORTORDER_CHOICES_MAP, defaultChoice=None, mapChoice=True) != u'DESCENDING':
        orderByList.append(fieldName)
      else:
        orderByList.append(u'{0} desc'.format(fieldName))
    elif myarg == u'targetfolderid':
      targetFolderIdLocation = CLArgs.Location()
      targetFolderId = getString(OB_DRIVE_FILE_ID)
    elif myarg == u'targetfoldername':
      targetFolderNameLocation = CLArgs.Location()
      targetFolderName = getString(OB_DRIVE_FILE_NAME)
    elif myarg == u'targetuserfoldername':
      targetUserFolderPattern = getString(OB_DRIVE_FILE_NAME)
    else:
      unknownArgumentExit()
  orderBy = u','.join(orderByList) if orderByList else None
  targetUser, targetDrive = buildGAPIServiceObject(DRIVE_API, targetUser)
  if not targetDrive:
    return
  try:
    result = callGAPI(targetDrive.about(), u'get',
                      throw_reasons=GAPI_DRIVE_THROW_REASONS,
                      fields=u'quotaBytesTotal,quotaBytesUsed')
    targetDriveFree = int(result[u'quotaBytesTotal']) - int(result[u'quotaBytesUsed'])
    if not targetFolderId and not targetFolderName:
      result = callGAPI(targetDrive.files(), u'get',
                        throw_reasons=GAPI_DRIVE_THROW_REASONS,
                        fileId=u'root', fields=u'id,{0}'.format(DRIVE_FILE_NAME))
      targetFolderId = result[u'id']
      targetFolderName = result[DRIVE_FILE_NAME]
    else:
      if targetFolderId:
        targetFolder = callGAPI(targetDrive.files(), u'get',
                                throw_reasons=GAPI_DRIVE_THROW_REASONS+[GAPI_FILE_NOT_FOUND],
                                fileId=targetFolderId, fields=u'id,{0},ownedByMe,mimeType'.format(DRIVE_FILE_NAME))
        if targetFolder[u'mimeType'] != MIMETYPE_GA_FOLDER:
          CLArgs.SetLocation(targetFolderIdLocation)
          usageErrorExit(formatKeyValueList(Indent.Spaces(),
                                            [Entity.Singular(Entity.USER), targetUser,
                                             Entity.Singular(Entity.DRIVE_FOLDER_ID), targetFolderId,
                                             PHRASE_NOT_AN_ENTITY.format(Entity.Singular(Entity.DRIVE_FOLDER))],
                                            u'\n'))
        if not targetFolder[u'ownedByMe']:
          CLArgs.SetLocation(targetFolderIdLocation)
          usageErrorExit(formatKeyValueList(Indent.Spaces(),
                                            [Entity.Singular(Entity.USER), targetUser,
                                             Entity.Singular(Entity.DRIVE_FOLDER_ID), targetFolderId,
                                             PHRASE_NOT_OWNED_BY.format(targetUser)],
                                            u'\n'))
        targetFolderName = targetFolder[DRIVE_FILE_NAME]
      elif targetFolderName:
        result = callGAPIpages(targetDrive.files(), u'list', DRIVE_FILES_LIST,
                               throw_reasons=GAPI_DRIVE_THROW_REASONS,
                               q=ME_IN_OWNERS_AND+u"mimeType = '{0}' and {1} = '{2}'".format(MIMETYPE_GA_FOLDER, DRIVE_FILE_NAME, targetFolderName),
                               fields=u'nextPageToken,{0}(id)'.format(DRIVE_FILES_LIST))
        if len(result) == 0:
          CLArgs.SetLocation(targetFolderNameLocation)
          usageErrorExit(formatKeyValueList(Indent.Spaces(),
                                            [Entity.Singular(Entity.USER), targetUser,
                                             Entity.Singular(Entity.DRIVE_FOLDER), targetFolderName,
                                             PHRASE_DOES_NOT_EXIST],
                                            u'\n'))
        targetFolderId = result[0][u'id']
  except GAPI_fileNotFound:
    CLArgs.SetLocation(targetFolderIdLocation)
    usageErrorExit(formatKeyValueList(Indent.Spaces(),
                                      [Entity.Singular(Entity.USER), targetUser,
                                       Entity.Singular(Entity.DRIVE_FOLDER_ID), targetFolderId,
                                       PHRASE_DOES_NOT_EXIST],
                                      u'\n'))
  except (GAPI_serviceNotAvailable, GAPI_authError):
    entityServiceNotApplicableWarning(Entity.TARGET_USER, targetUser)
    return
  targetPermissionsBody = {u'role': u'owner', u'type': u'user', DRIVE_PERMISSIONS_GROUP_USER_TYPE_VALUE: targetUser}
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    sourceUser, sourceDrive = buildGAPIServiceObject(DRIVE_API, user)
    if not sourceDrive:
      continue
    sourceUserName, _ = splitEmailAddress(sourceUser)
    try:
      result = callGAPI(sourceDrive.about(), u'get',
                        throw_reasons=GAPI_DRIVE_THROW_REASONS,
                        fields=u'quotaBytesTotal,quotaBytesUsed,permissionId,rootFolderId')
      sourceDriveSize = int(result[u'quotaBytesUsed'])
      sourcePermissionId = result[u'permissionId']
      sourceRoot = result[u'rootFolderId']
      if targetDriveFree < sourceDriveSize:
        printWarningMessage(TARGET_DRIVE_SPACE_ERROR_RC,
                            u'{0} {1}'.format(MESSAGE_NO_TRANSFER_LACK_OF_DISK_SPACE,
                                              formatKeyValueList(u'',
                                                                 [u'Source drive size', formatFileSize(sourceDriveSize),
                                                                  u'Target drive free', formatFileSize(targetDriveFree)],
                                                                 u'')))
        continue
      printKeyValueList([u'Source drive size', formatFileSize(sourceDriveSize),
                         u'Target drive free', formatFileSize(targetDriveFree)])
      targetDriveFree = targetDriveFree - sourceDriveSize # prep targetDriveFree for next user
      printGettingAllEntityItemsForWhom(Entity.DRIVE_FILE_OR_FOLDER, entityTypeName(Entity.SOURCE_USER, user), i, count)
      page_message = getPageMessageForWhom()
      sourceDriveFiles = callGAPIpages(sourceDrive.files(), u'list', DRIVE_FILES_LIST,
                                       page_message=page_message,
                                       throw_reasons=GAPI_DRIVE_THROW_REASONS,
                                       q=u"trashed = false", orderBy=orderBy,
                                       fields=u'nextPageToken,{0}(id,{1},{2},mimeType,ownedByMe)'.format(DRIVE_FILES_LIST, DRIVE_FILE_NAME, DRIVE_PARENTS_ID),
                                       maxResults=GC_Values[GC_DRIVE_MAX_RESULTS])
      targetUserFolderName = targetUserFolderPattern.replace(u'#user#', sourceUser)
      targetUserFolderName = targetUserFolderName.replace(u'#email#', sourceUser)
      targetUserFolderName = targetUserFolderName.replace(u'#username#', sourceUserName)
      result = callGAPIpages(targetDrive.files(), u'list', DRIVE_FILES_LIST,
                             throw_reasons=GAPI_DRIVE_THROW_REASONS,
                             q=ME_IN_OWNERS_AND+u"mimeType = '{0}' and {1} = '{2}' and '{3}' in parents".format(MIMETYPE_GA_FOLDER, DRIVE_FILE_NAME, targetUserFolderName, targetFolderId),
                             fields=u'nextPageToken,{0}(id)'.format(DRIVE_FILES_LIST))
      if len(result) > 0:
        targetParentId = result[0][u'id']
      else:
        targetParentId = callGAPI(targetDrive.files(), DRIVE_CREATE_FILE,
                                  throw_reasons=GAPI_DRIVE_THROW_REASONS,
                                  body={u'parents': [{u'id': targetFolderId}], DRIVE_FILE_NAME: targetUserFolderName, u'mimeType': MIMETYPE_GA_FOLDER}, fields=u'id')[u'id']
      targetUserFolderName = os.path.join(targetFolderName, targetUserFolderName)
      fileTree = buildFileTree(sourceDriveFiles, sourceDrive)
      Indent.Increment()
      _transferDriveFiles(fileTree[sourceRoot], sourceRoot)
      _transferDriveFiles(fileTree[u'orphans'], u'orphans')
      Indent.Decrement()
    except (GAPI_serviceNotAvailable, GAPI_authError):
      entityServiceNotApplicableWarning(Entity.USER, sourceUser, i, count)

def validateUserGetPermissionId(user):
  _, drive = buildGAPIServiceObject(DRIVE_API, user)
  if drive:
    try:
      return callGAPI(drive.permissions(), u'getIdForEmail',
                      throw_reasons=GAPI_DRIVE_THROW_REASONS,
                      email=user, fields=u'id')[u'id']
    except (GAPI_serviceNotAvailable, GAPI_authError):
      entityServiceNotApplicableWarning(Entity.USER, user)
  return None

# gam <UserTypeEntity> transfer ownership <DriveFileEntity> <UserItem> [includetrashed] (orderby <DriveOrderByFieldName> [ascending|descending])* [preview] [filepath] [todrive [<ToDriveAttributes>]]
def transferDriveFileOwnership(users):

  def _identifyFilesToTransfer(fileEntry, trashed):
    for childId in fileEntry[u'children']:
      childEntry = fileTree.get(childId)
      if childEntry:
        childEntryInfo = childEntry[u'info']
        if trashed or not childEntryInfo[u'labels'][u'trashed']:
          if childEntryInfo[u'ownedByMe']:
            filesToTransfer[childId] = {u'name': childEntryInfo[DRIVE_FILE_NAME], u'type': [Entity.DRIVE_FILE, Entity.DRIVE_FOLDER][childEntryInfo[u'mimeType'] == MIMETYPE_GA_FOLDER]}
          if childEntryInfo[u'mimeType'] == MIMETYPE_GA_FOLDER:
            _identifyFilesToTransfer(childEntry, trashed)

  fileIdEntity = getDriveFileEntity()
  body, parameters = initializeDriveFileAttributes()
  newOwner = getEmailAddress()
  orderByList = []
  csvFormat = filepath = trashed = False
  todrive = {}
  fileTree = None
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'includetrashed':
      trashed = True
    elif myarg == u'orderby':
      fieldName = getChoice(DRIVEFILE_ORDERBY_CHOICES_MAP, mapChoice=True)
      if getChoice(SORTORDER_CHOICES_MAP, defaultChoice=None, mapChoice=True) != u'DESCENDING':
        orderByList.append(fieldName)
      else:
        orderByList.append(u'{0} desc'.format(fieldName))
    elif myarg == u'preview':
      csvFormat = True
    elif myarg == u'filepath':
      filepath = True
    elif myarg == u'todrive':
      todrive = getTodriveParameters()
    else:
      unknownArgumentExit()
  Action.Set(Action.TRANSFER_OWNERSHIP)
  permissionId = validateUserGetPermissionId(newOwner)
  if not permissionId:
    return
  orderBy = u','.join(orderByList) if orderByList else None
  if csvFormat:
    titles, csvRows = initializeTitlesCSVfile([u'OldOwner', u'NewOwner', u'type', u'id', DRIVE_FILE_NAME])
    if filepath:
      addTitlesToCSVfile([u'paths',], titles)
  else:
    filepath = False
  body = {u'role': u'owner'}
  bodyAdd = {u'role': u'writer', u'type': u'user', DRIVE_PERMISSIONS_GROUP_USER_TYPE_VALUE: newOwner}
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, body, parameters, entityType=Entity.DRIVE_FOLDER)
    if jcount == 0:
      continue
    if filepath:
      filePathInfo = initFilePathInfo()
    try:
      printGettingAllEntityItemsForWhom(Entity.DRIVE_FILE_OR_FOLDER, user, i, count)
      page_message = getPageMessageForWhom()
      feed = callGAPIpages(drive.files(), u'list', DRIVE_FILES_LIST,
                           page_message=page_message,
                           throw_reasons=GAPI_DRIVE_THROW_REASONS,
                           orderBy=orderBy, fields=u'nextPageToken,{0}(id,{1},{2},mimeType,ownedByMe,labels(trashed))'.format(DRIVE_FILES_LIST, DRIVE_FILE_NAME, DRIVE_PARENTS_ID),
                           maxResults=GC_Values[GC_DRIVE_MAX_RESULTS])
    except (GAPI_serviceNotAvailable, GAPI_authError):
      entityServiceNotApplicableWarning(Entity.USER, user, i, count)
      continue
    fileTree = buildFileTree(feed, drive)
    Indent.Increment()
    j = 0
    for fileId in fileIdEntity[u'list']:
      j += 1
      try:
        fileEntryInfo = callGAPI(drive.files(), u'get',
                                 throw_reasons=GAPI_DRIVE_THROW_REASONS+[GAPI_FILE_NOT_FOUND],
                                 fileId=fileId, fields=u'id,{0},{1},mimeType,ownedByMe,labels(trashed)'.format(DRIVE_FILE_NAME, DRIVE_PARENTS_ID))
      except GAPI_fileNotFound:
        entityActionFailedWarning([Entity.USER, user, Entity.DRIVE_FILE_OR_FOLDER, fileId], PHRASE_NOT_FOUND, j, jcount)
        continue
      except (GAPI_serviceNotAvailable, GAPI_authError):
        entityServiceNotApplicableWarning(Entity.USER, user, i, count)
        break
      entityType = [Entity.DRIVE_FILE, Entity.DRIVE_FOLDER][fileEntryInfo[u'mimeType'] == MIMETYPE_GA_FOLDER]
      entityPerformActionItemValue([Entity.USER, user], entityType, u'{0} ({1})'.format(fileEntryInfo[DRIVE_FILE_NAME], fileId), j, jcount)
      filesToTransfer = {}
      if trashed or not fileEntryInfo[u'labels'][u'trashed']:
        if fileEntryInfo[u'ownedByMe']:
          filesToTransfer[fileId] = {u'name': fileEntryInfo[DRIVE_FILE_NAME], u'type': entityType}
        if fileEntryInfo[u'mimeType'] == MIMETYPE_GA_FOLDER:
          fileEntry = fileTree.get(fileEntryInfo[u'id'])
          if fileEntry:
            _identifyFilesToTransfer(fileEntry, trashed)
      if csvFormat:
        for xferFileId, fileInfo in filesToTransfer.items():
          row = {u'OldOwner': user, u'NewOwner': newOwner, u'type': Entity.Singular(fileInfo[u'type']), u'id': xferFileId, DRIVE_FILE_NAME: fileInfo[u'name']}
          if filepath:
            addFilePathsToRow(drive, fileTree, fileTree[xferFileId][u'info'], filePathInfo, row, titles)
          csvRows.append(row)
        continue
      Indent.Increment()
      kcount = len(filesToTransfer)
      entityPerformActionNumItemsModifier([Entity.USER, user], kcount, Entity.DRIVE_FILE_OR_FOLDER, u'{0} {1}: {2}'.format(Action.MODIFIER_TO, Entity.Singular(Entity.USER), newOwner), i, count)
      Indent.Increment()
      k = 0
      for xferFileId in filesToTransfer:
        k += 1
        entityType = filesToTransfer[xferFileId][u'type']
        fileDesc = u'{0} ({1})'.format(filesToTransfer[xferFileId][u'name'], xferFileId)
        try:
          callGAPI(drive.permissions(), DRIVE_PATCH_PERMISSIONS,
                   throw_reasons=GAPI_DRIVE_THROW_REASONS+[GAPI_FILE_NOT_FOUND, GAPI_PERMISSION_NOT_FOUND],
                   fileId=xferFileId, permissionId=permissionId, transferOwnership=True, body=body, fields=u'')
          entityModifierNewValueItemValueActionPerformed([Entity.USER, user, entityType, fileDesc], Action.MODIFIER_TO, None, Entity.USER, newOwner, k, kcount)
        except GAPI_permissionNotFound:
          # this might happen if target user isn't explicitly in ACL (i.e. shared with anyone)
          try:
            callGAPI(drive.permissions(), DRIVE_CREATE_PERMISSIONS,
                     throw_reasons=GAPI_DRIVE_THROW_REASONS+[GAPI_INVALID_SHARING_REQUEST, GAPI_FILE_NOT_FOUND],
                     fileId=xferFileId, sendNotificationEmails=False, body=bodyAdd, fields=u'')
            callGAPI(drive.permissions(), DRIVE_PATCH_PERMISSIONS,
                     throw_reasons=GAPI_DRIVE_THROW_REASONS+[GAPI_FILE_NOT_FOUND, GAPI_PERMISSION_NOT_FOUND],
                     fileId=xferFileId, permissionId=permissionId, transferOwnership=True, body=body, fields=u'')
            entityModifierNewValueItemValueActionPerformed([Entity.USER, user, entityType, fileDesc], Action.MODIFIER_TO, None, Entity.USER, newOwner, k, kcount)
          except GAPI_invalidSharingRequest as e:
            entityActionFailedWarning([Entity.USER, user, entityType, fileDesc], entityTypeNameMessage(Entity.PERMISSION_ID, permissionId, e.message), k, kcount)
          except GAPI_permissionNotFound:
            entityDoesNotHaveItemWarning([Entity.USER, user, entityType, fileDesc, Entity.PERMISSION_ID, permissionId], k, kcount)
          except GAPI_fileNotFound:
            entityActionFailedWarning([Entity.USER, user, entityType, fileDesc], PHRASE_DOES_NOT_EXIST, k, kcount)
          except (GAPI_serviceNotAvailable, GAPI_authError):
            entityServiceNotApplicableWarning(Entity.USER, user, i, count)
        except GAPI_fileNotFound:
          entityActionFailedWarning([Entity.USER, user, entityType, fileDesc], PHRASE_DOES_NOT_EXIST, j, jcount)
        except (GAPI_serviceNotAvailable, GAPI_authError):
          entityServiceNotApplicableWarning(Entity.USER, user, i, count)
          break
      Indent.Decrement()
      Indent.Decrement()
    Indent.Decrement()
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Files to Transfer Ownership', todrive)

# gam <UserTypeEntity> claim ownership <DriveFileEntity> [skipids <DriveFileEntity>] [skipusers <UserTypeEntity>] [subdomains <DomainNameEntity>] [includetrashed] [restricted] [writerscantshare] [preview] [filepath] [todrive [<ToDriveAttributes>]]
def claimDriveFolderOwnership(users):
  def _identifyFilesToClaim(fileEntry, skipids, skipusers, trashed):
    for childId in fileEntry[u'children']:
      childEntry = fileTree.get(childId)
      if childEntry:
        childEntryInfo = childEntry[u'info']
        if childId not in skipids and (trashed or not childEntryInfo[u'labels'][u'trashed']):
          owner = childEntryInfo[u'owners'][0][u'emailAddress']
          if not childEntryInfo[u'ownedByMe'] and owner not in skipusers:
            filesToClaim.setdefault(owner, {})
            if childId not in filesToClaim[owner]:
              filesToClaim[owner][childId] = {u'name': childEntryInfo[DRIVE_FILE_NAME], u'type': [Entity.DRIVE_FILE, Entity.DRIVE_FOLDER][childEntryInfo[u'mimeType'] == MIMETYPE_GA_FOLDER]}
          if childEntryInfo[u'mimeType'] == MIMETYPE_GA_FOLDER:
            _identifyFilesToClaim(childEntry, skipids, skipusers, trashed)

  fileIdEntity = getDriveFileEntity()
  skipFileIdEntity = initDriveFileEntity()
  body, parameters = initializeDriveFileAttributes()
  skipbody, skipparameters = initializeDriveFileAttributes()
  skipusers = []
  subdomains = []
  csvFormat = filepath = trashed = False
  todrive = {}
  restricted = False
  writersCanShare = True
  fileTree = None
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'skipids':
      skipFileIdEntity = getDriveFileEntity()
    elif myarg == u'skipusers':
      _, skipusers = getEntityToModify(defaultEntityType=CL_ENTITY_USERS)
    elif myarg == u'subdomains':
      subdomains = getEntityList(OB_DOMAIN_NAME_ENTITY)
    elif myarg == u'includetrashed':
      trashed = True
    elif myarg == u'restricted':
      restricted = True
    elif myarg == u'writerscantshare':
      writersCanShare = False
    elif myarg == u'preview':
      csvFormat = True
    elif myarg == u'filepath':
      filepath = True
    elif myarg == u'todrive':
      todrive = getTodriveParameters()
    else:
      unknownArgumentExit()
  Action.Set(Action.CLAIM_OWNERSHIP)
  if csvFormat:
    titles, csvRows = initializeTitlesCSVfile([u'NewOwner', u'OldOwner', u'type', u'id', DRIVE_FILE_NAME])
    if filepath:
      addTitlesToCSVfile([u'paths',], titles)
  else:
    filepath = False
  body = {u'role': u'owner'}
  bodyShare = {}
  if not writersCanShare:
    bodyShare[u'writersCanShare'] = False
  if restricted:
    bodyShare[u'labels'][DRIVE_FILE_LABEL_RESTRICTED] = True
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, body, parameters)
    if not drive:
      continue
    permissionId = validateUserGetPermissionId(user)
    if not permissionId:
      continue
    entityPerformActionNumItems([Entity.USER, user], jcount, Entity.DRIVE_FILE_OR_FOLDER, i, count)
    if jcount == 0:
      continue
    if filepath:
      filePathInfo = initFilePathInfo()
    bodyAdd = {u'role': u'writer', u'type': u'user', DRIVE_PERMISSIONS_GROUP_USER_TYPE_VALUE: user}
    if skipFileIdEntity[u'query'] or skipFileIdEntity[u'root']:
      _validateUserGetFileIDs(origUser, i, count, skipFileIdEntity, skipbody, skipparameters, drive=drive)
    try:
      printGettingAllEntityItemsForWhom(Entity.DRIVE_FILE_OR_FOLDER, user, i, count)
      page_message = getPageMessageForWhom()
      feed = callGAPIpages(drive.files(), u'list', DRIVE_FILES_LIST,
                           page_message=page_message,
                           throw_reasons=GAPI_DRIVE_THROW_REASONS,
                           fields=u'nextPageToken,{0}(id,{1},{2},mimeType,ownedByMe,owners(emailAddress),labels(trashed))'.format(DRIVE_FILES_LIST, DRIVE_FILE_NAME, DRIVE_PARENTS_ID),
                           maxResults=GC_Values[GC_DRIVE_MAX_RESULTS])
    except (GAPI_serviceNotAvailable, GAPI_authError):
      entityServiceNotApplicableWarning(Entity.USER, user, i, count)
      continue
    fileTree = buildFileTree(feed, drive)
    Indent.Increment()
    j = 0
    for fileId in fileIdEntity[u'list']:
      j += 1
      filesToClaim = {}
      fileEntry = fileTree.get(fileId)
      if not fileEntry:
        entityActionFailedWarning([Entity.USER, user, Entity.DRIVE_FILE_OR_FOLDER, fileId], PHRASE_NOT_FOUND, j, jcount)
        continue
      fileEntryInfo = fileEntry[u'info']
      entityType = [Entity.DRIVE_FILE, Entity.DRIVE_FOLDER][fileEntryInfo[u'mimeType'] == MIMETYPE_GA_FOLDER]
      fileDesc = u'{0} ({1})'.format(fileEntryInfo[DRIVE_FILE_NAME], fileId)
      entityPerformActionItemValue([Entity.USER, user], entityType, fileDesc, j, jcount)
      if not fileEntryInfo[u'ownedByMe'] and fileId not in skipFileIdEntity[u'list']:
        owner = fileEntryInfo[u'owners'][0][u'emailAddress']
        if trashed or not fileEntryInfo[u'labels'][u'trashed'] and owner not in skipusers:
          filesToClaim.setdefault(owner, {})
          if fileId not in filesToClaim[owner]:
            filesToClaim[owner][fileId] = {u'name': fileEntryInfo[DRIVE_FILE_NAME], u'type': entityType}
      _identifyFilesToClaim(fileEntry, skipFileIdEntity[u'list'], skipusers, trashed)
      if csvFormat:
        for oldOwner in filesToClaim:
          for claimFileId, fileInfo in filesToClaim[oldOwner].items():
            row = {u'NewOwner': user, u'OldOwner': oldOwner, u'type': Entity.Singular(fileInfo[u'type']), u'id': claimFileId, DRIVE_FILE_NAME: fileInfo[u'name']}
            if filepath:
              addFilePathsToRow(drive, fileTree, fileTree[claimFileId][u'info'], filePathInfo, row, titles)
            csvRows.append(row)
        continue
      Indent.Increment()
      kcount = len(filesToClaim)
      entityPerformActionNumItems([Entity.USER, user], kcount, Entity.USER, i, count)
      Indent.Increment()
      k = 0
      for oldOwner in filesToClaim:
        k += 1
        _, userdomain = splitEmailAddress(oldOwner)
        lcount = len(filesToClaim[oldOwner])
        if userdomain == GC_Values[GC_DOMAIN] or userdomain in subdomains:
          _, source_drive = buildGAPIServiceObject(DRIVE_API, oldOwner)
          entityPerformActionNumItemsModifier([Entity.USER, user], lcount, Entity.DRIVE_FILE_OR_FOLDER, u'{0} {1}: {2}'.format(Action.MODIFIER_FROM, Entity.Singular(Entity.USER), oldOwner), k, kcount)
          Indent.Increment()
          l = 0
          for fileId, fileInfo in filesToClaim[oldOwner].items():
            l += 1
            if bodyShare:
              callGAPI(source_drive.files(), u'patch',
                       fileId=fileId, body=bodyShare, fields=u'')
            entityType = fileInfo[u'type']
            fileDesc = u'{0} ({1})'.format(fileInfo[u'name'], fileId)
            try:
              callGAPI(source_drive.permissions(), DRIVE_PATCH_PERMISSIONS,
                       throw_reasons=GAPI_DRIVE_THROW_REASONS+[GAPI_FILE_NOT_FOUND, GAPI_PERMISSION_NOT_FOUND],
                       fileId=fileId, permissionId=permissionId, transferOwnership=True, body=body, fields=u'')
              entityModifierNewValueItemValueActionPerformed([Entity.USER, user, entityType, fileDesc], Action.MODIFIER_FROM, None, Entity.USER, oldOwner, l, lcount)
            except GAPI_permissionNotFound:
              # if claimer not in ACL (file might be visible for all with link)
              try:
                Action.Set(Action.ADD)
                callGAPI(source_drive.permissions(), DRIVE_CREATE_PERMISSIONS,
                         throw_reasons=GAPI_DRIVE_THROW_REASONS+[GAPI_INVALID_SHARING_REQUEST, GAPI_FILE_NOT_FOUND],
                         fileId=fileId, sendNotificationEmails=False, body=bodyAdd, fields=u'')
                entityActionPerformed([Entity.USER, user, entityType, fileDesc, Entity.PERMISSION_ID, permissionId], l, lcount)
                Action.Set(Action.CLAIM_OWNERSHIP)
                callGAPI(source_drive.permissions(), DRIVE_PATCH_PERMISSIONS,
                         throw_reasons=GAPI_DRIVE_THROW_REASONS+[GAPI_FILE_NOT_FOUND, GAPI_PERMISSION_NOT_FOUND],
                         fileId=fileId, permissionId=permissionId, transferOwnership=True, body=body, fields=u'')
                entityModifierNewValueItemValueActionPerformed([Entity.USER, user, entityType, fileDesc], Action.MODIFIER_FROM, None, Entity.USER, oldOwner, l, lcount)
              except GAPI_invalidSharingRequest as e:
                entityActionFailedWarning([Entity.USER, user, entityType, fileDesc], entityTypeNameMessage(Entity.PERMISSION_ID, permissionId, e.message), l, lcount)
              except GAPI_permissionNotFound:
                entityDoesNotHaveItemWarning([Entity.USER, user, entityType, fileDesc, Entity.PERMISSION_ID, permissionId], l, lcount)
              except GAPI_fileNotFound:
                entityActionFailedWarning([Entity.USER, user, entityType, fileDesc], PHRASE_DOES_NOT_EXIST, l, lcount)
              except (GAPI_serviceNotAvailable, GAPI_authError):
                entityServiceNotApplicableWarning(Entity.USER, user, i, count)
            except GAPI_fileNotFound:
              entityActionFailedWarning([Entity.USER, user, entityType, fileDesc], PHRASE_DOES_NOT_EXIST, l, lcount)
            except (GAPI_serviceNotAvailable, GAPI_authError):
              entityServiceNotApplicableWarning(Entity.USER, user, i, count)
              break
          Indent.Decrement()
        else:
          entityPerformActionModifierNumItemsModifier([Entity.USER, user], u'Not Performed', kcount, Entity.DRIVE_FILE_OR_FOLDER, u'{0} {1}: {2}'.format(Action.MODIFIER_FROM, Entity.Singular(Entity.USER), oldOwner), j, jcount)
          Indent.Increment()
          l = 0
          for fileId, fileInfo in filesToClaim[oldOwner].items():
            l += 1
            entityActionNotPerformedWarning([Entity.USER, user, fileInfo[u'type'], u'{0} ({1})'.format(fileInfo[u'name'], fileId)],
                                            PHRASE_USER_IN_OTHER_DOMAIN.format(Entity.Singular(Entity.USER), oldOwner), l, lcount)
          Indent.Decrement()
      Indent.Decrement()
      Indent.Decrement()
    Indent.Decrement()
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Files to Claim Ownership', todrive)

# gam <UserTypeEntity> delete emptydrivefolders
def deleteEmptyDriveFolders(users):
  checkForExtraneousArguments()
  Action.Set(Action.DELETE_EMPTY)
  query = ME_IN_OWNERS_AND+u"mimeType = '{0}'".format(MIMETYPE_GA_FOLDER)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive = buildGAPIServiceObject(DRIVE_API, user)
    if not drive:
      continue
    try:
      printEntityKVList([Entity.USER, user],
                        [u'{0} {1}'.format(Action.ToPerform(), Entity.Plural(Entity.DRIVE_FILE_OR_FOLDER))],
                        i, count)
      Indent.Increment()
      deleted_empty = True
      while deleted_empty:
        printGettingAllEntityItemsForWhom(Entity.DRIVE_FOLDER, user, i, count)
        page_message = getPageMessageForWhom()
        feed = callGAPIpages(drive.files(), u'list', DRIVE_FILES_LIST,
                             page_message=page_message,
                             throw_reasons=GAPI_DRIVE_THROW_REASONS,
                             q=query, fields=u'nextPageToken,{0}(id,{1})'.format(DRIVE_FILES_LIST, DRIVE_FILE_NAME), maxResults=GC_Values[GC_DRIVE_MAX_RESULTS])
        deleted_empty = False
        for folder in feed:
          children = callGAPI(drive.children(), u'list',
                              throw_reasons=GAPI_DRIVE_THROW_REASONS,
                              folderId=folder[u'id'], fields=u'{0}(id)'.format(DRIVE_FILES_LIST), maxResults=1)
          if (not children) or (DRIVE_FILES_LIST not in children) or (len(children[DRIVE_FILES_LIST]) == 0):
            callGAPI(drive.files(), u'delete',
                     fileId=folder[u'id'])
            entityActionPerformed([Entity.USER, user, Entity.DRIVE_FOLDER, folder[DRIVE_FILE_NAME]], i, count)
            deleted_empty = True
          else:
            entityActionNotPerformedWarning([Entity.USER, user, Entity.DRIVE_FOLDER, folder[DRIVE_FILE_NAME]],
                                            u'{0} - {1}'.format(PHRASE_CONTAINS_AT_LEAST_1_ITEM, children[DRIVE_FILES_LIST][0][u'id']), i, count)
    except (GAPI_serviceNotAvailable, GAPI_authError):
      entityServiceNotApplicableWarning(Entity.USER, user, i, count)
      break
    Indent.Decrement()

# gam <UserTypeEntity> empty drivetrash
def emptyDriveTrash(users):
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive = buildGAPIServiceObject(DRIVE_API, user)
    if not drive:
      continue
    try:
      callGAPI(drive.files(), u'emptyTrash',
               throw_reasons=GAPI_DRIVE_THROW_REASONS)
      entityActionPerformed([Entity.USER, user, Entity.DRIVE_TRASH, None], i, count)
    except (GAPI_serviceNotAvailable, GAPI_authError):
      entityServiceNotApplicableWarning(Entity.USER, user, i, count)

DRIVEFILE_ACL_TIME_OBJECTS = [DRIVE_PERMISSIONS_EXPIRATION_DATE_TIME]

# DriveFileACL commands utilities
def _showDriveFilePermission(permission):
  if DRIVE_PERMISSIONS_NAME in permission:
    printKeyValueList([permission[DRIVE_PERMISSIONS_NAME]])
  elif u'id' in permission:
    if permission[u'id'] == u'anyone':
      printKeyValueList([u'Anyone'])
    elif permission[u'id'] == u'anyoneWithLink':
      printKeyValueList([u'Anyone with Link'])
    else:
      printKeyValueList([permission[u'id']])
  Indent.Increment()
  _convertReaderToCommenter(permission)
  for key in permission:
    if key not in [u'kind', u'etag', u'selfLink', DRIVE_PERMISSIONS_NAME]:
      if key not in DRIVEFILE_ACL_TIME_OBJECTS:
        if key != u'additionalRoles':
          printKeyValueList([key, permission[key]])
        else:
          printKeyValueList([key, u','.join(permission[key])])
      else:
        printKeyValueList([key, formatLocalTime(permission[key])])
  Indent.Decrement()
#
DRIVEFILE_ACL_ROLES_MAP = {
  u'commenter': u'commenter',
  u'editor': u'writer',
  u'owner': u'owner',
  u'read': u'reader',
  u'reader': u'reader',
  u'writer': u'writer',
  }

DRIVEFILE_ACL_PERMISSION_TYPES = [u'anyone', u'domain', u'group', u'user',] # anyone must be first element

# gam <UserTypeEntity> add drivefileacl <DriveFileEntity> anyone|(user <UserItem>)|(group <GroupItem>)|(domain <DomainName>)
#	(role reader|commenter|writer|owner|editor) [withlink|(allowfilediscovery <Boolean>)] [expiration <Time>] [transferownership <Boolean>] [sendmail] [emailmessage <String>] [showtitles]
def addDriveFileACL(users):
  sendNotificationEmails = showTitles = transferOwnership = False
  emailMessage = None
  fileIdEntity = getDriveFileEntity()
  body, parameters = initializeDriveFileAttributes()
  body[u'type'] = getChoice(DRIVEFILE_ACL_PERMISSION_TYPES)
  if body[u'type'] != u'anyone':
    if body[u'type'] != u'domain':
      body[DRIVE_PERMISSIONS_GROUP_USER_TYPE_VALUE] = permissionId = getEmailAddress()
    else:
      body[DRIVE_PERMISSIONS_DOMAIN_TYPE_VALUE] = permissionId = getString(OB_DOMAIN_NAME)
  else:
    permissionId = u'anyone'
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'withlink':
      body[u'withLink'] = True
    elif myarg == u'allowfilediscovery':
      body[u'withLink'] = not getBoolean()
    elif myarg == u'role':
      roleLocation = CLArgs.Location()
      _setRoleConvertCommenterToReader(body, getChoice(DRIVEFILE_ACL_ROLES_MAP, mapChoice=True))
    elif myarg == u'expiration':
      body[DRIVE_PERMISSIONS_EXPIRATION_DATE_TIME] = getFullTime()
    elif myarg == u'sendemail':
      sendNotificationEmails = True
    elif myarg == u'emailmessage':
      sendNotificationEmails = True
      emailMessage = getString(OB_STRING)
    elif myarg == u'transferownership':
      transferOwnership = getBoolean()
    elif myarg == u'showtitles':
      showTitles = True
    else:
      unknownArgumentExit()
  if u'role' not in body:
    missingArgumentExit(u'role {0}'.format(formatChoiceList(DRIVEFILE_ACL_ROLES_MAP)))
  if body[u'role'] == u'owner' and body[u'type'] != u'user':
    CLArgs.SetLocation(roleLocation)
    usageErrorExit(PHRASE_INVALID_OWNER_TYPE.format(body[u'role'], body[u'type']))
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, body, parameters, entityType=Entity.DRIVE_FILE_OR_FOLDER_ACL)
    if jcount == 0:
      continue
    Indent.Increment()
    j = 0
    for fileId in fileIdEntity[u'list']:
      j += 1
      try:
        fileName = fileId
        entityType = Entity.DRIVE_FILE_OR_FOLDER_ID
        if showTitles:
          result = callGAPI(drive.files(), u'get',
                            throw_reasons=GAPI_DRIVE_THROW_REASONS+[GAPI_FILE_NOT_FOUND, GAPI_FORBIDDEN, GAPI_INTERNAL_ERROR],
                            fileId=fileId, fields=DRIVE_FILE_NAME)
          if result and DRIVE_FILE_NAME in result:
            entityType = Entity.DRIVE_FILE_OR_FOLDER
            fileName = result[DRIVE_FILE_NAME]+u'('+fileId+u')'
        permission = callGAPI(drive.permissions(), DRIVE_CREATE_PERMISSIONS,
                              throw_reasons=GAPI_DRIVE_THROW_REASONS+[GAPI_FILE_NOT_FOUND, GAPI_FORBIDDEN, GAPI_INTERNAL_ERROR, GAPI_INVALID_SHARING_REQUEST],
                              fileId=fileId, sendNotificationEmails=sendNotificationEmails, emailMessage=emailMessage,
                              transferOwnership=transferOwnership, body=body)
        entityActionPerformed([Entity.USER, user, entityType, fileName, Entity.PERMISSION_ID, permissionId], j, jcount)
        _showDriveFilePermission(permission)
      except (GAPI_fileNotFound, GAPI_forbidden, GAPI_internalError) as e:
        entityActionFailedWarning([Entity.USER, user, entityType, fileName], e.message, j, jcount)
      except (GAPI_invalidSharingRequest) as e:
        entityActionFailedWarning([Entity.USER, user, entityType, fileName], entityTypeNameMessage(Entity.PERMISSION_ID, permissionId, e.message), j, jcount)
      except (GAPI_serviceNotAvailable, GAPI_authError):
        entityServiceNotApplicableWarning(Entity.USER, user, i, count)
        break
    Indent.Decrement()

# gam <UserTypeEntity> update drivefileacl <DriveFileEntity> <DriveFilePermissionIDorEmail>
#	(role reader|commenter|writer|owner|editor) [withlink|(allowfilediscovery <Boolean>)] [expiration <Time>] [removeexpiration <Boolean>] [transferownership <Boolean>] [showtitles]
def updateDriveFileACLs(users):
  fileIdEntity = getDriveFileEntity()
  body, parameters = initializeDriveFileAttributes()
  isEmail, permissionId = getPermissionId()
  removeExpiration = transferOwnership = False
  showTitles = False
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'withlink':
      body[u'withLink'] = True
    elif myarg == u'allowfilediscovery':
      body[u'withLink'] = not getBoolean()
    elif myarg == u'role':
      _setRoleConvertCommenterToReader(body, getChoice(DRIVEFILE_ACL_ROLES_MAP, mapChoice=True))
    elif myarg == u'expiration':
      body[DRIVE_PERMISSIONS_EXPIRATION_DATE_TIME] = getFullTime()
    elif myarg == u'removeexpiration':
      removeExpiration = getBoolean()
    elif myarg == u'transferownership':
      transferOwnership = getBoolean()
    elif myarg == u'showtitles':
      showTitles = True
    else:
      unknownArgumentExit()
  if removeExpiration is None and u'role' not in body:
    missingArgumentExit(u'role {0}'.format(formatChoiceList(DRIVEFILE_ACL_ROLES_MAP)))
  if isEmail:
    permissionId = validateUserGetPermissionId(permissionId)
    if not permissionId:
      return
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, body, parameters, entityType=Entity.DRIVE_FILE_OR_FOLDER_ACL)
    if jcount == 0:
      continue
    Indent.Increment()
    j = 0
    for fileId in fileIdEntity[u'list']:
      j += 1
      try:
        fileName = fileId
        entityType = Entity.DRIVE_FILE_OR_FOLDER_ID
        if showTitles:
          result = callGAPI(drive.files(), u'get',
                            throw_reasons=GAPI_DRIVE_THROW_REASONS+[GAPI_FILE_NOT_FOUND, GAPI_FORBIDDEN, GAPI_INTERNAL_ERROR],
                            fileId=fileId, fields=DRIVE_FILE_NAME)
          if result and DRIVE_FILE_NAME in result:
            entityType = Entity.DRIVE_FILE_OR_FOLDER
            fileName = result[DRIVE_FILE_NAME]+u'('+fileId+u')'
        permission = callGAPI(drive.permissions(), DRIVE_PATCH_PERMISSIONS,
                              throw_reasons=GAPI_DRIVE_THROW_REASONS+[GAPI_FILE_NOT_FOUND, GAPI_FORBIDDEN, GAPI_INTERNAL_ERROR,
                                                                      GAPI_BAD_REQUEST, GAPI_INVALID_OWNERSHIP_TRANSFER, GAPI_PERMISSION_NOT_FOUND],
                              fileId=fileId, permissionId=permissionId, removeExpiration=removeExpiration,
                              transferOwnership=transferOwnership, body=body)
        entityActionPerformed([Entity.USER, user, entityType, fileName, Entity.PERMISSION_ID, permissionId], j, jcount)
        _showDriveFilePermission(permission)
      except (GAPI_fileNotFound, GAPI_forbidden, GAPI_internalError, GAPI_badRequest, GAPI_invalidOwnershipTransfer) as e:
        entityActionFailedWarning([Entity.USER, user, entityType, fileName], e.message, j, jcount)
      except GAPI_permissionNotFound:
        entityDoesNotHaveItemWarning([Entity.USER, user, entityType, fileName, Entity.PERMISSION_ID, permissionId], j, jcount)
      except (GAPI_serviceNotAvailable, GAPI_authError):
        entityServiceNotApplicableWarning(Entity.USER, user, i, count)
        break
    Indent.Decrement()

# gam <UserTypeEntity> add permissions <DriveFileEntity> <DriveFilePermissionsEntity> [expiration <Time>] [sendmail] [emailmessage <String>]
def addDriveFilePermissions(users):

  def _makePermissionBody(permission):
    body = {}
    try:
      scope, role = permission.split(u';', 1)
      if scope == u'anyone' or scope == u'anyonewithlink':
        body[u'type'] = body[u'id'] = u'anyone'
        body[u'withLink'] = scope == u'anyonewithlink'
      else:
        body[u'type'], value = scope.split(u':', 1)
        if body[u'type'] == u'domainwithlink':
          body[u'withLink'] = True
          body[u'type'] = u'domain'
        if body[u'type'] not in DRIVEFILE_ACL_PERMISSION_TYPES[1:]:
          return None
        if body[u'type'] != u'domain':
          body[DRIVE_PERMISSIONS_GROUP_USER_TYPE_VALUE] = value
        else:
          body[DRIVE_PERMISSIONS_DOMAIN_TYPE_VALUE] = value
      _setRoleConvertCommenterToReader(body, DRIVEFILE_ACL_ROLES_MAP.get(role))
      if not body[u'role']:
        return None
      if expiration:
        body[DRIVE_PERMISSIONS_EXPIRATION_DATE_TIME] = expiration
      return body
    except ValueError:
      return None

  def _callbackAddPermission(request_id, response, exception):
    ri = request_id.splitlines()
    if int(ri[RI_J]) == 1:
      entityPerformActionNumItems([Entity.DRIVE_FILE_OR_FOLDER_ID, ri[RI_ENTITY]], int(ri[RI_JCOUNT]), Entity.PERMITTEE, int(ri[RI_I]), int(ri[RI_COUNT]))
    if exception is None:
      entityActionPerformed([Entity.DRIVE_FILE_OR_FOLDER_ID, ri[RI_ENTITY], Entity.PERMITTEE, ri[RI_ITEM]], int(ri[RI_J]), int(ri[RI_JCOUNT]))
    else:
      http_status, reason, message = checkGAPIError(exception)
      if reason not in GAPI_DEFAULT_RETRY_REASONS+[GAPI_SERVICE_LIMIT]:
        errMsg = getHTTPError({}, http_status, reason, message)
        entityActionFailedWarning([Entity.DRIVE_FILE_OR_FOLDER_ID, ri[RI_ENTITY], Entity.PERMITTEE, ri[RI_ITEM]], errMsg, int(ri[RI_J]), int(ri[RI_JCOUNT]))
        return
      waitOnFailure(1, 10, reason, message)
      try:
        callGAPI(drive.permissions(), DRIVE_CREATE_PERMISSIONS,
                 throw_reasons=GAPI_DRIVE_THROW_REASONS+[GAPI_FILE_NOT_FOUND, GAPI_FORBIDDEN, GAPI_INTERNAL_ERROR, GAPI_INVALID_SHARING_REQUEST], retry_reasons=[GAPI_SERVICE_LIMIT],
                 fileId=ri[RI_ENTITY], sendNotificationEmails=sendNotificationEmails, emailMessage=emailMessage, body=_makePermissionBody(ri[RI_ITEM]), fields=u'')
        entityActionPerformed([Entity.DRIVE_FILE_OR_FOLDER_ID, ri[RI_ENTITY], Entity.PERMITTEE, ri[RI_ITEM]], int(ri[RI_J]), int(ri[RI_JCOUNT]))
      except (GAPI_fileNotFound, GAPI_invalidSharingRequest, GAPI_forbidden, GAPI_serviceNotAvailable, GAPI_authError) as e:
        entityActionFailedWarning([Entity.DRIVE_FILE_OR_FOLDER_ID, ri[RI_ENTITY], Entity.PERMITTEE, ri[RI_ITEM]], e.message, int(ri[RI_J]), int(ri[RI_JCOUNT]))

  sendNotificationEmails = False
  emailMessage = expiration = None
  fileIdEntity = getDriveFileEntity()
  body, parameters = initializeDriveFileAttributes()
  permissions = getEntityList(OB_DRIVE_FILE_PERMISSION_ENTITY)
  permissionsLists = permissions if isinstance(permissions, dict) else None
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'expiration':
      expiration = getFullTime()
    elif myarg == u'sendemail':
      sendNotificationEmails = True
    elif myarg == u'emailmessage':
      sendNotificationEmails = True
      emailMessage = getString(OB_STRING)
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, body, parameters, entityType=Entity.DRIVE_FILE_OR_FOLDER_ACL)
    if jcount == 0:
      continue
    try:
      callGAPI(drive.about(), u'get',
               throw_reasons=GAPI_DRIVE_THROW_REASONS,
               fields=u'')
    except (GAPI_serviceNotAvailable, GAPI_authError):
      entityServiceNotApplicableWarning(Entity.USER, user, i, count)
      continue
    Indent.Increment()
    svcargs = dict([(u'fileId', None), (u'sendNotificationEmails', sendNotificationEmails), (u'emailMessage', emailMessage), (u'body', None), (u'fields', u'')]+GM_Globals[GM_EXTRA_ARGS_LIST])
    dbatch = googleapiclient.http.BatchHttpRequest(callback=_callbackAddPermission)
    bcount = 0
    j = 0
    for fileId in fileIdEntity[u'list']:
      j += 1
      if permissionsLists:
        if not GM_Globals[GM_CSV_SUBKEY_FIELD]:
          permissions = permissionsLists[fileId]
        else:
          permissions = permissionsLists[origUser][fileId]
      kcount = len(permissions)
      if kcount == 0:
        continue
      k = 0
      for permission in permissions:
        k += 1
        svcparms = svcargs.copy()
        svcparms[u'fileId'] = fileId
        svcparms[u'body'] = _makePermissionBody(permission)
        if not svcparms[u'body']:
          entityActionFailedWarning([Entity.DRIVE_FILE_OR_FOLDER_ID, fileId, Entity.PERMITTEE, permission], PHRASE_INVALID, k, kcount)
          continue
        dbatch.add(drive.permissions().insert(**svcparms), request_id=batchRequestID(fileId, j, jcount, k, kcount, permission))
        bcount += 1
        if bcount >= GC_Values[GC_BATCH_SIZE]:
          dbatch.execute()
          dbatch = googleapiclient.http.BatchHttpRequest(callback=_callbackAddPermission)
          bcount = 0
    if bcount > 0:
      dbatch.execute()
    Indent.Decrement()

# gam <UserTypeEntity> delete drivefileacl <DriveFileEntity> <DriveFilePermissionIDorEmail> [showtitles]
def deleteDriveFileACLs(users):
  fileIdEntity = getDriveFileEntity()
  body, parameters = initializeDriveFileAttributes()
  isEmail, permissionId = getPermissionId()
  showTitles = True if checkArgumentPresent(SHOWTITLES_ARGUMENT) else False
  checkForExtraneousArguments()
  if isEmail:
    permissionId = validateUserGetPermissionId(permissionId)
    if not permissionId:
      return
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, body, parameters, entityType=Entity.DRIVE_FILE_OR_FOLDER_ACL)
    if jcount == 0:
      continue
    Indent.Increment()
    j = 0
    for fileId in fileIdEntity[u'list']:
      j += 1
      try:
        fileName = fileId
        entityType = Entity.DRIVE_FILE_OR_FOLDER_ID
        if showTitles:
          result = callGAPI(drive.files(), u'get',
                            throw_reasons=GAPI_DRIVE_THROW_REASONS+[GAPI_FILE_NOT_FOUND, GAPI_FORBIDDEN, GAPI_INTERNAL_ERROR],
                            fileId=fileId, fields=DRIVE_FILE_NAME)
          if result and DRIVE_FILE_NAME in result:
            entityType = Entity.DRIVE_FILE_OR_FOLDER
            fileName = result[DRIVE_FILE_NAME]+u'('+fileId+u')'
        callGAPI(drive.permissions(), u'delete',
                 throw_reasons=GAPI_DRIVE_THROW_REASONS+[GAPI_FILE_NOT_FOUND, GAPI_FORBIDDEN, GAPI_INTERNAL_ERROR, GAPI_BAD_REQUEST, GAPI_PERMISSION_NOT_FOUND],
                 fileId=fileId, permissionId=permissionId)
        entityActionPerformed([Entity.USER, user, entityType, fileName, Entity.PERMISSION_ID, permissionId], j, jcount)
      except (GAPI_fileNotFound, GAPI_forbidden, GAPI_internalError, GAPI_badRequest) as e:
        entityActionFailedWarning([Entity.USER, user, entityType, fileName], e.message, j, jcount)
      except GAPI_permissionNotFound:
        entityDoesNotHaveItemWarning([Entity.USER, user, entityType, fileName, Entity.PERMISSION_ID, permissionId], j, jcount)
      except (GAPI_serviceNotAvailable, GAPI_authError):
        entityServiceNotApplicableWarning(Entity.USER, user, i, count)
        break
    Indent.Decrement()

# gam <UserTypeEntity> delete permissions <DriveFileEntity> <DriveFilePermissionIDEntity>
def deleteDriveFilePermissions(users):

  def _callbackDeletePermissionId(request_id, response, exception):
    ri = request_id.splitlines()
    if int(ri[RI_J]) == 1:
      entityPerformActionNumItems([Entity.DRIVE_FILE_OR_FOLDER_ID, ri[RI_ENTITY]], int(ri[RI_JCOUNT]), Entity.PERMISSION_ID, int(ri[RI_I]), int(ri[RI_COUNT]))
    if exception is None:
      entityActionPerformed([Entity.DRIVE_FILE_OR_FOLDER_ID, ri[RI_ENTITY], Entity.PERMISSION_ID, ri[RI_ITEM]], int(ri[RI_J]), int(ri[RI_JCOUNT]))
    else:
      http_status, reason, message = checkGAPIError(exception)
      if reason not in GAPI_DEFAULT_RETRY_REASONS+[GAPI_SERVICE_LIMIT]:
        if reason == GAPI_PERMISSION_NOT_FOUND:
          entityDoesNotHaveItemWarning([Entity.DRIVE_FILE_OR_FOLDER_ID, ri[RI_ENTITY], Entity.PERMISSION_ID, ri[RI_ITEM]], int(ri[RI_J]), int(ri[RI_JCOUNT]))
        else:
          errMsg = getHTTPError({}, http_status, reason, message)
          entityActionFailedWarning([Entity.DRIVE_FILE_OR_FOLDER_ID, ri[RI_ENTITY], Entity.PERMISSION_ID, ri[RI_ITEM]], errMsg, int(ri[RI_J]), int(ri[RI_JCOUNT]))
        return
      waitOnFailure(1, 10, reason, message)
      try:
        callGAPI(drive.permissions(), u'delete',
                 throw_reasons=GAPI_DRIVE_THROW_REASONS+[GAPI_FILE_NOT_FOUND, GAPI_FORBIDDEN, GAPI_INTERNAL_ERROR, GAPI_BAD_REQUEST, GAPI_PERMISSION_NOT_FOUND], retry_reasons=[GAPI_SERVICE_LIMIT],
                 fileId=ri[RI_ENTITY], permissionId=ri[RI_ITEM])
        entityActionPerformed([Entity.DRIVE_FILE_OR_FOLDER_ID, ri[RI_ENTITY], Entity.PERMISSION_ID, ri[RI_ITEM]], int(ri[RI_J]), int(ri[RI_JCOUNT]))
      except (GAPI_fileNotFound, GAPI_forbidden, GAPI_internalError, GAPI_badRequest, GAPI_permissionNotFound, GAPI_serviceNotAvailable, GAPI_authError) as e:
        entityActionFailedWarning([Entity.DRIVE_FILE_OR_FOLDER_ID, ri[RI_ENTITY], Entity.PERMISSION_ID, ri[RI_ITEM]], e.message, int(ri[RI_J]), int(ri[RI_JCOUNT]))

  fileIdEntity = getDriveFileEntity()
  body, parameters = initializeDriveFileAttributes()
  permissionIds = getEntityList(OB_DRIVE_FILE_PERMISSION_ID_ENTITY)
  permissionIdsLists = permissionIds if isinstance(permissionIds, dict) else None
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, body, parameters, entityType=Entity.DRIVE_FILE_OR_FOLDER_ACL)
    if jcount == 0:
      continue
    try:
      callGAPI(drive.about(), u'get',
               throw_reasons=GAPI_DRIVE_THROW_REASONS,
               fields=u'')
    except (GAPI_serviceNotAvailable, GAPI_authError):
      entityServiceNotApplicableWarning(Entity.USER, user, i, count)
      continue
    Indent.Increment()
    svcargs = dict([(u'fileId', None), (u'permissionId', None), (u'fields', u'')]+GM_Globals[GM_EXTRA_ARGS_LIST])
    dbatch = googleapiclient.http.BatchHttpRequest(callback=_callbackDeletePermissionId)
    bcount = 0
    j = 0
    for fileId in fileIdEntity[u'list']:
      j += 1
      if permissionIdsLists:
        if not GM_Globals[GM_CSV_SUBKEY_FIELD]:
          permissionIds = permissionIdsLists[fileId]
        else:
          permissionIds = permissionIdsLists[origUser][fileId]
      kcount = len(permissionIds)
      if kcount == 0:
        continue
      k = 0
      for permissionId in permissionIds:
        k += 1
        svcparms = svcargs.copy()
        svcparms[u'fileId'] = fileId
        svcparms[u'permissionId'] = permissionId
        dbatch.add(drive.permissions().delete(**svcparms), request_id=batchRequestID(fileId, j, jcount, k, kcount, permissionId))
        bcount += 1
        if bcount >= GC_Values[GC_BATCH_SIZE]:
          dbatch.execute()
          dbatch = googleapiclient.http.BatchHttpRequest(callback=_callbackDeletePermissionId)
          bcount = 0
    if bcount > 0:
      dbatch.execute()
    Indent.Decrement()

def _printShowDriveFileACLs(users, csvFormat):
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile([u'Owner', u'id'])
  fileIdEntity = getDriveFileEntity()
  body, parameters = initializeDriveFileAttributes()
  showTitles = False
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'showtitles':
      showTitles = True
      if csvFormat:
        addTitlesToCSVfile([DRIVE_FILE_NAME], titles)
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, body, parameters, entityType=[Entity.DRIVE_FILE_OR_FOLDER_ACL, None][csvFormat])
    if jcount == 0:
      continue
    Indent.Increment()
    j = 0
    for fileId in fileIdEntity[u'list']:
      j += 1
      try:
        fileName = fileId
        entityType = Entity.DRIVE_FILE_OR_FOLDER_ID
        if showTitles:
          result = callGAPI(drive.files(), u'get',
                            throw_reasons=GAPI_DRIVE_THROW_REASONS+[GAPI_FILE_NOT_FOUND, GAPI_FORBIDDEN, GAPI_INTERNAL_ERROR],
                            fileId=fileId, fields=DRIVE_FILE_NAME)
          if result and DRIVE_FILE_NAME in result:
            entityType = Entity.DRIVE_FILE_OR_FOLDER
            fileName = result[DRIVE_FILE_NAME]
            if not csvFormat:
              fileName += u'('+fileId+u')'
        result = callGAPI(drive.permissions(), u'list',
                          throw_reasons=GAPI_DRIVE_THROW_REASONS+[GAPI_FILE_NOT_FOUND, GAPI_FORBIDDEN, GAPI_INTERNAL_ERROR],
                          fileId=fileId, fields=DRIVE_PERMISSIONS_LIST)
        if not csvFormat:
          printEntityKVList([entityType, fileName], [Entity.Plural(Entity.PERMITTEE)], j, jcount)
          if result:
            Indent.Increment()
            for permission in result[DRIVE_PERMISSIONS_LIST]:
              _showDriveFilePermission(permission)
            Indent.Decrement()
        elif result:
          result[u'permissions'] = result.pop(u'items', {})
          if showTitles:
            addRowTitlesToCSVfile(flattenJSON(result, flattened={u'Owner': user, u'id': fileId, DRIVE_FILE_NAME: fileName}), csvRows, titles)
          else:
            addRowTitlesToCSVfile(flattenJSON(result, flattened={u'Owner': user, u'id': fileId}), csvRows, titles)
      except (GAPI_fileNotFound, GAPI_forbidden, GAPI_internalError) as e:
        entityActionFailedWarning([Entity.USER, user, entityType, fileName], e.message, j, jcount)
      except (GAPI_serviceNotAvailable, GAPI_authError):
        entityServiceNotApplicableWarning(Entity.USER, user, i, count)
        break
    Indent.Decrement()
  if csvFormat:
    sortCSVTitles([u'Owner', u'id', DRIVE_FILE_NAME], titles)
    writeCSVfile(csvRows, titles, u'Drive File ACLs', todrive)

# gam <UserTypeEntity> print drivefileacl <DriveFileEntity> [todrive [<ToDriveAttributes>]] [showtitles]
def printDriveFileACLs(users):
  _printShowDriveFileACLs(users, True)

# gam <UserTypeEntity> show drivefileacl <DriveFileEntity> [showtitles]
def showDriveFileACLs(users):
  _printShowDriveFileACLs(users, False)

# gam <UserTypeEntity> delete alias|aliases
def deleteUsersAliases(users):
  cd = buildGAPIObject(DIRECTORY_API)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      user_aliases = callGAPI(cd.users(), u'get',
                              throw_reasons=GAPI_USER_GET_THROW_REASONS,
                              userKey=user, fields=u'id,primaryEmail,aliases')
      user_id = user_aliases[u'id']
      user_primary = user_aliases[u'primaryEmail']
      jcount = len(user_aliases[u'aliases']) if (u'aliases' in user_aliases) else 0
      entityPerformActionNumItems([Entity.USER, user_primary], jcount, Entity.ALIAS, i, count)
      if jcount == 0:
        setSysExitRC(NO_ENTITIES_FOUND)
        continue
      Indent.Increment()
      j = 0
      for an_alias in user_aliases[u'aliases']:
        j += 1
        try:
          callGAPI(cd.users().aliases(), u'delete',
                   throw_reasons=[GAPI_RESOURCE_ID_NOT_FOUND],
                   userKey=user_id, alias=an_alias)
          entityActionPerformed([Entity.USER, user_primary, Entity.ALIAS, an_alias], j, jcount)
        except GAPI_resourceIdNotFound:
          entityActionFailedWarning([Entity.USER, user_primary, Entity.ALIAS, an_alias], PHRASE_DOES_NOT_EXIST, j, jcount)
      Indent.Decrement()
    except (GAPI_userNotFound, GAPI_domainNotFound, GAPI_forbidden, GAPI_badRequest, GAPI_backendError, GAPI_systemError):
      entityUnknownWarning(Entity.USER, user, i, count)

def checkUserExists(cd, user, i=0, count=0):
  user = normalizeEmailAddressOrUID(user)
  try:
    return callGAPI(cd.users(), u'get',
                    throw_reasons=GAPI_USER_GET_THROW_REASONS,
                    userKey=user, fields=u'primaryEmail')[u'primaryEmail']
  except (GAPI_userNotFound, GAPI_domainNotFound, GAPI_forbidden, GAPI_badRequest, GAPI_backendError, GAPI_systemError):
    entityUnknownWarning(Entity.USER, user, i, count)
    return None

# gam <UserTypeEntity> add group|groups [member|manager|owner] <GroupEntity>
def addUserToGroups(users):

  _ADD_USER_REASON_TO_MESSAGE_MAP = {GAPI_DUPLICATE: PHRASE_DUPLICATE, GAPI_MEMBER_NOT_FOUND: PHRASE_DOES_NOT_EXIST, GAPI_INVALID_MEMBER: PHRASE_INVALID_ROLE}
  def _callbackAddUserToGroups(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      if str(response[u'email']).lower() != ri[RI_ITEM]:
        entityActionPerformed([Entity.GROUP, ri[RI_ENTITY], ri[RI_ROLE], u'{0} (primary address)'.format(response[u'email'])], int(ri[RI_J]), int(ri[RI_JCOUNT]))
      else:
        entityActionPerformed([Entity.GROUP, ri[RI_ENTITY], ri[RI_ROLE], response[u'email']], int(ri[RI_J]), int(ri[RI_JCOUNT]))
    else:
      http_status, reason, message = checkGAPIError(exception)
      if reason in GAPI_MEMBERS_THROW_REASONS:
        entityUnknownWarning(Entity.GROUP, ri[RI_ENTITY], int(ri[RI_J]), int(ri[RI_JCOUNT]))
      else:
        errMsg = getHTTPError(_ADD_USER_REASON_TO_MESSAGE_MAP, http_status, reason, message)
        entityActionFailedWarning([Entity.GROUP, ri[RI_ENTITY], ri[RI_ROLE], ri[RI_ITEM]], errMsg, int(ri[RI_J]), int(ri[RI_JCOUNT]))

  def _batchAddUserToGroups(cd, user, i, count, groupKeys, body):
    Action.Set(Action.ADD)
    role = body[u'role']
    jcount = len(groupKeys)
    entityPerformActionModifierNumItemsModifier([Entity.USER, user], Action.MODIFIER_TO, jcount, Entity.GROUP, u'{0} {1}'.format(PHRASE_AS, body[u'role'].lower()), i, count)
    Indent.Increment()
    svcargs = dict([(u'groupKey', None), (u'body', body), (u'fields', u'email')]+GM_Globals[GM_EXTRA_ARGS_LIST])
    dbatch = googleapiclient.http.BatchHttpRequest(callback=_callbackAddUserToGroups)
    bcount = 0
    j = 0
    for group in groupKeys:
      j += 1
      svcparms = svcargs.copy()
      svcparms[u'groupKey'] = normalizeEmailAddressOrUID(group)
      dbatch.add(cd.members().insert(**svcparms), request_id=batchRequestID(svcparms[u'groupKey'], 0, 0, j, jcount, user, role))
      bcount += 1
      if bcount >= GC_Values[GC_BATCH_SIZE]:
        dbatch.execute()
        dbatch = googleapiclient.http.BatchHttpRequest(callback=_callbackAddUserToGroups)
        bcount = 0
    if bcount > 0:
      dbatch.execute()
    Indent.Decrement()

  cd = buildGAPIObject(DIRECTORY_API)
  role = getChoice(GROUP_ROLES_MAP, defaultChoice=Entity.ROLE_MEMBER, mapChoice=True)
  groupKeys = getEntityList(OB_GROUP_ENTITY)
  userGroupLists = groupKeys if isinstance(groupKeys, dict) else None
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    if userGroupLists:
      groupKeys = userGroupLists[user]
    user = checkUserExists(cd, user, i, count)
    if user:
      _batchAddUserToGroups(cd, user, i, count, groupKeys, {u'role': role, u'email': user})

# gam <UserTypeEntity> delete group|groups [<GroupEntity>]
def deleteUserFromGroups(users):

  _DELETE_USER_REASON_TO_MESSAGE_MAP = {GAPI_MEMBER_NOT_FOUND: u'{0} {1}'.format(PHRASE_NOT_A, Entity.Singular(Entity.MEMBER)), GAPI_INVALID_MEMBER: PHRASE_DOES_NOT_EXIST}
  def _callbackDeleteUserFromGroups(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      entityActionPerformed([Entity.GROUP, ri[RI_ENTITY], ri[RI_ROLE], ri[RI_ITEM]], int(ri[RI_J]), int(ri[RI_JCOUNT]))
    else:
      http_status, reason, message = checkGAPIError(exception)
      if reason in GAPI_MEMBERS_THROW_REASONS:
        entityUnknownWarning(Entity.GROUP, ri[RI_ENTITY], int(ri[RI_J]), int(ri[RI_JCOUNT]))
      else:
        errMsg = getHTTPError(_DELETE_USER_REASON_TO_MESSAGE_MAP, http_status, reason, message)
        entityActionFailedWarning([Entity.GROUP, ri[RI_ENTITY], ri[RI_ROLE], ri[RI_ITEM]], errMsg, int(ri[RI_J]), int(ri[RI_JCOUNT]))

  def _batchDeleteUserFromGroups(cd, user, i, count, groupKeys):
    Action.Set(Action.REMOVE)
    role = Entity.MEMBER
    jcount = len(groupKeys)
    entityPerformActionModifierNumItems([Entity.USER, user], Action.MODIFIER_FROM, jcount, Entity.GROUP, i, count)
    Indent.Increment()
    svcargs = dict([(u'groupKey', None), (u'memberKey', user), (u'fields', u'')]+GM_Globals[GM_EXTRA_ARGS_LIST])
    dbatch = googleapiclient.http.BatchHttpRequest(callback=_callbackDeleteUserFromGroups)
    bcount = 0
    j = 0
    for group in groupKeys:
      j += 1
      svcparms = svcargs.copy()
      svcparms[u'groupKey'] = normalizeEmailAddressOrUID(group)
      dbatch.add(cd.members().delete(**svcparms), request_id=batchRequestID(svcparms[u'groupKey'], 0, 0, j, jcount, user, role))
      bcount += 1
      if bcount >= GC_Values[GC_BATCH_SIZE]:
        dbatch.execute()
        dbatch = googleapiclient.http.BatchHttpRequest(callback=_callbackDeleteUserFromGroups)
        bcount = 0
    if bcount > 0:
      dbatch.execute()
    Indent.Decrement()

  cd = buildGAPIObject(DIRECTORY_API)
  if CLArgs.ArgumentsRemaining():
    groupKeys = getEntityList(OB_GROUP_ENTITY)
    userGroupLists = groupKeys if isinstance(groupKeys, dict) else None
    checkForExtraneousArguments()
  else:
    groupKeys = None
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    if groupKeys is None:
      user = checkUserExists(cd, user, i, count)
      if user:
        result = callGAPIpages(cd.groups(), u'list', u'groups',
                               userKey=user, fields=u'nextPageToken,groups(email)')
        userGroupKeys = [item[u'email'] for item in result]
        _batchDeleteUserFromGroups(cd, user, i, count, userGroupKeys)
    else:
      if userGroupLists:
        userGroupKeys = userGroupLists[user]
      else:
        userGroupKeys = groupKeys
      user = checkUserExists(cd, user, i, count)
      if user:
        _batchDeleteUserFromGroups(cd, user, i, count, userGroupKeys)

# License command utilities
LICENSE_SKUID = u'skuId'
LICENSE_PRODUCTID = u'productId'
LICENSE_OLDSKUID = u'oldSkuId'

def getLicenseParameters(operation):
  lic = buildGAPIObject(LICENSING_API)
  parameters = {}
  parameters[LICENSE_PRODUCTID], parameters[LICENSE_SKUID] = getGoogleSKU()
  if checkArgumentPresent([u'product', u'productid']):
    parameters[LICENSE_PRODUCTID] = getGoogleProduct()
  if operation == u'patch':
    checkArgumentPresent(FROM_ARGUMENT)
    oldProductId, parameters[LICENSE_OLDSKUID] = getGoogleSKU()
    if parameters[LICENSE_PRODUCTID] != oldProductId:
      CLArgs.Backup()
      usageErrorExit(MESSAGE_SKU_PRODUCT_MISMATCH).format(oldProductId, parameters[LICENSE_PRODUCTID])
  checkForExtraneousArguments()
  return (lic, parameters)

# gam <UserTypeEntity> add license <SKUID>
def addLicense(users):
  lic, parameters = getLicenseParameters(u'insert')
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      callGAPI(lic.licenseAssignments(), u'insert',
               throw_reasons=[GAPI_USER_NOT_FOUND, GAPI_FORBIDDEN, GAPI_BACKEND_ERROR, GAPI_DUPLICATE, GAPI_CONDITION_NOT_MET],
               productId=parameters[LICENSE_PRODUCTID], skuId=parameters[LICENSE_SKUID], body={u'userId': user}, fields=u'')
      entityActionPerformed([Entity.USER, user, Entity.LICENSE, _formatSKUIdDisplayName(parameters[LICENSE_SKUID])], i, count)
    except (GAPI_conditionNotMet, GAPI_duplicate) as e:
      entityActionFailedWarning([Entity.USER, user, Entity.LICENSE, _formatSKUIdDisplayName(parameters[LICENSE_SKUID])], e.message, i, count)
    except (GAPI_userNotFound, GAPI_forbidden, GAPI_backendError):
      entityUnknownWarning(Entity.USER, user, i, count)

# gam <UserTypeEntity> update license <SKUID> [from] <SKUID>
def updateLicense(users):
  lic, parameters = getLicenseParameters(u'patch')
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      callGAPI(lic.licenseAssignments(), u'patch',
               throw_reasons=[GAPI_USER_NOT_FOUND, GAPI_FORBIDDEN, GAPI_NOT_FOUND, GAPI_BACKEND_ERROR],
               productId=parameters[LICENSE_PRODUCTID], skuId=parameters[LICENSE_OLDSKUID], userId=user, body={u'skuId': parameters[LICENSE_SKUID]}, fields=u'')
      entityModifierNewValueActionPerformed([Entity.USER, user, Entity.LICENSE, _skuIdToDisplayName(parameters[LICENSE_SKUID])],
                                            Action.MODIFIER_FROM, _skuIdToDisplayName(parameters[LICENSE_OLDSKUID]), i, count)
    except GAPI_notFound as e:
      entityActionFailedWarning([Entity.USER, user, Entity.LICENSE, _formatSKUIdDisplayName(parameters[LICENSE_OLDSKUID])], e.message, i, count)
    except (GAPI_userNotFound, GAPI_forbidden, GAPI_backendError):
      entityUnknownWarning(Entity.USER, user, i, count)

# gam <UserTypeEntity> delete license <SKUID>
def deleteLicense(users):
  lic, parameters = getLicenseParameters(u'delete')
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      callGAPI(lic.licenseAssignments(), u'delete',
               throw_reasons=[GAPI_USER_NOT_FOUND, GAPI_FORBIDDEN, GAPI_NOT_FOUND, GAPI_BACKEND_ERROR],
               productId=parameters[LICENSE_PRODUCTID], skuId=parameters[LICENSE_SKUID], userId=user)
      entityActionPerformed([Entity.USER, user, Entity.LICENSE, _formatSKUIdDisplayName(parameters[LICENSE_SKUID])], i, count)
    except GAPI_notFound as e:
      entityActionFailedWarning([Entity.USER, user, Entity.LICENSE, _formatSKUIdDisplayName(parameters[LICENSE_SKUID])], e.message, i, count)
    except (GAPI_userNotFound, GAPI_forbidden, GAPI_backendError):
      entityUnknownWarning(Entity.USER, user, i, count)

# gam <UserTypeEntity> update photo <FileNamePattern>
#	#  #user# and #email" will be replaced with user email address #username# will be replaced by portion of email address in front of @
def updatePhoto(users):
  cd = buildGAPIObject(DIRECTORY_API)
  filenamePattern = getString(OB_PHOTO_FILENAME_PATTERN)
  checkForExtraneousArguments()
  p = re.compile(u'^(ht|f)tps?://.*$')
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, userName, _ = splitEmailAddressOrUID(user)
    filename = filenamePattern.replace(u'#user#', user)
    filename = filename.replace(u'#email#', user)
    filename = filename.replace(u'#username#', userName)
    if p.match(filename):
      try:
        status, image_data = httplib2.Http(disable_ssl_certificate_validation=GC_Values[GC_NO_VERIFY_SSL]).request(filename, u'GET')
        if status[u'status'] != u'200':
          entityActionFailedWarning([Entity.USER, user, Entity.PHOTO, filename], PHRASE_NOT_ALLOWED, i, count)
          continue
        if status[u'content-location'] != filename:
          entityActionFailedWarning([Entity.USER, user, Entity.PHOTO, filename], PHRASE_NOT_FOUND, i, count)
          continue
      except (httplib2.HttpLib2Error, httplib2.ServerNotFoundError, httplib2.CertificateValidationUnsupported) as e:
        entityActionFailedWarning([Entity.USER, user, Entity.PHOTO, filename], e.message, i, count)
        continue
    else:
      image_data = readFile(filename, mode=u'rb', continueOnError=True, displayError=True)
      if image_data is None:
        entityActionFailedWarning([Entity.USER, user, Entity.PHOTO, filename], e.strerror, i, count)
        continue
    body = {u'photoData': base64.urlsafe_b64encode(image_data)}
    try:
      callGAPI(cd.users().photos(), u'update',
               throw_reasons=[GAPI_USER_NOT_FOUND, GAPI_FORBIDDEN, GAPI_INVALID_INPUT],
               userKey=user, body=body, fields=u'')
      entityActionPerformed([Entity.USER, user, Entity.PHOTO, filename], i, count)
    except GAPI_invalidInput as e:
      entityActionFailedWarning([Entity.USER, user, Entity.PHOTO, filename], e.message, i, count)
    except (GAPI_userNotFound, GAPI_forbidden):
      entityUnknownWarning(Entity.USER, user, i, count)

# gam <UserTypeEntity> delete photo
def deletePhoto(users):
  cd = buildGAPIObject(DIRECTORY_API)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      callGAPI(cd.users().photos(), u'delete',
               throw_reasons=[GAPI_USER_NOT_FOUND, GAPI_FORBIDDEN, GAPI_PHOTO_NOT_FOUND],
               userKey=user)
      entityActionPerformed([Entity.USER, user, Entity.PHOTO, u''], i, count)
    except GAPI_photoNotFound as e:
      entityActionFailedWarning([Entity.USER, user, Entity.PHOTO, u''], e.message, i, count)
    except (GAPI_userNotFound, GAPI_forbidden):
      entityUnknownWarning(Entity.USER, user, i, count)

# gam <UserTypeEntity> get photo [drivedir|(targetfolder <FilePath>)] [noshow]
def getPhoto(users):
  cd = buildGAPIObject(DIRECTORY_API)
  targetFolder = os.getcwd()
  showPhotoData = True
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'drivedir':
      targetFolder = GC_Values[GC_DRIVE_DIR]
    elif myarg == u'targetfolder':
      targetFolder = os.path.expanduser(getString(OB_FILE_PATH))
      if not os.path.isdir(targetFolder):
        os.makedirs(targetFolder)
    elif myarg == u'noshow':
      showPhotoData = False
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      entityPerformActionNumItems([Entity.USER, user], 1, Entity.PHOTO, i, count)
      photo = callGAPI(cd.users().photos(), u'get',
                       throw_reasons=[GAPI_USER_NOT_FOUND, GAPI_FORBIDDEN, GAPI_PHOTO_NOT_FOUND],
                       userKey=user)
      filename = os.path.join(targetFolder, u'{0}.jpg'.format(user))
      photo_data = str(photo[u'photoData'])
      if showPhotoData:
        writeStdout(photo_data+'\n')
      status, e = writeFileReturnError(filename, base64.urlsafe_b64decode(photo_data))
      if status:
        entityActionPerformed([Entity.USER, user, Entity.PHOTO, filename], i, count)
      else:
        entityActionFailedWarning([Entity.USER, user, Entity.PHOTO, filename], e.strerror, i, count)
    except GAPI_photoNotFound as e:
      entityActionFailedWarning([Entity.USER, user, Entity.PHOTO, None], e.message, i, count)
    except (GAPI_userNotFound, GAPI_forbidden):
      entityUnknownWarning(Entity.USER, user, i, count)

PROFILE_SHARING_CHOICES_MAP = {
  u'share': True,
  u'shared': True,
  u'unshare': False,
  u'unshared': False,
  }

def _setShowProfile(users, function, **kwargs):
  cd = buildGAPIObject(DIRECTORY_API)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      result = callGAPI(cd.users(), function,
                        throw_reasons=[GAPI_USER_NOT_FOUND, GAPI_FORBIDDEN],
                        userKey=user, fields=u'includeInGlobalAddressList', **kwargs)
      printEntity([Entity.USER, user, Entity.PROFILE_SHARING_ENABLED, result.get(u'includeInGlobalAddressList', u'Unknown')], i, count)
    except (GAPI_userNotFound, GAPI_forbidden):
      entityUnknownWarning(Entity.USER, user, i, count)

# gam <UserTypeEntity> profile share|shared|unshare|unshared
def setProfile(users):
  body = {u'includeInGlobalAddressList': getChoice(PROFILE_SHARING_CHOICES_MAP, mapChoice=True)}
  _setShowProfile(users, u'patch', body=body)

# gam <UserTypeEntity> show profile
def showProfile(users):
  _setShowProfile(users, u'get')

# Token commands utilities
def commonClientIds(clientId):
  if clientId == u'gasmo':
    return u'1095133494869.apps.googleusercontent.com'
  return clientId

# gam <UserTypeEntity> delete token|tokens|3lo|oauth clientid <ClientID>
def deleteTokens(users):
  cd = buildGAPIObject(DIRECTORY_API)
  checkArgumentPresent(CLIENTID_ARGUMENT, required=True)
  clientId = commonClientIds(getString(OB_CLIENT_ID))
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      callGAPI(cd.tokens(), u'delete',
               throw_reasons=[GAPI_USER_NOT_FOUND, GAPI_NOT_FOUND],
               userKey=user, clientId=clientId)
      entityActionPerformed([Entity.USER, user, Entity.ACCESS_TOKEN, clientId], i, count)
    except GAPI_notFound as e:
      entityActionFailedWarning([Entity.USER, user, Entity.ACCESS_TOKEN, clientId], e.message, i, count)
    except GAPI_userNotFound:
      entityUnknownWarning(Entity.USER, user, i, count)

def _printShowTokens(entityType, users, csvFormat):
  def _showToken(token, j, jcount):
    printKeyValueListWithCount([u'Client ID', token[u'clientId']], j, jcount)
    Indent.Increment()
    for item in token:
      if item not in [u'clientId', u'scopes']:
        printKeyValueList([item, token.get(item, u'')])
    item = u'scopes'
    printKeyValueList([item, None])
    Indent.Increment()
    for it in token.get(item, []):
      printKeyValueList([it])
    Indent.Decrement()
    Indent.Decrement()

  cd = buildGAPIObject(DIRECTORY_API)
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile([u'user', u'clientId', u'displayText', u'anonymous', u'nativeApp', u'userKey', u'scopes'])
  clientId = None
  delimiter = GC_Values[GC_CSV_OUTPUT_FIELD_DELIMITER]
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'clientid':
      clientId = commonClientIds(getString(OB_CLIENT_ID))
    elif myarg == u'delimiter':
      delimiter = getDelimiter()
    elif not entityType:
      CLArgs.Backup()
      entityType, users = getEntityToModify(defaultEntityType=CL_ENTITY_USERS)
  if not entityType:
    users = getUsersToModify(CL_ENTITY_ALL_USERS, None)
  fields = u','.join([u'clientId', u'displayText', u'anonymous', u'nativeApp', u'userKey', u'scopes'])
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      if csvFormat:
        printGettingEntityItemForWhom(Entity.ACCESS_TOKEN, user, i, count)
      if clientId:
        results = [callGAPI(cd.tokens(), u'get',
                            throw_reasons=[GAPI_USER_NOT_FOUND, GAPI_DOMAIN_NOT_FOUND, GAPI_FORBIDDEN, GAPI_NOT_FOUND, GAPI_RESOURCE_NOT_FOUND],
                            userKey=user, clientId=clientId, fields=fields)]
      else:
        results = callGAPIitems(cd.tokens(), u'list', u'items',
                                throw_reasons=[GAPI_USER_NOT_FOUND, GAPI_DOMAIN_NOT_FOUND, GAPI_FORBIDDEN],
                                userKey=user, fields=u'items({0})'.format(fields))
      jcount = len(results)
      if not csvFormat:
        entityPerformActionNumItems([Entity.USER, user], jcount, Entity.ACCESS_TOKEN, i, count)
      if jcount == 0:
        setSysExitRC(NO_ENTITIES_FOUND)
        continue
      if not csvFormat:
        Indent.Increment()
        j = 0
        for token in results:
          j += 1
          _showToken(token, j, jcount)
        Indent.Decrement()
      else:
        for token in results:
          row = {u'user': user, u'scopes': delimiter.join(token.get(u'scopes', []))}
          for item in token:
            if item != u'scopes':
              row[item] = token.get(item, u'')
          csvRows.append(row)
    except (GAPI_notFound, GAPI_resourceNotFound) as e:
      entityActionFailedWarning([Entity.USER, user, Entity.ACCESS_TOKEN, clientId], e.message, i, count)
    except (GAPI_userNotFound, GAPI_domainNotFound, GAPI_forbidden):
      entityUnknownWarning(Entity.USER, user, i, count)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'OAuth Tokens', todrive)

# gam <UserTypeEntity> show tokens|token|3lo|oauth [clientid <ClientID>]
def showTokens(users):
  _printShowTokens(CL_ENTITY_USERS, users, False)

# gam <UserTypeEntity> print tokens|token [todrive [<ToDriveAttributes>]] [clientid <ClientID>] [delimiter <String>]
def printTokens(users):
  _printShowTokens(CL_ENTITY_USERS, users, True)

# gam print tokens|token [todrive [<ToDriveAttributes>]] [clientid <ClientID>] [<UserTypeEntity>] [delimiter <String>]
def doPrintTokens():
  _printShowTokens(None, None, True)

# gam <UserTypeEntity> deprovision|deprov
def deprovisionUser(users):
  cd = buildGAPIObject(DIRECTORY_API)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      printGettingEntityItemForWhom(Entity.APPLICATION_SPECIFIC_PASSWORD, user, i, count)
      asps = callGAPIitems(cd.asps(), u'list', u'items',
                           throw_reasons=[GAPI_USER_NOT_FOUND],
                           userKey=user, fields=u'items(codeId)')
      jcount = len(asps)
      entityPerformActionNumItems([Entity.USER, user], jcount, Entity.APPLICATION_SPECIFIC_PASSWORD, i, count)
      if jcount > 0:
        Indent.Increment()
        j = 0
        for asp in asps:
          j += 1
          codeId = asp[u'codeId']
          try:
            callGAPI(cd.asps(), u'delete',
                     throw_reasons=[GAPI_USER_NOT_FOUND, GAPI_INVALID],
                     userKey=user, codeId=codeId)
            entityActionPerformed([Entity.USER, user, Entity.APPLICATION_SPECIFIC_PASSWORD, codeId], j, jcount)
          except GAPI_invalid as e:
            entityActionFailedWarning([Entity.USER, user, Entity.APPLICATION_SPECIFIC_PASSWORD, codeId], e.message, j, jcount)
        Indent.Decrement()
#
      printGettingEntityItemForWhom(Entity.BACKUP_VERIFICATION_CODES, user, i, count)
      try:
        codes = callGAPIitems(cd.verificationCodes(), u'list', u'items',
                              throw_reasons=[GAPI_USER_NOT_FOUND],
                              userKey=user, fields=u'items(verificationCode)')
        jcount = len(codes)
        entityPerformActionNumItems([Entity.USER, user], jcount, Entity.BACKUP_VERIFICATION_CODES, i, count)
        if jcount > 0:
          callGAPI(cd.verificationCodes(), u'invalidate',
                   throw_reasons=[GAPI_USER_NOT_FOUND, GAPI_INVALID],
                   userKey=user)
          entityActionPerformed([Entity.USER, user, Entity.BACKUP_VERIFICATION_CODES, None], i, count)
      except GAPI_invalid as e:
        entityActionFailedWarning([Entity.USER, user, Entity.BACKUP_VERIFICATION_CODES, None], e.message, i, count)
#
      printGettingEntityItemForWhom(Entity.ACCESS_TOKEN, user, i, count)
      tokens = callGAPIitems(cd.tokens(), u'list', u'items',
                             throw_reasons=[GAPI_USER_NOT_FOUND],
                             userKey=user, fields=u'items(clientId)')
      jcount = len(tokens)
      entityPerformActionNumItems([Entity.USER, user], jcount, Entity.ACCESS_TOKEN, i, count)
      if jcount > 0:
        Indent.Increment()
        j = 0
        for token in tokens:
          j += 1
          clientId = token[u'clientId']
          try:
            callGAPI(cd.tokens(), u'delete',
                     throw_reasons=[GAPI_USER_NOT_FOUND, GAPI_NOT_FOUND],
                     userKey=user, clientId=clientId)
            entityActionPerformed([Entity.USER, user, Entity.ACCESS_TOKEN, clientId], j, jcount)
          except GAPI_notFound as e:
            entityActionFailedWarning([Entity.USER, user, Entity.ACCESS_TOKEN, clientId], e.message, j, jcount)
        Indent.Decrement()
#
      entityActionPerformed([Entity.USER, user], i, count)
    except GAPI_userNotFound:
      entityUnknownWarning(Entity.USER, user, i, count)

def _printShowGmailProfile(users, csvFormat):
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile(None)
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(GMAIL_API, user)
    if not gmail:
      continue
    if csvFormat:
      printGettingEntityItemForWhom(Entity.GMAIL_PROFILE, user, i, count)
    try:
      results = callGAPI(gmail.users(), u'getProfile',
                         throw_reasons=GAPI_GMAIL_THROW_REASONS,
                         userId=u'me')
      if not csvFormat:
        kvList = []
        for item in [u'historyId', u'messagesTotal', u'threadsTotal']:
          kvList += [item, results[item]]
        printEntityKVList([Entity.USER, user], kvList, i, count)
      else:
        addRowTitlesToCSVfile(results, csvRows, titles)
    except (GAPI_serviceNotAvailable, GAPI_badRequest):
      entityServiceNotApplicableWarning(Entity.USER, user, i, count)
  if csvFormat:
    sortCSVTitles([u'emailAddress',], titles)
    writeCSVfile(csvRows, titles, u'Gmail Profiles', todrive)

# gam <UserTypeEntity> print gmailprofile [todrive [<ToDriveAttributes>]]
def printGmailProfile(users):
  _printShowGmailProfile(users, True)

# gam <UserTypeEntity> show gmailprofile
def showGmailProfile(users):
  _printShowGmailProfile(users, False)

PROFILE_PROPERTY_PRINT_ORDER = [
  u'objectType',
  u'displayName',
  u'name',
  u'nickname',
  u'domain',
  u'birthday',
  u'ageRange',
  u'gender',
  u'relationshipStatus',
  u'placesLived',
  u'language',
  u'occupation',
  u'aboutMe',
  u'braggingRights',
  u'skills',
  u'tagline',
  u'circledByCount',
  u'plusOneCount',
  u'verified',
  u'emails',
  u'organizations',
  u'urls',
  u'cover',
  ]

PROFILE_ARRAY_PROPERTY_PRINT_ORDER = {
  u'ageRange': [u'min', u'max'],
  u'cover': [u'layout', u'coverPhoto', u'coverInfo'],
  u'coverInfo': [u'topImageOffset', u'leftImageOffset'],
  u'coverPhoto': [u'url', u'height', u'width'],
  u'emails': [u'type', u'value'],
  u'image': [u'url',],
  u'name': [u'formatted', u'honorificPrefix', u'givenName', u'middleName', u'familyName', u'honorificSuffix'],
  u'organizations': [u'type', u'name', u'title', u'department', u'location', u'description', u'startDate', u'endDate', u'primary'],
  u'placesLived': [u'value', u'primary'],
  u'urls': [u'label', u'type', u'value'],
  }

def _showGplusProfile(user, i, count, result):
  def _showProfileObject(object_name, object_value, object_order=None, level=0):
    if object_name is not None:
      printJSONKey(object_name)
    if isinstance(object_value, list):
      if object_name is not None:
        printBlankLine()
        Indent.Increment()
      for sub_value in object_value:
        if isinstance(sub_value, (str, unicode, int, bool)):
          printKeyValueList([sub_value])
        else:
          _showProfileObject(None, sub_value, object_order=PROFILE_ARRAY_PROPERTY_PRINT_ORDER[object_name], level=level+1)
      if object_name is not None:
        Indent.Decrement()
    elif isinstance(object_value, dict):
      indentAfterFirst = unindentAfterLast = False
      if object_name is not None:
        printBlankLine()
        Indent.Increment()
      elif level > 0:
        indentAfterFirst = unindentAfterLast = True
      for sub_object in object_order or PROFILE_ARRAY_PROPERTY_PRINT_ORDER[object_name]:
        value = object_value.get(sub_object)
        if value is not None:
          _showProfileObject(sub_object, value, level=level+1)
          if indentAfterFirst:
            Indent.Increment()
            indentAfterFirst = False
      if object_name is not None or unindentAfterLast:
        Indent.Decrement()
    else:
      if object_name in [u'aboutMe',]:
        printJSONValue(dehtml(object_value))
      else:
        printJSONValue(object_value)

  enabled = result[u'isPlusUser']
  printEntity([Entity.USER, user, Entity.GPLUS_PROFILE, result[u'id']], i, count)
  Indent.Increment()
  printKeyValueList([u'isPlusUser', enabled])
  for item in PROFILE_PROPERTY_PRINT_ORDER:
    value = result.get(item)
    if value is not None:
      _showProfileObject(item, value)
  Indent.Decrement()

def _printShowGplusProfile(users, csvFormat):
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile(None)
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gplus = buildGAPIServiceObject(GPLUS_API, user)
    if not gplus:
      continue
    if csvFormat:
      printGettingEntityItemForWhom(Entity.GPLUS_PROFILE, user, i, count)
    try:
      results = callGAPI(gplus.people(), u'get',
                         throw_reasons=GAPI_GPLUS_THROW_REASONS,
                         userId=u'me')
      if not csvFormat:
        _showGplusProfile(user, i, count, results)
      else:
        addRowTitlesToCSVfile(flattenJSON(results, flattened={u'emailAddress': user}), csvRows, titles)
    except GAPI_serviceNotAvailable:
      entityServiceNotApplicableWarning(Entity.USER, user, i, count)
  if csvFormat:
    sortCSVTitles([u'emailAddress', u'id', u'displayName', u'domain'], titles)
    writeCSVfile(csvRows, titles, u'Gplus Profiles', todrive)

# gam <UserTypeEntity> print gplusprofile [todrive [<ToDriveAttributes>]]
def printGplusProfile(users):
  _printShowGplusProfile(users, True)

# gam <UserTypeEntity> show gplusprofile
def showGplusProfile(users):
  _printShowGplusProfile(users, False)

def _getUserGmailLabels(gmail, user, i, count, **kwargs):
  try:
    labels = callGAPI(gmail.users().labels(), u'list',
                      throw_reasons=GAPI_GMAIL_THROW_REASONS,
                      userId=u'me', **kwargs)
    if not labels:
      labels = {u'labels': []}
    return labels
  except (GAPI_serviceNotAvailable, GAPI_badRequest):
    entityServiceNotApplicableWarning(Entity.USER, user, i, count)
    return None

def _getLabelId(labels, labelName):
  for label in labels[u'labels']:
    if label[u'id'] == labelName or label[u'name'] == labelName:
      return label[u'id']
  return None

def _getLabelName(labels, labelId):
  for label in labels[u'labels']:
    if label[u'id'] == labelId:
      return label[u'name']
  return labelId

LABEL_LABEL_LIST_VISIBILITY_CHOICES_MAP = {
  u'hide': u'labelHide',
  u'show': u'labelShow',
  u'showifunread': u'labelShowIfUnread',
  }
LABEL_MESSAGE_LIST_VISIBILITY_CHOICES = [u'hide', u'show',]

# gam <UserTypeEntity> [add] label|labels <String> [messagelistvisibility hide|show] [labellistvisibility hide|show|showifunread]
def addLabel(users):
  label = getString(OB_LABEL_NAME)
  body = {u'name': label}
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'labellistvisibility':
      body[u'labelListVisibility'] = getChoice(LABEL_LABEL_LIST_VISIBILITY_CHOICES_MAP, mapChoice=True)
    elif myarg == u'messagelistvisibility':
      body[u'messageListVisibility'] = getChoice(LABEL_MESSAGE_LIST_VISIBILITY_CHOICES)
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(GMAIL_API, user)
    if not gmail:
      continue
    try:
      callGAPI(gmail.users().labels(), u'create',
               throw_reasons=GAPI_GMAIL_THROW_REASONS+[GAPI_DUPLICATE],
               userId=u'me', body=body, fields=u'')
      entityActionPerformed([Entity.USER, user, Entity.LABEL, label], i, count)
    except GAPI_duplicate:
      entityActionFailedWarning([Entity.USER, user, Entity.LABEL, label], PHRASE_DUPLICATE, i, count)
    except (GAPI_serviceNotAvailable, GAPI_badRequest):
      entityServiceNotApplicableWarning(Entity.USER, user, i, count)

# gam <UserTypeEntity> update labelsettings <LabelName> [name <String>] [messagelistvisibility hide|show] [labellistvisibility hide|show|showifunread]
def updateLabelSettings(users):
  label_name = getString(OB_LABEL_NAME)
  label_name_lower = label_name.lower()
  body = {}
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'name':
      body[u'name'] = getString(OB_STRING)
    elif myarg == u'messagelistvisibility':
      body[u'messageListVisibility'] = getChoice(LABEL_MESSAGE_LIST_VISIBILITY_CHOICES)
    elif myarg == u'labellistvisibility':
      body[u'labelListVisibility'] = getChoice(LABEL_LABEL_LIST_VISIBILITY_CHOICES_MAP, mapChoice=True)
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(GMAIL_API, user)
    if not gmail:
      continue
    labels = _getUserGmailLabels(gmail, user, i, count, fields=u'labels(id,name)')
    if not labels:
      continue
    try:
      for label in labels[u'labels']:
        if label[u'name'].lower() == label_name_lower:
          callGAPI(gmail.users().labels(), u'patch',
                   throw_reasons=GAPI_GMAIL_THROW_REASONS+[GAPI_NOT_FOUND, GAPI_INVALID_ARGUMENT],
                   userId=u'me', id=label[u'id'], body=body, fields=u'')
          break
      else:
        entityActionFailedWarning([Entity.USER, user, Entity.LABEL, label_name], PHRASE_DOES_NOT_EXIST, i, count)
    except (GAPI_notFound, GAPI_invalidArgument) as e:
      entityActionFailedWarning([Entity.USER, user, Entity.LABEL, label_name], e.message, i, count)
    except (GAPI_serviceNotAvailable, GAPI_badRequest):
      entityServiceNotApplicableWarning(Entity.USER, user, i, count)
#
LABEL_TYPE_SYSTEM = u'system'
LABEL_TYPE_USER = u'user'

# gam <UserTypeEntity> update label|labels [search <RegularExpression>] [replace <LabelReplacement>] [merge]
#	search defaults to '^Inbox/(.*)$' which will find all labels in the Inbox
#	replace defaults to '%s'
def updateLabels(users):
  search = u'^Inbox/(.*)$'
  replace = u'%s'
  merge = False
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'search':
      search = getString(OB_RE_PATTERN)
    elif myarg == u'replace':
      replace = getString(OB_LABEL_REPLACEMENT)
    elif myarg == u'merge':
      merge = True
    else:
      unknownArgumentExit()
  pattern = re.compile(search, re.IGNORECASE)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(GMAIL_API, user)
    if not gmail:
      continue
    labels = _getUserGmailLabels(gmail, user, i, count, fields=u'labels(id,name,type)')
    if not labels:
      continue
    try:
      labelMatches = 0
      for label in labels[u'labels']:
        if label[u'type'] == LABEL_TYPE_SYSTEM:
          continue
        match_result = pattern.search(label[u'name'])
        if match_result is not None:
          labelMatches += 1
          try:
            newLabelName = replace % match_result.groups()
          except TypeError:
            usageErrorExit(MESSAGE_MISMATCH_SEARCH_REPLACE_SUBFIELDS.format(len(match_result.groups()), search, replace.count(u'%s'), replace))
          newLabelNameLower = newLabelName.lower()
          try:
            Action.Set(Action.RENAME)
            callGAPI(gmail.users().labels(), u'patch',
                     throw_reasons=[GAPI_ABORTED, GAPI_DUPLICATE],
                     userId=u'me', id=label[u'id'], body={u'name': newLabelName}, fields=u'')
            entityModifierNewValueActionPerformed([Entity.USER, user, Entity.LABEL, label[u'name']], Action.MODIFIER_TO, newLabelName, i, count)
          except (GAPI_aborted, GAPI_duplicate):
            if merge:
              Action.Set(Action.MERGE)
              entityPerformActionModifierNewValue([Entity.USER, user, Entity.LABEL, label[u'name']], Action.MODIFIER_WITH, newLabelName, i, count)
              messagesToRelabel = callGAPIpages(gmail.users().messages(), u'list', u'messages',
                                                userId=u'me', q=u'label:"{0}"'.format(label[u'name']))
              Action.Set(Action.RELABEL)
              jcount = len(messagesToRelabel)
              Indent.Increment()
              if jcount > 0:
                for new_label in labels[u'labels']:
                  if new_label[u'name'].lower() == newLabelNameLower:
                    body = {u'addLabelIds': [new_label[u'id']]}
                    break
                j = 0
                for message in messagesToRelabel:
                  j += 1
                  callGAPI(gmail.users().messages(), u'modify',
                           userId=u'me', id=message[u'id'], body=body, fields=u'')
                  entityActionPerformed([Entity.USER, user, Entity.MESSAGE, message[u'id']], j, jcount)
              else:
                printEntityKVList([Entity.USER, user],
                                  [PHRASE_NO_MESSAGES_WITH_LABEL, label[u'name']],
                                  i, count)
              Indent.Decrement()
              callGAPI(gmail.users().labels(), u'delete',
                       userId=u'me', id=label[u'id'])
              Action.Set(Action.DELETE)
              entityActionPerformed([Entity.USER, user, Entity.LABEL, label[u'name']], i, count)
            else:
              entityActionNotPerformedWarning([Entity.USER, user, Entity.LABEL, newLabelName], PHRASE_ALREADY_EXISTS_USE_MERGE_ARGUMENT, i, count)
      if labels and (labelMatches == 0):
        printEntityKVList([Entity.USER, user],
                          [PHRASE_NO_LABELS_MATCH, search],
                          i, count)
    except (GAPI_serviceNotAvailable, GAPI_badRequest):
      entityServiceNotApplicableWarning(Entity.USER, user, i, count)

# gam <UserTypeEntity> delete label|labels <LabelName>|regex:<RegularExpression>
def deleteLabel(users):
  def _handleProcessGmailError(exception, ri):
    http_status, reason, message = checkGAPIError(exception)
    entityActionFailedWarning([Entity.USER, ri[RI_ENTITY], Entity.LABEL, ri[RI_ITEM]], formatHTTPError(http_status, reason, message), int(ri[RI_J]), int(ri[RI_JCOUNT]))

  def _callbackDeleteLabel(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      entityActionPerformed([Entity.USER, ri[RI_ENTITY], Entity.LABEL, ri[RI_ITEM]], int(ri[RI_J]), int(ri[RI_JCOUNT]))
    else:
      _handleProcessGmailError(exception, ri)

  label = getString(OB_LABEL_NAME)
  label_name_lower = label.lower()
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(GMAIL_API, user)
    if not gmail:
      continue
    try:
      printGettingAllEntityItemsForWhom(Entity.LABEL, user, i, count)
      labels = _getUserGmailLabels(gmail, user, i, count, fields=u'labels(id,name,type)')
      if not labels:
        continue
      del_labels = []
      if label == u'--ALL_LABELS--':
        count = len(labels[u'labels'])
        for del_label in labels[u'labels']:
          if del_label[u'type'] == LABEL_TYPE_SYSTEM:
            continue
          del_labels.append(del_label)
      elif label[:6].lower() == u'regex:':
        regex = label[6:]
        p = re.compile(regex)
        for del_label in labels[u'labels']:
          if del_label[u'type'] == LABEL_TYPE_SYSTEM:
            continue
          elif p.match(del_label[u'name']):
            del_labels.append(del_label)
      else:
        for del_label in labels[u'labels']:
          if label_name_lower == del_label[u'name'].lower():
            del_labels.append(del_label)
            break
        else:
          entityActionFailedWarning([Entity.USER, user, Entity.LABEL, label], PHRASE_DOES_NOT_EXIST, i, count)
          continue
      jcount = len(del_labels)
      entityPerformActionNumItems([Entity.USER, user], jcount, Entity.LABEL, i, count)
      Indent.Increment()
      svcargs = dict([(u'userId', u'me'), (u'id', None), (u'fields', u'')]+GM_Globals[GM_EXTRA_ARGS_LIST])
      dbatch = googleapiclient.http.BatchHttpRequest(callback=_callbackDeleteLabel)
      bcount = 0
      j = 0
      for del_me in del_labels:
        j += 1
        svcparms = svcargs.copy()
        svcparms[u'id'] = del_me[u'id']
        dbatch.add(gmail.users().labels().delete(**svcparms), request_id=batchRequestID(user, 0, 0, j, jcount, del_me[u'name']))
        bcount += 1
        if bcount == 10:
          dbatch.execute()
          dbatch = googleapiclient.http.BatchHttpRequest(callback=_callbackDeleteLabel)
          bcount = 0
      if bcount > 0:
        dbatch.execute()
      Indent.Decrement()
    except (GAPI_serviceNotAvailable, GAPI_badRequest):
      entityServiceNotApplicableWarning(Entity.USER, user, i, count)

# gam <UserTypeEntity> show labels|label [onlyuser] [showcounts]
def showLabels(users):
  onlyUser = showCounts = False
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'onlyuser':
      onlyUser = True
    elif myarg == u'showcounts':
      showCounts = True
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(GMAIL_API, user)
    if not gmail:
      continue
    labels = _getUserGmailLabels(gmail, user, i, count)
    if not labels:
      continue
    try:
      jcount = len(labels[u'labels'])
      if (jcount > 0) and onlyUser:
        for label in labels[u'labels']:
          if label[u'type'] == LABEL_TYPE_SYSTEM:
            jcount -= 1
      entityPerformActionNumItems([Entity.USER, user], jcount, Entity.LABEL, i, count)
      if jcount == 0:
        setSysExitRC(NO_ENTITIES_FOUND)
        continue
      Indent.Increment()
      for label in labels[u'labels']:
        if onlyUser and (label[u'type'] == LABEL_TYPE_SYSTEM):
          continue
        printKeyValueList([label[u'name']])
        Indent.Increment()
        for a_key in label:
          if a_key != u'name':
            printKeyValueList([a_key, label[a_key]])
        if showCounts:
          counts = callGAPI(gmail.users().labels(), u'get',
                            throw_reasons=GAPI_GMAIL_THROW_REASONS,
                            userId=u'me', id=label[u'id'],
                            fields=u'messagesTotal,messagesUnread,threadsTotal,threadsUnread')
          for a_key in counts:
            printKeyValueList([a_key, counts[a_key]])
        Indent.Decrement()
      Indent.Decrement()
    except (GAPI_serviceNotAvailable, GAPI_badRequest):
      entityServiceNotApplicableWarning(Entity.USER, user, i, count)

# gam <UserTypeEntity> archive messages <GroupItem> (((query <QueryGmail>) (matchlabel <LabelName>) [or|and])+ [quick|notquick] [doit] [max_to_archive <Number>])|(ids <MessageIDEntity>)
def archiveMessages(users):
  gm = buildGAPIObject(GROUPSMIGRATION_API)
  entityType = Entity.MESSAGE
  currLabelOp = prevLabelOp = u'and'
  labelGroupOpen = False
  query = u''
  doIt = quick = True
  maxToProcess = 0
  messageEntity = None
  cd = buildGAPIObject(DIRECTORY_API)
  group = getEmailAddress()
  try:
    group = callGAPI(cd.groups(), u'get',
                     throw_reasons=GAPI_GROUP_GET_THROW_REASONS,
                     groupKey=group, fields=u'email')[u'email']
  except (GAPI_groupNotFound, GAPI_domainNotFound, GAPI_forbidden, GAPI_badRequest) as e:
    CLArgs.Backup()
    usageErrorExit(u'{0}: {1}'.format(PHRASE_INVALID_GROUP, e.message))
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'query':
      query += u' ({0})'.format(getString(OB_QUERY))
    elif myarg == u'matchlabel':
      labelName = getString(OB_LABEL_NAME).lower().replace(u' ', u'-').replace(u'/', u'-')
      if not labelGroupOpen:
        query += u'('
        labelGroupOpen = True
      query += u' label:{0}'.format(labelName)
    elif myarg in [u'or', u'and']:
      prevLabelOp = currLabelOp
      currLabelOp = myarg
      if labelGroupOpen and currLabelOp != prevLabelOp:
        query += u')'
        labelGroupOpen = False
      if currLabelOp == u'or':
        query += u' OR '
    elif myarg == u'ids':
      messageEntity = getUserObjectEntity(OB_MESSAGE_ID, entityType)
    elif myarg == u'quick':
      quick = True
    elif myarg == u'notquick':
      quick = False
    elif myarg == u'doit':
      doIt = True
    elif myarg in[u'maxtoarchive', u'maxtoprocess']:
      maxToProcess = getInteger(minVal=0)
    else:
      unknownArgumentExit()
  if query:
    if labelGroupOpen:
      query += u')'
  else:
    query = None
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail, messageIds = _validateUserGetMessageIds(user, messageEntity)
    if not gmail:
      continue
    try:
      if messageEntity is None:
        printGettingAllEntityItemsForWhom(entityType, user, i, count)
        page_message = getPageMessage()
        listResult = callGAPIpages(gmail.users().messages(), u'list', u'messages',
                                   page_message=page_message, maxItems=[0, maxToProcess][quick],
                                   throw_reasons=GAPI_GMAIL_THROW_REASONS,
                                   userId=u'me', q=query, fields=u'nextPageToken,messages(id)', maxResults=GC_Values[GC_MESSAGE_MAX_RESULTS])
        messageIds = [message[u'id'] for message in listResult]
      jcount = len(messageIds)
      if jcount == 0:
        entityNumEntitiesActionNotPerformedWarning(Entity.USER, user, entityType, jcount, PHRASE_NO_ENTITIES_MATCHED.format(Entity.Plural(entityType)), i, count)
        setSysExitRC(NO_ENTITIES_FOUND)
        continue
      if messageEntity is None:
        if maxToProcess and jcount > maxToProcess:
          entityNumEntitiesActionNotPerformedWarning(Entity.USER, user, entityType, jcount, PHRASE_COUNT_N_EXCEEDS_MAX_TO_PROCESS_M.format(jcount, Action.ToPerform(), maxToProcess), i, count)
          continue
        if not doIt:
          entityNumEntitiesActionNotPerformedWarning(Entity.USER, user, entityType, jcount, PHRASE_USE_DOIT_ARGUMENT_TO_PERFORM_ACTION, i, count)
          continue
      entityPerformActionNumItems([Entity.USER, user], jcount, entityType, i, count)
      Indent.Increment()
      j = 0
      for messageId in messageIds:
        j += 1
        try:
          message = callGAPI(gmail.users().messages(), u'get',
                             throw_reasons=GAPI_GMAIL_THROW_REASONS+[GAPI_NOT_FOUND, GAPI_INVALID_ARGUMENT],
                             userId=u'me', id=messageId, format=u'raw')
          stream = StringIO.StringIO()
          stream.write(base64.urlsafe_b64decode(str(message[u'raw'])))
          try:
            callGAPI(gm.archive(), u'insert',
                     throw_reasons=GAPI_GMAIL_THROW_REASONS+[GAPI_NOT_FOUND],
                     groupId=group, media_body=googleapiclient.http.MediaIoBaseUpload(stream, mimetype=u'message/rfc822', resumable=True))
            entityActionPerformed([Entity.USER, user, entityType, messageId], j, jcount)
          except GAPI_serviceNotAvailable:
            entityServiceNotApplicableWarning(Entity.USER, user, i, count)
            break
          except GAPI_badRequest as e:
            entityActionFailedWarning([Entity.USER, user, entityType, messageId], e.message, j, jcount)
        except (GAPI_serviceNotAvailable, GAPI_badRequest):
          entityServiceNotApplicableWarning(Entity.USER, user, i, count)
          break
        except (GAPI_notFound, GAPI_invalidArgument) as e:
          entityActionFailedWarning([Entity.USER, user, entityType, messageId], e.message, j, jcount)
      Indent.Decrement()
    except (GAPI_serviceNotAvailable, GAPI_badRequest):
      entityServiceNotApplicableWarning(Entity.USER, user, i, count)

def _processMessagesThreads(users, entityType):
  def _initLabelNameMap():
    baseLabelNameMap = {
      u'INBOX': u'INBOX', u'SPAM': u'SPAM', u'TRASH': u'TRASH',
      u'UNREAD': u'UNREAD', u'STARRED': u'STARRED', u'IMPORTANT': u'IMPORTANT',
      u'SENT': u'SENT', u'DRAFT': u'DRAFT',
      u'CATEGORY_PERSONAL': u'CATEGORY_PERSONAL',
      u'CATEGORY_SOCIAL': u'CATEGORY_SOCIAL',
      u'CATEGORY_PROMOTIONS': u'CATEGORY_PROMOTIONS',
      u'CATEGORY_UPDATES': u'CATEGORY_UPDATES',
      u'CATEGORY_FORUMS': u'CATEGORY_FORUMS',
      }

    labelNameMap = baseLabelNameMap.copy()
    for label in userGmailLabels[u'labels']:
      if label[u'type'] == u'system':
        labelNameMap[label[u'id']] = label[u'id']
      else:
        labelNameMap[label[u'name']] = label[u'id']
    return labelNameMap

  def _convertLabelNamesToIds(bodyLabels, labelNameMap, addLabelIfMissing):
    labelIds = []
    for label in bodyLabels:
      if label not in labelNameMap:
        results = callGAPI(gmail.users().labels(), u'create',
                           userId=u'me', body={u'labelListVisibility': u'labelShow', u'messageListVisibility': u'show', u'name': label}, fields=u'id')
        labelNameMap[label] = results[u'id']
      try:
        labelIds.append(labelNameMap[label])
      except KeyError:
        pass
      if addLabelIfMissing:
        if label.find(u'/') != -1:
          # make sure to create parent labels for proper nesting
          parent_label = label[:label.rfind(u'/')]
          while True:
            if not parent_label in labelNameMap:
              result = callGAPI(gmail.users().labels(), u'create',
                                userId=u'me', body={u'name': parent_label}, fields=u'id')
              labelNameMap[parent_label] = result[u'id']
            if parent_label.find(u'/') == -1:
              break
            parent_label = parent_label[:parent_label.rfind(u'/')]
    return labelIds

  def _batchDeleteModifyMessages(gmail, function, user, jcount, messageIds, body):
    mcount = 0
    bcount = min(jcount-mcount, GC_Values[GC_MESSAGE_BATCH_SIZE])
    while bcount > 0:
      body[u'ids'] = messageIds[mcount:mcount+bcount]
      try:
        callGAPI(gmail.users().messages(), function,
                 throw_reasons=GAPI_GMAIL_THROW_REASONS+[GAPI_INVALID_MESSAGE_ID],
                 userId=u'me', body=body)
        for messageId in body[u'ids']:
          mcount += 1
          entityActionPerformed([Entity.USER, user, entityType, messageId], mcount, jcount)
      except (GAPI_serviceNotAvailable, GAPI_badRequest):
        mcount += bcount
      except GAPI_invalidMessageId:
        entityActionFailedWarning([Entity.USER, user, entityType, PHRASE_BATCH], u'{0} ({1}-{2}/{3})'.format(PHRASE_INVALID_MESSAGE_ID, mcount+1, mcount+bcount, jcount))
        mcount += bcount
      bcount = min(jcount-mcount, GC_Values[GC_MESSAGE_BATCH_SIZE])

  _GMAIL_ERROR_REASON_TO_MESSAGE_MAP = {GAPI_NOT_FOUND: PHRASE_DOES_NOT_EXIST, GAPI_INVALID_MESSAGE_ID: PHRASE_INVALID_MESSAGE_ID}
  def _handleProcessGmailError(exception, ri):
    http_status, reason, message = checkGAPIError(exception)
    errMsg = getHTTPError(_GMAIL_ERROR_REASON_TO_MESSAGE_MAP, http_status, reason, message)
    entityActionFailedWarning([Entity.USER, ri[RI_ENTITY], entityType, ri[RI_ITEM]], errMsg, int(ri[RI_J]), int(ri[RI_JCOUNT]))

  def _callbackProcessMessage(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      entityActionPerformed([Entity.USER, ri[RI_ENTITY], entityType, ri[RI_ITEM]], int(ri[RI_J]), int(ri[RI_JCOUNT]))
    else:
      _handleProcessGmailError(exception, ri)

  def _batchProcessMessagesThreads(service, function, user, jcount, messageIds, **kwargs):
    svcargs = dict([(u'userId', u'me'), (u'id', None), (u'fields', u'')]+kwargs.items()+GM_Globals[GM_EXTRA_ARGS_LIST])
    method = getattr(service, function)
    dbatch = googleapiclient.http.BatchHttpRequest(callback=_callbackProcessMessage)
    bcount = 0
    j = 0
    for messageId in messageIds:
      j += 1
      svcparms = svcargs.copy()
      svcparms[u'id'] = messageId
      dbatch.add(method(**svcparms), request_id=batchRequestID(user, 0, 0, j, jcount, svcparms[u'id']))
      bcount += 1
      if bcount == GC_Values[GC_EMAIL_BATCH_SIZE]:
        dbatch.execute()
        dbatch = googleapiclient.http.BatchHttpRequest(callback=_callbackProcessMessage)
        bcount = 0
    if bcount > 0:
      dbatch.execute()

  currLabelOp = prevLabelOp = u'and'
  labelGroupOpen = False
  query = u''
  includeSpamTrash = False
  labelNameMap = {}
  doIt = quick = False
  maxToProcess = 1
  function = {Action.DELETE: u'delete', Action.MODIFY: u'modify', Action.SPAM: u'spam', Action.TRASH: u'trash', Action.UNTRASH: u'untrash'}[Action.Get()]
  addLabelNames = []
  addLabelIds = []
  removeLabelNames = []
  removeLabelIds = []
  messageEntity = None
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'query':
      query += u' ({0})'.format(getString(OB_QUERY))
    elif myarg == u'matchlabel':
      labelName = getString(OB_LABEL_NAME).lower().replace(u' ', u'-').replace(u'/', u'-')
      if not labelGroupOpen:
        query += u'('
        labelGroupOpen = True
      query += u' label:{0}'.format(labelName)
    elif myarg in [u'or', u'and']:
      prevLabelOp = currLabelOp
      currLabelOp = myarg
      if labelGroupOpen and currLabelOp != prevLabelOp:
        query += u')'
        labelGroupOpen = False
      if currLabelOp == u'or':
        query += u' OR '
    elif myarg == u'ids':
      messageEntity = getUserObjectEntity(OB_MESSAGE_ID, entityType)
    elif myarg == u'quick':
      quick = True
    elif myarg == u'notquick':
      quick = False
    elif myarg == u'doit':
      doIt = True
    elif myarg in [u'maxtodelete', u'maxtomodify', u'maxtospam', u'maxtotrash', u'maxtountrash', u'maxtoprocess']:
      maxToProcess = getInteger(minVal=0)
    elif (function == u'modify') and (myarg == u'addlabel'):
      addLabelNames.append(getString(OB_LABEL_NAME))
    elif (function == u'modify') and (myarg == u'removelabel'):
      removeLabelNames.append(getString(OB_LABEL_NAME))
    else:
      unknownArgumentExit()
  if query:
    if labelGroupOpen:
      query += u')'
  elif messageEntity is None:
    missingArgumentExit(u'query|matchlabel|ids')
  listType = [u'threads', u'messages'][entityType == Entity.MESSAGE]
  includeSpamTrash = Action.Get() in [Action.DELETE, Action.MODIFY, Action.UNTRASH]
  if function == u'spam':
    function = u'modify'
    addLabelIds = [u'SPAM',]
    removeLabelIds = [u'INBOX',]
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail, messageIds = _validateUserGetMessageIds(user, messageEntity)
    if not gmail:
      continue
    service = [gmail.users().threads(), gmail.users().messages()][entityType == Entity.MESSAGE]
    try:
      if addLabelNames or removeLabelNames:
        userGmailLabels = _getUserGmailLabels(gmail, user, i, count, fields=u'labels(id,name,type)')
        if not userGmailLabels:
          continue
        labelNameMap = _initLabelNameMap()
        addLabelIds = _convertLabelNamesToIds(addLabelNames, labelNameMap, True)
        removeLabelIds = _convertLabelNamesToIds(removeLabelNames, labelNameMap, False)
      if messageEntity is None:
        printGettingAllEntityItemsForWhom(Entity.MESSAGE, user, i, count)
        page_message = getPageMessage()
        listResult = callGAPIpages(service, u'list', listType,
                                   page_message=page_message, maxItems=[0, maxToProcess][quick],
                                   throw_reasons=GAPI_GMAIL_THROW_REASONS,
                                   userId=u'me', q=query, includeSpamTrash=includeSpamTrash, fields=u'nextPageToken,{0}(id)'.format(listType), maxResults=GC_Values[GC_MESSAGE_MAX_RESULTS])
        messageIds = [message[u'id'] for message in listResult]
      else:
        # Need to get authorization set up for batch
        callGAPI(gmail.users(), u'getProfile',
                 throw_reasons=GAPI_GMAIL_THROW_REASONS,
                 userId=u'me', fields=u'')
      jcount = len(messageIds)
      if jcount == 0:
        entityNumEntitiesActionNotPerformedWarning(Entity.USER, user, entityType, jcount, PHRASE_NO_ENTITIES_MATCHED.format(Entity.Plural(entityType)), i, count)
        setSysExitRC(NO_ENTITIES_FOUND)
        continue
      if messageEntity is None:
        if maxToProcess and jcount > maxToProcess:
          entityNumEntitiesActionNotPerformedWarning(Entity.USER, user, entityType, jcount, PHRASE_COUNT_N_EXCEEDS_MAX_TO_PROCESS_M.format(jcount, Action.ToPerform(), maxToProcess), i, count)
          continue
        if not doIt:
          entityNumEntitiesActionNotPerformedWarning(Entity.USER, user, entityType, jcount, PHRASE_USE_DOIT_ARGUMENT_TO_PERFORM_ACTION, i, count)
          continue
      entityPerformActionNumItems([Entity.USER, user], jcount, entityType, i, count)
      Indent.Increment()
      if function == u'delete' and entityType == Entity.MESSAGE:
        _batchDeleteModifyMessages(gmail, u'batchDelete', user, jcount, messageIds, {u'ids': []})
      elif function == u'modify' and entityType == Entity.MESSAGE:
        _batchDeleteModifyMessages(gmail, u'batchModify', user, jcount, messageIds, {u'ids': [], u'addLabelIds': addLabelIds, u'removeLabelIds': removeLabelIds})
      else:
        if addLabelIds or removeLabelIds:
          kwargs = {u'body': {u'addLabelIds': addLabelIds, u'removeLabelIds': removeLabelIds}}
        else:
          kwargs = {}
        _batchProcessMessagesThreads(service, function, user, jcount, messageIds, **kwargs)
      Indent.Decrement()
    except (GAPI_serviceNotAvailable, GAPI_badRequest):
      entityServiceNotApplicableWarning(Entity.USER, user, i, count)

# gam <UserTypeEntity> delete message|messages (((query <QueryGmail>) (matchlabel <LabelName>) [or|and])+ [quick|notquick] [doit] [max_to_delete <Number>])|(ids <MessageIDEntity>)
# gam <UserTypeEntity> modify message|messages (((query <QueryGmail>) (matchlabel <LabelName>) [or|and])+ [quick|notquick] [doit] [max_to_modify <Number>])|(ids <MessageIDEntity>) (addlabel <LabelName>)* (removelabel <LabelName>)*
# gam <UserTypeEntity> spam message|messages (((query <QueryGmail>) (matchlabel <LabelName>) [or|and])+ [quick|notquick] [doit] [max_to_spam <Number>])|(ids <MessageIDEntity>)
# gam <UserTypeEntity> trash message|messages (((query <QueryGmail>) (matchlabel <LabelName>) [or|and])+ [quick|notquick] [doit] [max_to_trash <Number>])|(ids <MessageIDEntity>)
# gam <UserTypeEntity> untrash message|messages (((query <QueryGmail>) (matchlabel <LabelName>) [or|and])+ [quick|notquick] [doit] [max_to_untrash <Number>])|(ids <MessageIDEntity>)
def processMessages(users):
  _processMessagesThreads(users, Entity.MESSAGE)

# gam <UserTypeEntity> delete thread|threads (((query <QueryGmail>) (matchlabel <LabelName>) [or|and])+ [quick|notquick] [doit] [max_to_delete <Number>])|(ids <ThreadIDEntity>)
# gam <UserTypeEntity> modify thread|threads (((query <QueryGmail>) (matchlabel <LabelName>) [or|and])+ [quick|notquick] [doit] [max_to_modify <Number>])|(ids <ThreadIDEntity>) (addlabel <LabelName>)* (removelabel <LabelName>)*
# gam <UserTypeEntity> spam thread|threads (((query <QueryGmail>) (matchlabel <LabelName>) [or|and])+ [quick|notquick] [doit] [max_to_spam <Number>])|(ids <ThreadIDEntity>)
# gam <UserTypeEntity> trash thread|threads (((query <QueryGmail>) (matchlabel <LabelName>) [or|and])+ [quick|notquick] [doit] [max_to_trash <Number>])|(ids <MessageIDEntity>)
# gam <UserTypeEntity> untrash thread|threads (((query <QueryGmail>) (matchlabel <LabelName>) [or|and])+ [quick|notquick] [doit] [max_to_untrash <Number>])|(ids <ThreadIDEntity>)
def processThreads(users):
  _processMessagesThreads(users, Entity.THREAD)

SMTP_HEADERS_MAP = {
  u'accept-language': u'Accept-Language',
  u'alternate-recipient': u'Alternate-Recipient',
  u'autoforwarded': u'Autoforwarded',
  u'autosubmitted': u'Autosubmitted',
  u'bcc': u'Bcc',
  u'cc': u'Cc',
  u'comments': u'Comments',
  u'content-alternative': u'Content-Alternative',
  u'content-base': u'Content-Base',
  u'content-description': u'Content-Description',
  u'content-disposition': u'Content-Disposition',
  u'content-duration': u'Content-Duration',
  u'content-id': u'Content-ID',
  u'content-identifier': u'Content-Identifier',
  u'content-language': u'Content-Language',
  u'content-location': u'Content-Location',
  u'content-md5': u'Content-MD5',
  u'content-return': u'Content-Return',
  u'content-transfer-encoding': u'Content-Transfer-Encoding',
  u'content-type': u'Content-Type',
  u'content-features': u'Content-features',
  u'conversion': u'Conversion',
  u'conversion-with-loss': u'Conversion-With-Loss',
  u'dl-expansion-history': u'DL-Expansion-History',
  u'date': u'Date',
  u'deferred-delivery': u'Deferred-Delivery',
  u'delivered-to': u'Delivered-To',
  u'delivery-date': u'Delivery-Date',
  u'discarded-x400-ipms-extensions': u'Discarded-X400-IPMS-Extensions',
  u'discarded-x400-mts-extensions': u'Discarded-X400-MTS-Extensions',
  u'disclose-recipients': u'Disclose-Recipients',
  u'disposition-notification-options': u'Disposition-Notification-Options',
  u'disposition-notification-to': u'Disposition-Notification-To',
  u'encoding': u'Encoding',
  u'encrypted': u'Encrypted',
  u'expires': u'Expires',
  u'expiry-date': u'Expiry-Date',
  u'from': u'From',
  u'generate-delivery-report': u'Generate-Delivery-Report',
  u'importance': u'Importance',
  u'in-reply-to': u'In-Reply-To',
  u'incomplete-copy': u'Incomplete-Copy',
  u'keywords': u'Keywords',
  u'language': u'Language',
  u'latest-delivery-time': u'Latest-Delivery-Time',
  u'list-archive': u'List-Archive',
  u'list-help': u'List-Help',
  u'list-id': u'List-ID',
  u'list-owner': u'List-Owner',
  u'list-post': u'List-Post',
  u'list-subscribe': u'List-Subscribe',
  u'list-unsubscribe': u'List-Unsubscribe',
  u'mime-version': u'MIME-Version',
  u'message-context': u'Message-Context',
  u'message-id': u'Message-ID',
  u'message-type': u'Message-Type',
  u'obsoletes': u'Obsoletes',
  u'original-encoded-information-types': u'Original-Encoded-Information-Types',
  u'original-message-id': u'Original-Message-ID',
  u'originator-return-address': u'Originator-Return-Address',
  u'pics-label': u'PICS-Label',
  u'prevent-nondelivery-report': u'Prevent-NonDelivery-Report',
  u'priority': u'Priority',
  u'received': u'Received',
  u'references': u'References',
  u'reply-by': u'Reply-By',
  u'reply-to': u'Reply-To',
  u'resent-bcc': u'Resent-Bcc',
  u'resent-cc': u'Resent-Cc',
  u'resent-date': u'Resent-Date',
  u'resent-from': u'Resent-From',
  u'resent-message-id': u'Resent-Message-ID',
  u'resent-reply-to': u'Resent-Reply-To',
  u'resent-sender': u'Resent-Sender',
  u'resent-to': u'Resent-To',
  u'return-path': u'Return-Path',
  u'sender': u'Sender',
  u'sensitivity': u'Sensitivity',
  u'subject': u'Subject',
  u'supersedes': u'Supersedes',
  u'to': u'To',
  u'x400-content-identifier': u'X400-Content-Identifier',
  u'x400-content-return': u'X400-Content-Return',
  u'x400-content-type': u'X400-Content-Type',
  u'x400-mts-identifier': u'X400-MTS-Identifier',
  u'x400-originator': u'X400-Originator',
  u'x400-received': u'X400-Received',
  u'x400-recipients': u'X400-Recipients',
  u'x400-trace': u'X400-Trace',
  }

def _printShowMessagesThreads(users, entityType, csvFormat):

  _GMAIL_ERROR_REASON_TO_MESSAGE_MAP = {GAPI_NOT_FOUND: PHRASE_DOES_NOT_EXIST, GAPI_INVALID_MESSAGE_ID: PHRASE_INVALID_MESSAGE_ID}
  def _handleShowGmailError(exception, ri):
    http_status, reason, message = checkGAPIError(exception)
    errMsg = getHTTPError(_GMAIL_ERROR_REASON_TO_MESSAGE_MAP, http_status, reason, message)
    printKeyValueListWithCount([Entity.Singular(entityType), ri[RI_ITEM], errMsg], int(ri[RI_J]), int(ri[RI_JCOUNT]))
    setSysExitRC(AC_FAILED_RC)

  def _handlePrintGmailError(exception, ri):
    http_status, reason, message = checkGAPIError(exception)
    errMsg = getHTTPError(_GMAIL_ERROR_REASON_TO_MESSAGE_MAP, http_status, reason, message)
    entityActionFailedWarning([Entity.USER, ri[RI_ENTITY], entityType, ri[RI_ITEM]], errMsg, int(ri[RI_J]), int(ri[RI_JCOUNT]))

  def _getMessageBody(payload):
    for header in payload[u'headers']:
      if header[u'name'].lower() == u'content-type':
        if header[u'value'].startswith(u'multipart/mixed') or header[u'value'].startswith(u'multipart/related'):
          return _getMessageBody(payload[u'parts'][0])
        break
    if payload[u'body'][u'size']:
      return dehtml(base64.urlsafe_b64decode(str(payload[u'body'][u'data'])))
    for part in payload[u'parts']:
      if part[u'mimeType'] == u'text/plain':
        return dehtml(base64.urlsafe_b64decode(str(part[u'body'][u'data'])))
    return u'Body not available'

  def _showMessage(result, j, jcount):
    printEntity([Entity.MESSAGE, result[u'id']], j, jcount)
    Indent.Increment()
    if show_snippet:
      printKeyValueList([u'Snippet', dehtml(result[u'snippet']).replace(u'\n', u' ')])
    for name in headersToShow:
      for header in result[u'payload'][u'headers']:
        if name == header[u'name'].lower():
          printKeyValueList([SMTP_HEADERS_MAP.get(name, header[u'name']), header[u'value']])
    if show_size:
      printKeyValueList([u'SizeEstimate', result[u'sizeEstimate']])
    if show_labels:
      messageLabels = []
      for labelId in result[u'labelIds']:
        for label in labels[u'labels']:
          if label[u'id'] == labelId:
            messageLabels.append(label[u'name'])
            break
      printKeyValueList([u'Labels', u','.join(messageLabels)])
    if show_body:
      printKeyValueList([u'Body', None])
      Indent.Increment()
      printKeyValueList([Indent.MultiLineText(_getMessageBody(result[u'payload']))])
      Indent.Decrement()
    Indent.Decrement()

  def _callbackShowMessage(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is  None:
      _showMessage(response, int(ri[RI_J]), int(ri[RI_JCOUNT]))
    else:
      _handleShowGmailError(exception, ri)

  def _printMessage(user, result):
    row = {u'User': user, u'threadId': result[u'threadId'], u'id': result[u'id']}
    if show_snippet:
      row[u'Snippet'] = dehtml(result[u'snippet']).replace(u'\n', u' ')
    for name in headersToShow:
      j = 0
      for header in result[u'payload'][u'headers']:
        if name == header[u'name'].lower():
          j += 1
          if j == 1:
            row[SMTP_HEADERS_MAP.get(name, header[u'name'])] = header[u'value']
          else:
            row[u'{0} {1}'.format(SMTP_HEADERS_MAP.get(name, header[u'name']), j)] = header[u'value']
    if show_size:
      row[u'SizeEstimate'] = result[u'sizeEstimate']
    if show_labels:
      messageLabels = []
      for labelId in result[u'labelIds']:
        for label in labels[u'labels']:
          if label[u'id'] == labelId:
            messageLabels.append(label[u'name'])
            break
      row[u'Labels'] = delimiter.join(messageLabels)
    if show_body:
      if not convertCRNL:
        row[u'Body'] = _getMessageBody(result[u'payload'])
      else:
        row[u'Body'] = _getMessageBody(convertCRsNLs(result[u'payload']))
    addRowTitlesToCSVfile(row, csvRows, titles)

  def _callbackPrintMessage(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      _printMessage(ri[RI_ENTITY], response)
    else:
      _handlePrintGmailError(exception, ri)

  def _showThread(result, j, jcount):
    printEntity([Entity.THREAD, result[u'id']], j, jcount)
    Indent.Increment()
    if show_snippet and u'snippet' in result:
      printKeyValueList([u'Snippet', dehtml(result[u'snippet']).replace(u'\n', u' ')])
    try:
      result = callGAPI(service, u'get',
                        throw_reasons=GAPI_GMAIL_THROW_REASONS+[GAPI_NOT_FOUND],
                        id=result[u'id'], userId=u'me', format=u'metadata')
      kcount = len(result[u'messages'])
      k = 0
      for message in result[u'messages']:
        k += 1
        _showMessage(message, k, kcount)
    except (GAPI_serviceNotAvailable, GAPI_badRequest, GAPI_notFound):
      pass
    Indent.Decrement()

  def _callbackShowThread(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      _showThread(response, int(ri[RI_J]), int(ri[RI_JCOUNT]))
    else:
      _handleShowGmailError(exception, ri)

  def _printThread(user, result):
    try:
      result = callGAPI(service, u'get',
                        throw_reasons=GAPI_GMAIL_THROW_REASONS+[GAPI_NOT_FOUND],
                        id=result[u'id'], userId=u'me', format=u'metadata')
      for message in result[u'messages']:
        _printMessage(user, message)
    except (GAPI_serviceNotAvailable, GAPI_badRequest, GAPI_notFound):
      pass

  def _callbackPrintThread(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      _printThread(ri[RI_ENTITY], response)
    else:
      _handlePrintGmailError(exception, ri)

  def _batchPrintShowMessagesThreads(service, user, jcount, messageIds, callback):
    svcargs = dict([(u'userId', u'me'), (u'id', None), (u'format', [u'metadata', u'full'][show_body])]+GM_Globals[GM_EXTRA_ARGS_LIST])
    dbatch = googleapiclient.http.BatchHttpRequest(callback=callback)
    bcount = 0
    j = 0
    for messageId in messageIds:
      j += 1
      svcparms = svcargs.copy()
      svcparms[u'id'] = messageId
      dbatch.add(service.get(**svcparms), request_id=batchRequestID(user, 0, 0, j, jcount, svcparms[u'id']))
      bcount += 1
      if maxToProcess and j == maxToProcess:
        break
      if bcount == GC_Values[GC_EMAIL_BATCH_SIZE]:
        dbatch.execute()
        dbatch = googleapiclient.http.BatchHttpRequest(callback=callback)
        bcount = 0
    if bcount > 0:
      dbatch.execute()

  currLabelOp = prevLabelOp = u'and'
  labelGroupOpen = False
  query = u''
  includeSpamTrash = False
  quick = True
  maxToProcess = 0
  convertCRNL = GC_Values[GC_CSV_OUTPUT_CONVERT_CR_NL]
  delimiter = GC_Values[GC_CSV_OUTPUT_FIELD_DELIMITER]
  show_body = show_labels = show_size = show_snippet = False
  messageEntity = None
  headersToShow = [u'Date', u'Subject', u'From', u'Reply-To', u'To', u'Delivered-To', u'Content-Type', u'Message-ID']
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile([u'User', u'threadId', u'id'])
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'query':
      query += u' ({0})'.format(getString(OB_QUERY))
    elif myarg == u'matchlabel':
      labelName = getString(OB_LABEL_NAME).lower().replace(u' ', u'-').replace(u'/', u'-')
      if not labelGroupOpen:
        query += u'('
        labelGroupOpen = True
      query += u' label:{0}'.format(labelName)
    elif myarg in [u'or', u'and']:
      prevLabelOp = currLabelOp
      currLabelOp = myarg
      if labelGroupOpen and currLabelOp != prevLabelOp:
        query += u')'
        labelGroupOpen = False
      if currLabelOp == u'or':
        query += u' OR '
    elif myarg == u'ids':
      messageEntity = getUserObjectEntity(OB_MESSAGE_ID, entityType)
    elif myarg == u'quick':
      quick = True
    elif myarg == u'notquick':
      quick = False
    elif myarg in[u'maxtoprint', u'maxtoshow', u'maxtoprocess']:
      maxToProcess = getInteger(minVal=0)
    elif myarg == u'headers':
      headersToShow = getString(OB_STRING, minLen=0).replace(u',', u' ').split()
    elif myarg in [u'convertcrnl', u'converttextnl', u'convertbodynl']:
      convertCRNL = True
    elif myarg == u'showbody':
      show_body = True
    elif myarg == u'showlabels':
      show_labels = True
    elif myarg == u'showsize':
      show_size = True
    elif myarg == u'showsnippet':
      show_snippet = True
    elif myarg == u'includespamtrash':
      includeSpamTrash = True
    elif myarg == u'delimiter':
      delimiter = getDelimiter()
    else:
      unknownArgumentExit()
  if query:
    if labelGroupOpen:
      query += u')'
  else:
    query = None
  if csvFormat:
    headerTitles = []
    for j, name in enumerate(headersToShow):
      headersToShow[j] = name.lower()
      headerTitles.append(SMTP_HEADERS_MAP.get(headersToShow[j], name))
    addTitlesToCSVfile(headerTitles, titles)
  else:
    for j, name in enumerate(headersToShow):
      headersToShow[j] = name.lower()
  listType = [u'threads', u'messages'][entityType == Entity.MESSAGE]
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail, messageIds = _validateUserGetMessageIds(user, messageEntity)
    if not gmail:
      continue
    service = [gmail.users().threads(), gmail.users().messages()][entityType == Entity.MESSAGE]
    try:
      if show_labels:
        labels = _getUserGmailLabels(gmail, user, i, count, fields=u'labels(id,name)')
        if not labels:
          continue
      if messageEntity is None:
        printGettingAllEntityItemsForWhom(entityType, user, i, count)
        page_message = getPageMessage()
        listResult = callGAPIpages(service, u'list', listType,
                                   page_message=page_message, maxItems=[0, maxToProcess][quick],
                                   throw_reasons=GAPI_GMAIL_THROW_REASONS,
                                   userId=u'me', q=query, includeSpamTrash=includeSpamTrash, fields=u'nextPageToken,{0}(id)'.format(listType), maxResults=GC_Values[GC_MESSAGE_MAX_RESULTS])
        messageIds = [message[u'id'] for message in listResult]
      else:
        # Need to get authorization set up for batch
        callGAPI(gmail.users(), u'getProfile',
                 throw_reasons=GAPI_GMAIL_THROW_REASONS,
                 userId=u'me', fields=u'')
      jcount = len(messageIds)
      if jcount == 0:
        if not csvFormat:
          entityNumEntitiesActionNotPerformedWarning(Entity.USER, user, entityType, jcount, PHRASE_NO_ENTITIES_MATCHED.format(Entity.Plural(entityType)), i, count)
        setSysExitRC(NO_ENTITIES_FOUND)
        continue
      if not csvFormat:
        if messageEntity is not None or maxToProcess == 0 or jcount <= maxToProcess:
          entityPerformActionNumItems([Entity.USER, user], jcount, entityType, i, count)
        else:
          entityPerformActionNumItemsModifier([Entity.USER, user], maxToProcess, entityType, u'of {0} Total {1}'.format(jcount, Entity.Plural(entityType)), i, count)
      if messageEntity is None and maxToProcess and (jcount > maxToProcess):
        jcount = maxToProcess
      if not csvFormat:
        Indent.Increment()
        _batchPrintShowMessagesThreads(service, user, jcount, messageIds, [_callbackShowThread, _callbackShowMessage][entityType == Entity.MESSAGE])
        Indent.Decrement()
      else:
        _batchPrintShowMessagesThreads(service, user, jcount, messageIds, [_callbackPrintThread, _callbackPrintMessage][entityType == Entity.MESSAGE])
    except (GAPI_serviceNotAvailable, GAPI_badRequest):
      entityServiceNotApplicableWarning(Entity.USER, user, i, count)
  if csvFormat:
    removeTitlesFromCSVfile([u'Snippet', u'SizeEstimate', u'Labels', u'Body'], titles)
    if show_snippet:
      addTitleToCSVfile(u'Snippet', titles)
    if show_size:
      addTitleToCSVfile(u'SizeEstimate', titles)
    if show_labels:
      addTitleToCSVfile(u'Labels', titles)
    if show_body:
      addTitleToCSVfile(u'Body', titles)
    writeCSVfile(csvRows, titles, u'Messages', todrive)

# gam <UserTypeEntity> print message|messages (((query <QueryGmail>) (matchlabel <LabelName>) [or|and])* [quick|notquick] [max_to_show <Number>] [includespamtrash])|(ids <MessageIDEntity>) [headers <String>] [showlabels] [showbody] [showsize] [showsnippet] [convertcrnl] [delimiter <String>] [todrive [<ToDriveAttributes>]]
def printMessages(users):
  _printShowMessagesThreads(users, Entity.MESSAGE, True)

# gam <UserTypeEntity> print thread|threads (((query <QueryGmail>) (matchlabel <LabelName>) [or|and])* [quick|notquick] [max_to_show <Number>] [includespamtrash])|(ids <ThreadIDEntity>) [headers <String>] [showlabels] [showbody] [showsize] [showsnippet] [convertcrnl] [delimiter <String>] [todrive [<ToDriveAttributes>]]
def printThreads(users):
  _printShowMessagesThreads(users, Entity.THREAD, True)

# gam <UserTypeEntity> show message|messages (((query <QueryGmail>) (matchlabel <LabelName>) [or|and])* [quick|notquick] [max_to_show <Number>] [includespamtrash])|(ids <MessageIDEntity>) [headers <String>] [showlabels] [showbody] [showsize] [showsnippet] [convertcrnl]
def showMessages(users):
  _printShowMessagesThreads(users, Entity.MESSAGE, False)

# gam <UserTypeEntity> show thread|threads (((query <QueryGmail>) (matchlabel <LabelName>) [or|and])* [quick|notquick] [max_to_show <Number>] [includespamtrash])|(ids <ThreadIDEntity>) [headers <String>] [showlabels] [showbody] [showsize] [showsnippet] [convertcrnl]
def showThreads(users):
  _printShowMessagesThreads(users, Entity.THREAD, False)

# Process Email Settings
def _processEmailSettings(user, i, count, service, function, **kwargs):
  try:
    return callGData(service, function,
                     throw_errors=GDATA_EMAILSETTINGS_THROW_LIST,
                     **kwargs)
  except GData_doesNotExist:
    entityActionFailedWarning([Entity.USER, user], PHRASE_DOES_NOT_EXIST, i, count)
  except (GData_serviceNotApplicable, GData_invalidDomain):
    entityServiceNotApplicableWarning(Entity.USER, user, i, count)
  except (GData_badRequest, GData_internalServerError, GData_nameNotValid, GData_invalidValue) as e:
    entityBadRequestWarning([Entity.USER, user, Entity.EMAIL_SETTINGS, None], e.message, i, count)
  return None

# gam <UserTypeEntity> arrows <Boolean>
def setArrows(users):
  emailSettings = getEmailSettingsObject()
  enable = getBoolean()
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, userName, emailSettings.domain = splitEmailAddressOrUID(user)
    result = _processEmailSettings(user, i, count, emailSettings, u'UpdateGeneral',
                                   username=userName, arrows=enable)
    if result:
      printEntity([Entity.USER, user, Entity.ARROWS_ENABLED, result[u'arrows']], i, count)

HTTP_400_RESULT_PATTERN = re.compile(r'errorCode="(.*)".*invalidInput="(.*)".*reason="(.*)"')
HTTP_4XX_5XX_RESULT_PATTERN = re.compile(r'<TITLE>(.*)</TITLE>')

# gam <UserTypeEntity> add delegate|delegates <UserEntity>
# gam <UserTypeEntity> delegate|delegates to <UserEntity>
def addDelegate(users):
  delegateTo(users, checkForTo=False)

def delegateTo(users, checkForTo=True):

  def _checkDelegator(i, count, jcount):
    try:
      result = callGAPI(cd.users(), u'get',
                        throw_reasons=GAPI_USER_GET_THROW_REASONS,
                        userKey=delegatorEmail, fields=u'suspended,changePasswordAtNextLogin')
      if result[u'suspended']:
        entityNumEntitiesActionNotPerformedWarning(Entity.DELEGATOR, delegatorEmail, Entity.DELEGATE, jcount, entityTypeNameMessage(Entity.DELEGATOR, delegatorEmail, PHRASE_IS_SUSPENDED_NO_DELEGATION), i, count)
        setSysExitRC(USER_SUSPENDED_ERROR_RC)
      elif result[u'changePasswordAtNextLogin']:
        entityNumEntitiesActionNotPerformedWarning(Entity.DELEGATOR, delegatorEmail, Entity.DELEGATE, jcount, entityTypeNameMessage(Entity.DELEGATOR, delegatorEmail, PHRASE_IS_REQD_TO_CHG_PWD_NO_DELEGATION), i, count)
        setSysExitRC(USER_SUSPENDED_ERROR_RC)
      else:
        return True
    except (GAPI_userNotFound, GAPI_domainNotFound, GAPI_forbidden, GAPI_badRequest, GAPI_backendError, GAPI_systemError):
      entityUnknownWarning(Entity.DELEGATOR, delegatorEmail, i, count)
    return False

  def _checkDelegate(j, jcount):
    try:
      result = callGAPI(cd.users(), u'get',
                        throw_reasons=GAPI_USER_GET_THROW_REASONS,
                        userKey=delegateEmail, fields=u'suspended,changePasswordAtNextLogin')
      if result[u'suspended']:
        entityActionNotPerformedWarning([Entity.DELEGATOR, delegatorEmail],
                                        entityTypeNameMessage(Entity.DELEGATE, delegateEmail, PHRASE_IS_SUSPENDED_NO_DELEGATION), j, jcount)
        setSysExitRC(USER_SUSPENDED_ERROR_RC)
      elif result[u'changePasswordAtNextLogin']:
        entityActionNotPerformedWarning([Entity.DELEGATOR, delegatorEmail],
                                        entityTypeNameMessage(Entity.DELEGATE, delegateEmail, PHRASE_IS_REQD_TO_CHG_PWD_NO_DELEGATION), j, jcount)
        setSysExitRC(USER_SUSPENDED_ERROR_RC)
    except (GAPI_userNotFound, GAPI_domainNotFound, GAPI_forbidden, GAPI_badRequest, GAPI_backendError, GAPI_systemError):
      entityUnknownWarning(Entity.DELEGATE, delegateEmail, j, jcount)

  def _checkDelegatorDelegate(i, count, j, jcount):
    if not _checkDelegator(i, count, jcount):
      return False
    Indent.Increment()
    _checkDelegate(j, jcount)
    Indent.Decrement()
    return True

  cd = buildGAPIObject(DIRECTORY_API)
  emailSettings = buildGAPIObject(EMAIL_SETTINGS_API)
  if checkForTo:
    checkArgumentPresent(TO_ARGUMENT, required=True)
  delegateEntity = getUserObjectEntity(OB_USER_ENTITY, Entity.DELEGATE)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    delegatorEmail, delegatorName, delegatorDomain, delegates, jcount = _validateDelegatorGetObjectList(user, i, count, delegateEntity)
    j = 0
    for delegate in delegates:
      j += 1
      delegateEmail = normalizeEmailAddressOrUID(delegate)
      uri = u'https://apps-apis.google.com/a/feeds/emailsettings/2.0/{0}/{1}/delegation'.format(delegatorDomain, delegatorName)
      body = u'''<?xml version="1.0" encoding="utf-8"?>
  <atom:entry xmlns:atom="http://www.w3.org/2005/Atom" xmlns:apps="http://schemas.google.com/apps/2006">
  <apps:property name="address" value="{0}" />
  </atom:entry>'''.format(delegateEmail)
      headers = {u'GData-Version': u'2.0', u'Content-Type': u'application/atom+xml; charset=UTF-8'}
      retries = 10
      delegatorOK = True
      for n in range(1, retries+1):
        status, result = emailSettings._http.request(uri=uri, method=u'POST', body=body, headers=headers)
        httpStatus = int(status[u'status'])
        if httpStatus == 201: # Success
          Indent.Increment()
          entityActionPerformed([Entity.DELEGATOR, delegatorEmail, Entity.DELEGATE, delegateEmail], j, jcount)
          Indent.Decrement()
          time.sleep(10) # on success, sleep 10 seconds before exiting or moving on to next user to prevent ghost delegates
          break
        if httpStatus == 400:
          tg = HTTP_400_RESULT_PATTERN.search(result)
          if tg is not None:
            errorCode = int(tg.group(1))
            invalidInput = tg.group(2)
            reason = tg.group(3)
            if errorCode == GDATA_DOES_NOT_EXIST:
              delegatorOK = _checkDelegatorDelegate(i, count, j, jcount)
            elif errorCode == GDATA_NAME_NOT_VALID:
              Indent.Increment()
              entityServiceNotApplicableWarning(Entity.DELEGATE, delegateEmail, j, jcount)
              Indent.Decrement()
            elif errorCode == GDATA_ENTITY_EXISTS:
              Indent.Increment()
              entityActionFailedWarning([Entity.DELEGATOR, delegatorEmail], entityTypeNameMessage(Entity.DELEGATE, delegateEmail, PHRASE_DUPLICATE), j, jcount)
              Indent.Decrement()
            else:
              if not invalidInput:
                delegatorOK = False
                entityActionFailedWarning([Entity.DELEGATOR, delegatorEmail], u'errorCode: {0}, reason: {1}'.format(errorCode, reason), i, count)
              else:
                Indent.Increment()
                entityActionFailedWarning([Entity.DELEGATOR, delegatorEmail], entityTypeNameMessage(Entity.DELEGATE, delegateEmail, u'errorCode: {0}, reason: {1}'.format(errorCode, reason)), j, jcount)
                Indent.Decrement()
          else:
            delegatorOK = _checkDelegatorDelegate(i, count, j, jcount)
          break
        if httpStatus < 500:
          delegatorOK = _checkDelegatorDelegate(i, count, j, jcount)
          break
        tg = HTTP_4XX_5XX_RESULT_PATTERN.search(result)
        reason = tg.group(1) if tg is not None else u'Unknown Error'
        waitOnFailure(n, retries, httpStatus, reason)
      else: #retries exceeded
        delegatorOK = _checkDelegatorDelegate(i, count, j, jcount)
      if not delegatorOK:
        break

# gam <UserTypeEntity> delete delegate|delegates <UserEntity>>
def deleteDelegate(users):
  emailSettings = buildGAPIObject(EMAIL_SETTINGS_API)
  delegateEntity = getUserObjectEntity(OB_USER_ENTITY, Entity.DELEGATE)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    delegatorEmail, delegatorName, delegatorDomain, delegates, jcount = _validateDelegatorGetObjectList(user, i, count, delegateEntity)
    Indent.Increment()
    j = 0
    for delegate in delegates:
      j += 1
      delegateEmail = addDomainToEmailAddressOrUID(delegate, delegatorDomain)
      if not delegateEmail:
        entityActionFailedWarning([Entity.DELEGATOR, delegatorEmail, Entity.DELEGATE, delegate], PHRASE_DOES_NOT_EXIST, j, jcount)
        continue
      try:
        callGAPI(emailSettings.delegates(), u'delete',
                 throw_reasons=[GAPI_NOT_FOUND, GAPI_SERVICE_NOT_AVAILABLE, GAPI_DOMAIN_NOT_FOUND, GAPI_INVALID_INPUT],
                 v=u'2.0', delegator=delegatorName, domainName=delegatorDomain, delegate=delegateEmail)
        entityActionPerformed([Entity.DELEGATOR, delegatorEmail, Entity.DELEGATE, delegateEmail], j, jcount)
      except (GAPI_notFound, GAPI_serviceNotAvailable, GAPI_domainNotFound):
        entityServiceNotApplicableWarning(Entity.DELEGATOR, delegatorEmail, i, count)
        break
      except GAPI_invalidInput as e:
        entityActionFailedWarning([Entity.DELEGATOR, delegatorEmail, Entity.DELEGATE, delegateEmail], e.message, j, jcount)
    Indent.Decrement()

def _printShowDelegates(users, csvFormat):

  def getDelegateFields(delegate):
    delegateName = u''
    delegateAddress = u''
    delegationId = u''
    delegateStatus = u''
    for item in delegate[u'apps$property']:
      if item[u'name'] == u'delegate':
        delegateName = item[u'value']
      elif item[u'name'] == u'address':
        delegateAddress = item[u'value']
      elif item[u'name'] == u'delegationId':
        delegationId = item[u'value']
      elif item[u'name'] == u'status':
        delegateStatus = item[u'value']
    return delegateName, delegateAddress, delegationId, delegateStatus

  emailSettings = buildGAPIObject(EMAIL_SETTINGS_API)
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile([u'Delegator', u'Delegate', u'Delegate Email', u'Delegation ID', u'Status'])
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    delegatorEmail, delegatorName, delegatorDomain = splitEmailAddressOrUID(user)
    if csvFormat:
      printGettingAllEntityItemsForWhom(Entity.DELEGATE, delegatorEmail, i, count)
    try:
      result = callGAPI(emailSettings.delegates(), u'get',
                        throw_reasons=[GAPI_NOT_FOUND, GAPI_SERVICE_NOT_AVAILABLE, GAPI_DOMAIN_NOT_FOUND],
                        v=u'2.0', delegator=delegatorName, domainName=delegatorDomain)
      if result is not None and u'feed' in result and u'entry' in result[u'feed']:
        delegates = result[u'feed'][u'entry']
        jcount = len(delegates)
        if not csvFormat:
          entityPerformActionNumItems([Entity.DELEGATOR, delegatorEmail], jcount, Entity.DELEGATE, i, count)
        if jcount == 0:
          setSysExitRC(NO_ENTITIES_FOUND)
          continue
        if not csvFormat:
          Indent.Increment()
          j = 0
          for delegate in delegates:
            j += 1
            delegateName, delegateAddress, delegationID, delegateStatus = getDelegateFields(delegate)
            printEntity([Entity.DELEGATE, delegateName], j, jcount)
            Indent.Increment()
            printKeyValueList([u'Delegate Email', delegateAddress])
            printKeyValueList([u'Delegation ID', delegationID])
            printKeyValueList([u'Status', delegateStatus])
            Indent.Decrement()
          Indent.Decrement()
        else:
          for delegate in delegates:
            delegateName, delegateAddress, delegationID, delegateStatus = getDelegateFields(delegate)
            csvRows.append({u'Delegator': delegatorEmail, u'Delegate': delegateName, u'Delegate Email': delegateAddress, u'Delegation ID': delegationID, u'Status': delegateStatus})
    except (GAPI_notFound, GAPI_serviceNotAvailable, GAPI_domainNotFound):
      entityServiceNotApplicableWarning(Entity.DELEGATOR, delegatorEmail, i, count)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Delegates', todrive)

# gam <UserTypeEntity> print delegates|delegate [todrive [<ToDriveAttributes>]]
def printDelegates(users):
  _printShowDelegates(users, True)

# gam <UserTypeEntity> show delegates|delegate
def showDelegates(users):
  _printShowDelegates(users, False)

FILTER_ADD_LABEL_TO_ARGUMENT_MAP = {
  u'IMPORTANT': u'important',
  u'STARRED': u'star',
  u'TRASH': u'trash',
  }

FILTER_REMOVE_LABEL_TO_ARGUMENT_MAP = {
  u'IMPORTANT': u'notimportant',
  u'UNREAD': u'markread',
  u'INBOX': u'archive',
  u'SPAM': u'neverspam',
  }

def _printFilter(user, userFilter, labels):
  row = {u'User': user, u'id': userFilter[u'id']}
  if u'criteria' in userFilter:
    for item in userFilter[u'criteria']:
      if item in [u'hasAttachment', u'excludeChats']:
        row[item] = item
      elif item == u'size':
        row[item] = u'size {0} {1}'.format(userFilter[u'criteria'][u'sizeComparison'], formatMaxMessageBytes(userFilter[u'criteria'][item]))
      elif item == u'sizeComparison':
        pass
      else:
        row[item] = u'{0} {1}'.format(item, userFilter[u'criteria'][item])
  else:
    row[u'error'] = u'NoCriteria'
  if u'action' in userFilter:
    for labelId in userFilter[u'action'].get(u'addLabelIds', []):
      if labelId in FILTER_ADD_LABEL_TO_ARGUMENT_MAP:
        row[FILTER_ADD_LABEL_TO_ARGUMENT_MAP[labelId]] = FILTER_ADD_LABEL_TO_ARGUMENT_MAP[labelId]
      else:
        row[u'label'] = u'label {0}'.format(_getLabelName(labels, labelId))
    for labelId in userFilter[u'action'].get(u'removeLabelIds', []):
      if labelId in FILTER_REMOVE_LABEL_TO_ARGUMENT_MAP:
        row[FILTER_REMOVE_LABEL_TO_ARGUMENT_MAP[labelId]] = FILTER_REMOVE_LABEL_TO_ARGUMENT_MAP[labelId]
    if userFilter[u'action'].get(u'forward'):
      row[u'forward'] = u'forward {0}'.format(userFilter[u'action'][u'forward'])
  else:
    row[u'error'] = u'NoActions'
  return row

def _showFilter(userFilter, j, jcount, labels):
  printEntity([Entity.FILTER, userFilter[u'id']], j, jcount)
  Indent.Increment()
  printEntitiesCount(Entity.CRITERIA, None)
  Indent.Increment()
  if u'criteria' in userFilter:
    for item in userFilter[u'criteria']:
      if item in [u'hasAttachment', u'excludeChats']:
        printKeyValueList([item])
      elif item == u'size':
        printKeyValueList([u'{0} {1} {2}'.format(item, userFilter[u'criteria'][u'sizeComparison'], formatMaxMessageBytes(userFilter[u'criteria'][item]))])
      elif item == u'sizeComparison':
        pass
      else:
        printKeyValueList([u'{0} "{1}"'.format(item, userFilter[u'criteria'][item])])
  else:
    printKeyValueList([ERROR, PHRASE_NO_FILTER_CRITERIA.format(Entity.Singular(Entity.FILTER))])
  Indent.Decrement()
  printEntitiesCount(Entity.ACTION, None)
  Indent.Increment()
  if u'action' in userFilter:
    for labelId in userFilter[u'action'].get(u'addLabelIds', []):
      if labelId in FILTER_ADD_LABEL_TO_ARGUMENT_MAP:
        printKeyValueList([FILTER_ADD_LABEL_TO_ARGUMENT_MAP[labelId]])
      else:
        printKeyValueList([u'label "{0}"'.format(_getLabelName(labels, labelId))])
    for labelId in userFilter[u'action'].get(u'removeLabelIds', []):
      if labelId in FILTER_REMOVE_LABEL_TO_ARGUMENT_MAP:
        printKeyValueList([FILTER_REMOVE_LABEL_TO_ARGUMENT_MAP[labelId]])
    Indent.Decrement()
    if userFilter[u'action'].get(u'forward'):
      printEntity([Entity.FORWARDING_ADDRESS, userFilter[u'action'][u'forward']])
  else:
    printKeyValueList([ERROR, PHRASE_NO_FILTER_ACTIONS.format(Entity.Singular(Entity.FILTER))])
    Indent.Decrement()
  Indent.Decrement()
#
FILTER_CRITERIA_CHOICES_MAP = {
  u'excludechats': u'excludeChats',
  u'from': u'from',
  u'hasattachment': u'hasAttachment',
  u'haswords': u'query',
  u'musthaveattachment': u'hasAttachment',
  u'negatedquery': u'negatedQuery',
  u'nowords': u'negatedQuery',
  u'query': u'query',
  u'size': u'size',
  u'subject': u'subject',
  u'to': u'to',
  }
FILTER_ACTION_CHOICES = [u'archive', u'forward', u'important', u'label', u'markread', u'neverspam', u'notimportant', u'star', u'trash',]

# gam <UserTypeEntity> [add] filter [from <EmailAddress>] [to <EmailAddress>] [subject <String>] [haswords|query <List>] [nowords|negatedquery <List>] [musthaveattachment|hasattachment] [excludechats] [size larger|smaller <ByteCount>]
#	[label <LabelName>] [important|notimportant] [star] [trash] [markread] [archive] [neverspam] [forward <EmailAddress>]
def addFilter(users):
  body = {}
  addLabelName = None
  addLabelIds = []
  removeLabelIds = []
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in FILTER_CRITERIA_CHOICES_MAP:
      myarg = FILTER_CRITERIA_CHOICES_MAP[myarg]
      body.setdefault(u'criteria', {})
      if myarg in [u'from', u'to']:
        body[u'criteria'][myarg] = getEmailAddress(noUid=True)
      elif myarg in [u'subject', u'query', u'negatedQuery']:
        body[u'criteria'][myarg] = getString(OB_STRING)
      elif myarg in [u'hasAttachment', u'excludeChats']:
        body[u'criteria'][myarg] = True
      elif myarg == u'size':
        body[u'criteria'][u'sizeComparison'] = getChoice([u'larger', u'smaller'])
        body[u'criteria'][myarg] = getMaxMessageBytes()
    elif myarg in FILTER_ACTION_CHOICES:
      body.setdefault(u'action', {})
      if myarg == u'label':
        addLabelName = getString(OB_LABEL_NAME)
      elif myarg == u'important':
        addLabelIds.append(u'IMPORTANT')
        if u'IMPORTANT' in removeLabelIds:
          removeLabelIds.remove(u'IMPORTANT')
      elif myarg == u'star':
        addLabelIds.append(u'STARRED')
      elif myarg == u'trash':
        addLabelIds.append(u'TRASH')
      elif myarg == u'notimportant':
        removeLabelIds.append(u'IMPORTANT')
        if u'IMPORTANT' in addLabelIds:
          addLabelIds.remove(u'IMPORTANT')
      elif myarg == u'markread':
        removeLabelIds.append(u'UNREAD')
      elif myarg == u'archive':
        removeLabelIds.append(u'INBOX')
      elif myarg == u'neverspam':
        removeLabelIds.append(u'SPAM')
      elif myarg == u'forward':
        body[u'action'][u'forward'] = getEmailAddress(noUid=True)
    else:
      unknownArgumentExit()
  if u'criteria' not in body:
    missingChoiceExit(FILTER_CRITERIA_CHOICES_MAP)
  if u'action' not in body:
    missingChoiceExit(FILTER_ACTION_CHOICES)
  if removeLabelIds:
    body[u'action'][u'removeLabelIds'] = removeLabelIds
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(GMAIL_API, user)
    if not gmail:
      continue
    labels = _getUserGmailLabels(gmail, user, i, count, fields=u'labels(id,name)')
    if not labels:
      continue
    try:
      if addLabelIds:
        body[u'action'][u'addLabelIds'] = addLabelIds[:]
      if addLabelName:
        if not addLabelIds:
          body[u'action'][u'addLabelIds'] = []
        addLabelId = _getLabelId(labels, addLabelName)
        if not addLabelId:
          result = callGAPI(gmail.users().labels(), u'create',
                            throw_reasons=GAPI_GMAIL_THROW_REASONS,
                            userId=u'me', body={u'name': addLabelName}, fields=u'id')
          addLabelId = result[u'id']
        body[u'action'][u'addLabelIds'].append(addLabelId)
      result = callGAPI(gmail.users().settings().filters(), u'create',
                        throw_reasons=GAPI_GMAIL_THROW_REASONS+[GAPI_INVALID_ARGUMENT, GAPI_FAILED_PRECONDITION],
                        userId=u'me', body=body, fields=u'id')
      if result:
        entityActionPerformed([Entity.USER, user, Entity.FILTER, result[u'id']], i, count)
    except (GAPI_invalidArgument, GAPI_failedPrecondition) as e:
      entityActionFailedWarning([Entity.USER, user, Entity.FILTER, u''], e.message, i, count)
    except (GAPI_serviceNotAvailable, GAPI_badRequest):
      entityServiceNotApplicableWarning(Entity.USER, user, i, count)

# gam <UserTypeEntity> delete filter <FilterIDEntity>
def deleteFilters(users):
  filterIdEntity = getUserObjectEntity(OB_FILTER_ID_ENTITY, Entity.FILTER)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail, filterIds, jcount = _validateUserGetObjectList(user, i, count, filterIdEntity)
    if jcount == 0:
      continue
    Indent.Increment()
    j = 0
    for filterId in filterIds:
      j += 1
      try:
        callGAPI(gmail.users().settings().filters(), u'delete',
                 throw_reasons=GAPI_GMAIL_THROW_REASONS+[GAPI_NOT_FOUND],
                 userId=u'me', id=filterId)
        entityActionPerformed([Entity.USER, user, Entity.FILTER, filterId], j, jcount)
      except GAPI_notFound as e:
        entityActionFailedWarning([Entity.USER, user, Entity.FILTER, filterId], e.message, j, jcount)
      except (GAPI_serviceNotAvailable, GAPI_badRequest):
        entityServiceNotApplicableWarning(Entity.USER, user, i, count)
        break
    Indent.Decrement()

# gam <UserTypeEntity> info filters <FilterIDEntity>
def infoFilters(users):
  filterIdEntity = getUserObjectEntity(OB_FILTER_ID_ENTITY, Entity.FILTER)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail, filterIds, jcount = _validateUserGetObjectList(user, i, count, filterIdEntity)
    if jcount == 0:
      continue
    labels = _getUserGmailLabels(gmail, user, i, count, fields=u'labels(id,name)')
    if not labels:
      continue
    Indent.Increment()
    j = 0
    for filterId in filterIds:
      j += 1
      try:
        result = callGAPI(gmail.users().settings().filters(), u'get',
                          throw_reasons=GAPI_GMAIL_THROW_REASONS+[GAPI_NOT_FOUND],
                          userId=u'me', id=filterId)
        printEntityKVList([Entity.USER, user],
                          [Entity.Singular(Entity.FILTER), result[u'id']],
                          i, count)
        Indent.Increment()
        _showFilter(result, j, jcount, labels)
        Indent.Decrement()
      except GAPI_notFound as e:
        entityActionFailedWarning([Entity.USER, user, Entity.FILTER, filterId], e.message, j, jcount)
      except (GAPI_serviceNotAvailable, GAPI_badRequest):
        entityServiceNotApplicableWarning(Entity.USER, user, i, count)
        break
    Indent.Decrement()

def _printShowFilters(users, csvFormat):
  labelIdsOnly = False
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile(None)
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'labelidsonly':
      labelIdsOnly = True
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(GMAIL_API, user)
    if not gmail:
      continue
    if not labelIdsOnly:
      labels = _getUserGmailLabels(gmail, user, i, count, fields=u'labels(id,name)')
      if not labels:
        continue
    else:
      labels = {u'labels': []}
    try:
      result = callGAPI(gmail.users().settings().filters(), u'list',
                        throw_reasons=GAPI_GMAIL_THROW_REASONS,
                        userId=u'me')
      jcount = len(result.get(u'filter', [])) if (result) else 0
      if not csvFormat:
        entityPerformActionNumItems([Entity.USER, user], jcount, Entity.FILTER, i, count)
      if jcount == 0:
        setSysExitRC(NO_ENTITIES_FOUND)
        continue
      if not csvFormat:
        Indent.Increment()
        j = 0
        for userFilter in result[u'filter']:
          j += 1
          _showFilter(userFilter, j, jcount, labels)
        Indent.Decrement()
      else:
        for userFilter in result[u'filter']:
          addRowTitlesToCSVfile(_printFilter(user, userFilter, labels), csvRows, titles)
    except (GAPI_serviceNotAvailable, GAPI_badRequest):
      entityServiceNotApplicableWarning(Entity.USER, user, i, count)
  if csvFormat:
    sortCSVTitles([u'User', u'id'], titles)
    writeCSVfile(csvRows, titles, u'Filters', todrive)

# gam <UserTypeEntity> print filters [todrive [<ToDriveAttributes>]]
def printFilters(users):
  _printShowFilters(users, True)

# gam <UserTypeEntity> show filters
def showFilters(users):
  _printShowFilters(users, False)

EMAILSETTINGS_OLD_NEW_OLD_FORWARD_ACTION_MAP = {
  u'ARCHIVE': u'archive',
  u'DELETE': u'trash',
  u'KEEP': u'leaveInInBox',
  u'MARK_READ': u'markRead',
  u'archive': u'ARCHIVE',
  u'trash': u'DELETE',
  u'leaveInInbox': u'KEEP',
  u'markRead': u'MARK_READ',
  }

def _showForward(user, i, count, result):
  if u'enabled' in result:
    enabled = result[u'enabled']
    kvList = [Entity.Singular(Entity.FORWARD_ENABLED), enabled]
    if enabled:
      kvList += [Entity.Singular(Entity.FORWARDING_ADDRESS), result[u'emailAddress']]
      kvList += [Entity.Singular(Entity.ACTION), result[u'disposition']]
  else:
    enabled = result[u'enable'] == u'true'
    kvList = [Entity.Singular(Entity.FORWARD_ENABLED), enabled]
    if enabled:
      kvList += [Entity.Singular(Entity.FORWARDING_ADDRESS), result[u'forwardTo']]
      kvList += [Entity.Singular(Entity.ACTION), EMAILSETTINGS_OLD_NEW_OLD_FORWARD_ACTION_MAP[result[u'action']]]
  printEntityKVList([Entity.USER, user], kvList, i, count)

EMAILSETTINGS_FORWARD_POP_ACTION_CHOICES_MAP = {
  u'archive': u'archive',
  u'delete': u'trash',
  u'keep': u'leaveInInbox',
  u'leaveininbox': u'leaveInInbox',
  u'markread': u'markRead',
  u'trash': u'trash',
  }

# gam <UserTypeEntity> forward <FalseValues>
# gam <UserTypeEntity> forward <TrueValues> keep|leaveininbox|archive|delete|trash|markread <EmailAddress>
def setForward(users):
  enable = getBoolean()
  body = {u'enabled': enable}
  if enable:
    while CLArgs.ArgumentsRemaining():
      myarg = getArgument()
      if myarg in EMAILSETTINGS_FORWARD_POP_ACTION_CHOICES_MAP:
        body[u'disposition'] = EMAILSETTINGS_FORWARD_POP_ACTION_CHOICES_MAP[myarg]
      elif myarg == u'confirm':
        pass
      elif myarg.find(u'@') != -1:
        body[u'emailAddress'] = normalizeEmailAddressOrUID(CLArgs.Previous())
      else:
        unknownArgumentExit()
    if not body.get(u'disposition'):
      missingChoiceExit(EMAILSETTINGS_FORWARD_POP_ACTION_CHOICES_MAP)
    if not body.get(u'emailAddress'):
      missingArgumentExit(OB_EMAIL_ADDRESS)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(GMAIL_API, user)
    if not gmail:
      continue
    try:
      result = callGAPI(gmail.users().settings(), u'updateAutoForwarding',
                        throw_reasons=GAPI_GMAIL_THROW_REASONS+[GAPI_FAILED_PRECONDITION],
                        userId=u'me', body=body)
      _showForward(user, i, count, result)
    except GAPI_failedPrecondition as e:
      entityActionFailedWarning([Entity.USER, user, Entity.FORWARDING_ADDRESS, body[u'emailAddress']], e.message, i, count)
    except (GAPI_serviceNotAvailable, GAPI_badRequest):
      entityServiceNotApplicableWarning(Entity.USER, user, i, count)

def _printShowForward(users, csvFormat):
  def _printForward(user, result):
    if u'enabled' in result:
      row = {u'User': user, u'forwardEnabled': result[u'enabled']}
      if result[u'enabled']:
        row[u'forwardTo'] = result[u'emailAddress']
        row[u'disposition'] = result[u'disposition']
    else:
      row = {u'User': user, u'forwardEnabled': result[u'enable']}
      if result[u'enable'] == u'true':
        row[u'forwardTo'] = result[u'forwardTo']
        row[u'disposition'] = EMAILSETTINGS_OLD_NEW_OLD_FORWARD_ACTION_MAP[result[u'action']]
    csvRows.append(row)

  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile([u'User', u'forwardEnabled', u'forwardTo', u'disposition'])
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(GMAIL_API, user)
    if not gmail:
      continue
    try:
      result = callGAPI(gmail.users().settings(), u'getAutoForwarding',
                        throw_reasons=GAPI_GMAIL_THROW_REASONS,
                        userId=u'me')
      if not csvFormat:
        _showForward(user, i, count, result)
      else:
        _printForward(user, result)
    except (GAPI_serviceNotAvailable, GAPI_badRequest):
      entityServiceNotApplicableWarning(Entity.USER, user, i, count)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Forward', todrive)

# gam <UserTypeEntity> print forward [todrive [<ToDriveAttributes>]]
def printForward(users):
  _printShowForward(users, True)

# gam <UserTypeEntity> show forward
def showForward(users):
  _printShowForward(users, False)

# Process ForwardingAddresses functions
def _showForwardingAddress(j, jcount, result):
  printEntityKVList([Entity.FORWARDING_ADDRESS, result[u'forwardingEmail']], [u'Verification Status', result[u'verificationStatus']], j, jcount)

def _processForwardingAddress(user, i, count, emailAddress, j, jcount, gmail, function, **kwargs):
  userDefined = True
  try:
    result = callGAPI(gmail.users().settings().forwardingAddresses(), function,
                      throw_reasons=GAPI_GMAIL_THROW_REASONS+[GAPI_NOT_FOUND, GAPI_ALREADY_EXISTS, GAPI_DUPLICATE],
                      userId=u'me', **kwargs)
    if function == u'get':
      _showForwardingAddress(j, count, result)
    else:
      entityActionPerformed([Entity.USER, user, Entity.FORWARDING_ADDRESS, emailAddress], j, jcount)
  except (GAPI_notFound, GAPI_alreadyExists, GAPI_duplicate) as e:
    entityActionFailedWarning([Entity.USER, user, Entity.FORWARDING_ADDRESS, emailAddress], e.message, j, jcount)
  except (GAPI_serviceNotAvailable, GAPI_badRequest, GAPI_authError):
    entityServiceNotApplicableWarning(Entity.USER, user, i, count)
    userDefined = False
  return userDefined

# gam <UserTypeEntity> add forwardingaddresses <EmailAddressEntity>
def addForwardingAddresses(users):
  emailAddressEntity = getUserObjectEntity(OB_EMAIL_ADDRESS_ENTITY, Entity.FORWARDING_ADDRESS)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail, emailAddresses, jcount = _validateUserGetObjectList(user, i, count, emailAddressEntity)
    if jcount == 0:
      continue
    Indent.Increment()
    j = 0
    for emailAddress in emailAddresses:
      j += 1
      emailAddress = normalizeEmailAddressOrUID(emailAddress, noUid=True)
      body = {u'forwardingEmail': emailAddress}
      if not _processForwardingAddress(user, i, count, emailAddress, j, jcount, gmail, u'create', body=body, fields=u''):
        break
    Indent.Decrement()

def _deleteInfoForwardingAddreses(users, function):
  emailAddressEntity = getUserObjectEntity(OB_EMAIL_ADDRESS_ENTITY, Entity.FORWARDING_ADDRESS)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail, emailAddresses, jcount = _validateUserGetObjectList(user, i, count, emailAddressEntity)
    if jcount == 0:
      continue
    Indent.Increment()
    j = 0
    for emailAddress in emailAddresses:
      j += 1
      emailAddress = normalizeEmailAddressOrUID(emailAddress, noUid=True)
      if not _processForwardingAddress(user, i, count, emailAddress, j, jcount, gmail, function, forwardingEmail=emailAddress):
        break
    Indent.Decrement()

# gam <UserTypeEntity> delete forwardingaddresses <EmailAddressEntity>
def deleteForwardingAddresses(users):
  _deleteInfoForwardingAddreses(users, u'delete')

# gam <UserTypeEntity> info forwardingaddresses <EmailAddressEntity>
def infoForwardingAddresses(users):
  _deleteInfoForwardingAddreses(users, u'get')

def _printShowForwardingAddresses(users, csvFormat):
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile([u'User', u'forwardingEmail', u'verificationStatus'])
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(GMAIL_API, user)
    if not gmail:
      continue
    try:
      result = callGAPI(gmail.users().settings().forwardingAddresses(), u'list',
                        throw_reasons=GAPI_GMAIL_THROW_REASONS,
                        userId=u'me')
      jcount = len(result.get(u'forwardingAddresses', [])) if (result) else 0
      if not csvFormat:
        entityPerformActionNumItems([Entity.USER, user], jcount, Entity.FORWARDING_ADDRESS, i, count)
      if jcount == 0:
        setSysExitRC(NO_ENTITIES_FOUND)
        continue
      if not csvFormat:
        Indent.Increment()
        j = 0
        for forward in result[u'forwardingAddresses']:
          j += 1
          _showForwardingAddress(j, jcount, forward)
        Indent.Decrement()
      else:
        for forward in result[u'forwardingAddresses']:
          csvRows.append({u'User': user, u'forwardingEmail': forward[u'forwardingEmail'], u'verificationStatus': forward[u'verificationStatus']})
    except (GAPI_serviceNotAvailable, GAPI_badRequest):
      entityServiceNotApplicableWarning(Entity.USER, user, i, count)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Forwarding Addresses', todrive)

# gam <UserTypeEntity> print forwardingaddresses [todrive [<ToDriveAttributes>]]
def printForwardingAddresses(users):
  _printShowForwardingAddresses(users, True)

# gam <UserTypeEntity> show forwardingaddresses
def showForwardingAddresses(users):
  _printShowForwardingAddresses(users, False)

def _showImap(user, i, count, result):
  enabled = result[u'enabled']
  kvList = [Entity.Singular(Entity.IMAP_ENABLED), enabled]
  if enabled:
    for item in result:
      if item != u'enabled':
        kvList += [item, result[item]]
  printEntityKVList([Entity.USER, user], kvList, i, count)
#
EMAILSETTINGS_IMAP_EXPUNGE_BEHAVIOR_CHOICES_MAP = {
  u'archive': u'archive',
  u'deleteforever': u'deleteForever',
  u'trash': u'trash',
  }

EMAILSETTINGS_IMAP_MAX_FOLDER_SIZE_CHOICES = [u'0', u'1000', u'2000', u'5000', u'10000']

# gam <UserTypeEntity> imap|imap4 <Boolean> [noautoexpunge] [expungebehavior archive|deleteforever|trash] [maxfoldersize 0|1000|2000|5000|10000]
def setImap(users):
  enable = getBoolean()
  body = {u'enabled': enable, u'autoExpunge': True, u'expungeBehavior': u'archive', u'maxFolderSize': 0}
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'noautoexpunge':
      body[u'autoExpunge'] = False
    elif myarg == u'expungebehavior':
      body[u'expungeBehavior'] = getChoice(EMAILSETTINGS_IMAP_EXPUNGE_BEHAVIOR_CHOICES_MAP, mapChoice=True)
    elif myarg == u'maxfoldersize':
      body[u'maxFolderSize'] = int(getChoice(EMAILSETTINGS_IMAP_MAX_FOLDER_SIZE_CHOICES))
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(GMAIL_API, user)
    if not gmail:
      continue
    try:
      result = callGAPI(gmail.users().settings(), u'updateImap',
                        throw_reasons=GAPI_GMAIL_THROW_REASONS,
                        userId=u'me', body=body)
      _showImap(user, i, count, result)
    except (GAPI_serviceNotAvailable, GAPI_badRequest):
      entityServiceNotApplicableWarning(Entity.USER, user, i, count)

# gam <UserTypeEntity> show imap|imap4
def showImap(users):
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(GMAIL_API, user)
    if not gmail:
      continue
    try:
      result = callGAPI(gmail.users().settings(), u'getImap',
                        throw_reasons=GAPI_GMAIL_THROW_REASONS,
                        userId=u'me')
      _showImap(user, i, count, result)
    except (GAPI_serviceNotAvailable, GAPI_badRequest):
      entityServiceNotApplicableWarning(Entity.USER, user, i, count)

def _showPop(user, i, count, result):
  enabled = result[u'accessWindow'] != u'disabled'
  kvList = [Entity.Singular(Entity.POP_ENABLED), enabled]
  if enabled:
    kvList += [u'For', result[u'accessWindow'], Entity.Singular(Entity.ACTION), result[u'disposition']]
  printEntityKVList([Entity.USER, user], kvList, i, count)
#
EMAILSETTINGS_POP_ENABLE_FOR_CHOICES_MAP = {
  u'allmail': u'allMail',
  u'fromnowon': u'fromNowOn',
  u'mailfromnowon': u'fromNowOn',
  u'newmail': u'fromNowOn',
  }

# gam <UserTypeEntity> pop|pop3 <Boolean> [for allmail|newmail|mailfromnowon|fromnowown] [action keep|leaveininbox|archive|delete|trash|markread]
def setPop(users):
  enable = getBoolean()
  body = {u'accessWindow': [u'disabled', u'allMail'][enable], u'disposition': u'leaveInInbox'}
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'for':
      body[u'accessWindow'] = getChoice(EMAILSETTINGS_POP_ENABLE_FOR_CHOICES_MAP, mapChoice=True)
    elif myarg == u'action':
      body[u'disposition'] = getChoice(EMAILSETTINGS_FORWARD_POP_ACTION_CHOICES_MAP, mapChoice=True)
    elif myarg == u'confirm':
      pass
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(GMAIL_API, user)
    if not gmail:
      continue
    try:
      result = callGAPI(gmail.users().settings(), u'updatePop',
                        throw_reasons=GAPI_GMAIL_THROW_REASONS,
                        userId=u'me', body=body)
      _showPop(user, i, count, result)
    except (GAPI_serviceNotAvailable, GAPI_badRequest):
      entityServiceNotApplicableWarning(Entity.USER, user, i, count)

# gam <UserTypeEntity> show pop|pop3
def showPop(users):
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(GMAIL_API, user)
    if not gmail:
      continue
    try:
      result = callGAPI(gmail.users().settings(), u'getPop',
                        throw_reasons=GAPI_GMAIL_THROW_REASONS,
                        userId=u'me')
      _showPop(user, i, count, result)
    except (GAPI_serviceNotAvailable, GAPI_badRequest):
      entityServiceNotApplicableWarning(Entity.USER, user, i, count)

# gam <UserTypeEntity> language <Language>
def setLanguage(users):
  emailSettings = getEmailSettingsObject()
  language = getChoice(LANGUAGE_CODES_MAP, mapChoice=True)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, userName, emailSettings.domain = splitEmailAddressOrUID(user)
    result = _processEmailSettings(user, i, count, emailSettings, u'UpdateLanguage',
                                   username=userName, language=language)
    if result:
      printEntity([Entity.USER, user, Entity.LANGUAGE, result[u'language']], i, count)

VALID_PAGESIZES = [u'25', u'50', u'100']

# gam <UserTypeEntity> pagesize 25|50|100
def setPageSize(users):
  emailSettings = getEmailSettingsObject()
  PageSize = getChoice(VALID_PAGESIZES)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, userName, emailSettings.domain = splitEmailAddressOrUID(user)
    result = _processEmailSettings(user, i, count, emailSettings, u'UpdateGeneral',
                                   username=userName, page_size=PageSize)
    if result:
      printEntity([Entity.USER, user, Entity.PAGE_SIZE, result[u'pageSize']], i, count)

def _showSendAs(result, j, jcount, formatSig):
  if result[u'displayName']:
    printEntity([Entity.SENDAS_ADDRESS, u'{0} <{1}>'.format(result[u'displayName'], result[u'sendAsEmail'])], j, jcount)
  else:
    printEntity([Entity.SENDAS_ADDRESS, u'<{0}>'.format(result[u'sendAsEmail'])], j, jcount)
  Indent.Increment()
  if result.get(u'replyToAddress'):
    printKeyValueList([u'ReplyTo', result[u'replyToAddress']])
  printKeyValueList([u'IsPrimary', result.get(u'isPrimary', False)])
  printKeyValueList([u'Default', result.get(u'isDefault', False)])
  if not result.get(u'isPrimary', False):
    printKeyValueList([u'TreatAsAlias', result.get(u'treatAsAlias', False)])
    printKeyValueList([u'Verification Status', result.get(u'verificationStatus', u'unspecified')])
  if formatSig:
    printKeyValueList([u'Signature', None])
    Indent.Increment()
    signature = result.get(u'signature')
    if not signature:
      signature = u'None'
    printKeyValueList([Indent.MultiLineText(dehtml(signature))])
    Indent.Decrement()
  else:
    signature = result.get(u'signature')
    if not signature:
      signature = u'None'
    printKeyValueList([u'Signature', convertCRsNLs(signature)])
  Indent.Decrement()

RT_PATTERN = re.compile(r'(?s){RT}.*?{(.+?)}.*?{/RT}')
RT_OPEN_PATTERN = re.compile(r'{RT}')
RT_CLOSE_PATTERN = re.compile(r'{/RT}')
RT_STRIP_PATTERN = re.compile(r'(?s){RT}.*?{/RT}')
RT_TAG_REPLACE_PATTERN = re.compile(r'{(.*?)}')

def _processTags(tagReplacements, message):
  while True:
    match = RT_PATTERN.search(message)
    if not match:
      break
    if tagReplacements.get(match.group(1)):
      message = RT_OPEN_PATTERN.sub(u'', message, count=1)
      message = RT_CLOSE_PATTERN.sub(u'', message, count=1)
    else:
      message = RT_STRIP_PATTERN.sub(u'', message, count=1)
  while True:
    match = RT_TAG_REPLACE_PATTERN.search(message)
    if not match:
      break
    message = re.sub(match.group(0), tagReplacements.get(match.group(1), u''), message)
  return message

def _processSignature(tagReplacements, signature, html):
  if signature:
    signature = signature.replace(u'\r', u'').replace(u'\\n', u'<br/>')
    if tagReplacements:
      signature = _processTags(tagReplacements, signature)
    if not html:
      signature = signature.replace(u'\n', u'<br/>')
  return signature

# Process SendAs functions
def _processSendAs(user, i, count, entityType, emailAddress, j, jcount, gmail, function, formatSig, **kwargs):
  userDefined = True
  try:
    result = callGAPI(gmail.users().settings().sendAs(), function,
                      throw_reasons=GAPI_GMAIL_THROW_REASONS+[GAPI_NOT_FOUND, GAPI_ALREADY_EXISTS, GAPI_DUPLICATE, GAPI_CANNOT_DELETE_PRIMARY_SENDAS, GAPI_INVALID_ARGUMENT],
                      userId=u'me', **kwargs)
    if function == u'get':
      _showSendAs(result, j, jcount, formatSig)
    else:
      entityActionPerformed([Entity.USER, user, entityType, emailAddress], j, jcount)
  except (GAPI_notFound, GAPI_alreadyExists, GAPI_duplicate, GAPI_cannotDeletePrimarySendAs, GAPI_invalidArgument) as e:
    entityActionFailedWarning([Entity.USER, user, entityType, emailAddress], e.message, j, jcount)
  except (GAPI_serviceNotAvailable, GAPI_badRequest, GAPI_authError):
    entityServiceNotApplicableWarning(Entity.USER, user, i, count)
    userDefined = False
  return userDefined

def getSendAsAttributes(myarg, body, tagReplacements):
  if myarg == u'replace':
    matchTag = getString(OB_TAG)
    matchReplacement = getString(OB_STRING, minLen=0)
    tagReplacements[matchTag] = matchReplacement
  elif myarg == u'name':
    body[u'displayName'] = getString(OB_NAME, minLen=0)
  elif myarg == u'replyto':
    body[u'replyToAddress'] = getEmailAddress(noUid=True)
  elif myarg == u'default':
    body[u'isDefault'] = True
  elif myarg == u'treatasalias':
    body[u'treatAsAlias'] = getBoolean()
  else:
    unknownArgumentExit()

def _addUpdateSendAs(users, addCmd):
  emailAddress = getEmailAddress(noUid=True)
  if addCmd:
    body = {u'sendAsEmail': emailAddress, u'displayName': getString(OB_NAME)}
  else:
    body = {}
  signature = None
  tagReplacements = {}
  html = False
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in [u'signature', u'sig']:
      if checkArgumentPresent(FILE_ARGUMENT):
        filename = getString(OB_FILE_NAME)
        encoding = getCharSet()
        signature = readFile(filename, encoding=encoding)
      else:
        signature = getString(OB_STRING, minLen=0)
    elif myarg == u'html':
      html = True
    else:
      getSendAsAttributes(myarg, body, tagReplacements)
  if signature is not None:
    body[u'signature'] = _processSignature(tagReplacements, signature, html)
  kwargs = {u'body': body, u'fields': u''}
  if not addCmd:
    kwargs[u'sendAsEmail'] = emailAddress
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(GMAIL_API, user)
    if not gmail:
      continue
    _processSendAs(user, i, count, Entity.SENDAS_ADDRESS, emailAddress, i, count, gmail, [u'patch', u'create'][addCmd], False, **kwargs)

# gam <UserTypeEntity> [add] sendas <EmailAddress> <String> [signature|sig <String>|(file <FileName> [charset <CharSet>]) (replace <RegularExpression> <String>)*] [html] [replyto <EmailAddress>] [default] [treatasalias <Boolean>]
def addSendAs(users):
  _addUpdateSendAs(users, True)

# gam <UserTypeEntity> update sendas <EmailAddress> [name <String>] [signature|sig <String>|(file <FileName> [charset <CharSet>]) (replace <RegularExpression> <String>)*] [html] [replyto <EmailAddress>] [default] [treatasalias <Boolean>]
def updateSendAs(users):
  _addUpdateSendAs(users, False)

def _deleteInfoSendAs(users, function):
  emailAddressEntity = getUserObjectEntity(OB_EMAIL_ADDRESS_ENTITY, Entity.SENDAS_ADDRESS)
  formatSig = False
  if function == u'get':
    while CLArgs.ArgumentsRemaining():
      myarg = getArgument()
      if myarg == u'format':
        formatSig = True
      else:
        unknownArgumentExit()
  else:
    checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail, emailAddresses, jcount = _validateUserGetObjectList(user, i, count, emailAddressEntity)
    if jcount == 0:
      continue
    Indent.Increment()
    j = 0
    for emailAddress in emailAddresses:
      j += 1
      emailAddress = normalizeEmailAddressOrUID(emailAddress, noUid=True)
      if not _processSendAs(user, i, count, Entity.SENDAS_ADDRESS, emailAddress, j, jcount, gmail, function, formatSig, sendAsEmail=emailAddress):
        break
    Indent.Decrement()

# gam <UserTypeEntity> delete sendas <EmailAddressEntity>
def deleteSendAs(users):
  _deleteInfoSendAs(users, u'delete')

# gam <UserTypeEntity> info sendas <EmailAddressEntity> [format]
def infoSendAs(users):
  _deleteInfoSendAs(users, u'get')

def _printShowSendAs(users, csvFormat):
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile([u'User', u'displayName', u'sendAsEmail', u'replyToAddress', u'isPrimary', u'isDefault', u'treatAsAlias', u'verificationStatus'])
  formatSig = False
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif not csvFormat and myarg == u'format':
      formatSig = True
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(GMAIL_API, user)
    if not gmail:
      continue
    try:
      result = callGAPI(gmail.users().settings().sendAs(), u'list',
                        throw_reasons=GAPI_GMAIL_THROW_REASONS,
                        userId=u'me')
      jcount = len(result.get(u'sendAs', [])) if (result) else 0
      if not csvFormat:
        entityPerformActionNumItems([Entity.USER, user], jcount, Entity.SENDAS_ADDRESS, i, count)
      if jcount == 0:
        setSysExitRC(NO_ENTITIES_FOUND)
        continue
      if not csvFormat:
        Indent.Increment()
        j = 0
        for sendas in result[u'sendAs']:
          j += 1
          _showSendAs(sendas, j, jcount, formatSig)
        Indent.Decrement()
      else:
        for sendas in result[u'sendAs']:
          row = {u'User': user, u'isPrimary': False}
          for item in sendas:
            row[item] = sendas[item]
          addRowTitlesToCSVfile(row, csvRows, titles)
    except (GAPI_serviceNotAvailable, GAPI_badRequest):
      entityServiceNotApplicableWarning(Entity.USER, user, i, count)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'SendAs', todrive)

# gam <UserTypeEntity> print sendas [todrive [<ToDriveAttributes>]]
def printSendAs(users):
  _printShowSendAs(users, True)

# gam <UserTypeEntity> show sendas [format]
def showSendAs(users):
  _printShowSendAs(users, False)

# gam <UserTypeEntity> add smime file <FileName> [password <Password>] [sendas|sendasemail <EmailAddress>] [default]
def addSmime(users):
  sendAsEmailBase = None
  smimefile = None
  body = {u'isDefault': False}
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'file':
      smimefile = getString(OB_FILE_NAME)
    elif myarg == u'password':
      body[u'encryptedKeyPassword'] = getString(OB_PASSWORD)
    elif myarg == u'default':
      body[u'isDefault'] = True
    elif myarg in [u'sendas', u'sendasemail']:
      sendAsEmailBase = getEmailAddress(noUid=True)
    else:
      unknownArgumentExit()
  if not smimefile:
    missingArgumentExit(u'file')
  smime_data = readFile(smimefile)
  body[u'pkcs12'] = base64.urlsafe_b64encode(smime_data)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(GMAIL_API, user)
    if not gmail:
      continue
    sendAsEmail = sendAsEmailBase if sendAsEmailBase else user
    try:
      result = callGAPI(gmail.users().settings().sendAs().smimeInfo(), u'insert',
                        throw_reasons=GAPI_GMAIL_SMIME_THROW_REASONS,
                        userId=u'me', sendAsEmail=sendAsEmail, body=body, fields=u'id,issuerCn')
      entityModifierNewValueActionPerformed([Entity.USER, user, Entity.SENDAS_ADDRESS, sendAsEmail, Entity.SMIME_ID, result[u'id']],
                                            Action.MODIFIER_FROM, u'{0}: {1}'.format(Entity.Singular(Entity.ISSUER_CN), result[u'issuerCn']), i, count)
    except GAPI_forbidden as e:
      entityActionFailedWarning([Entity.USER, user], e.message, i, count)
    except (GAPI_serviceNotAvailable, GAPI_badRequest):
      entityServiceNotApplicableWarning(Entity.USER, user, i, count)

def _getSmimeIds(gmail, user, i, count, sendAsEmail, function):
  try:
    result = callGAPI(gmail.users().settings().sendAs().smimeInfo(), u'list',
                      throw_reasons=GAPI_GMAIL_SMIME_THROW_REASONS,
                      userId=u'me', sendAsEmail=sendAsEmail, fields=u'smimeInfo(id)')
    smimes = result.get(u'smimeInfo', [])
    jcount = len(smimes)
    if jcount == 0:
      entityActionNotPerformedWarning([Entity.USER, user, Entity.SENDAS_ADDRESS, sendAsEmail, Entity.SMIME_ID, None],
                                      PHRASE_NO_ENTITIES_FOUND.format(Entity.Plural(Entity.SMIME_ID)), i, count)
      setSysExitRC(NO_ENTITIES_FOUND)
    elif jcount > 1:
      entityActionNotPerformedWarning([Entity.USER, user, Entity.SENDAS_ADDRESS, sendAsEmail, Entity.SMIME_ID, None],
                                      PHRASE_PLEASE_SELECT_ENTITY_TO_PROCESS.format(jcount, Entity.Plural(Entity.SMIME_ID), function, u'id <S/MIMEID>'),
                                      i, count)
      Indent.Increment()
      j = 0
      for smime in smimes:
        j += 1
        printEntityKVList([Entity.SMIME_ID, smime[u'id'], Entity.ISSUER_CN, smime[u'issuerCn']], [u'Default', smime.get(u'isDefault', False)], j, jcount)
      Indent.Decrement()
    else:
      return smimes[0][u'id']
  except GAPI_forbidden as e:
    entityActionFailedWarning([Entity.USER, user], e.message, i, count)
  except (GAPI_serviceNotAvailable, GAPI_badRequest):
    entityServiceNotApplicableWarning(Entity.USER, user, i, count)
  return None

# gam <UserTypeEntity> update smime [id <SmimeID>] [sendas|sendasemail <EmailAddress>] [default]
def updateSmime(users):
  smimeIdBase = None
  sendAsEmailBase = None
  setDefault = False
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'id':
      smimeIdBase = getString(OB_SMIME_ID)
    elif myarg in [u'sendas', u'sendasemail']:
      sendAsEmailBase = getEmailAddress(noUid=True)
    elif myarg == u'default':
      setDefault = True
    else:
      unknownArgumentExit()
  if not setDefault:
    missingArgumentExit(u'default')
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(GMAIL_API, user)
    if not gmail:
      continue
    sendAsEmail = sendAsEmailBase if sendAsEmailBase else user
    if not smimeIdBase:
      smimeId = _getSmimeIds(gmail, user, i, count, sendAsEmail, u'update')
      if not smimeId:
        continue
    else:
      smimeId = smimeIdBase
    try:
      callGAPI(gmail.users().settings().sendAs().smimeInfo(), u'setDefault',
               throw_reasons=GAPI_GMAIL_SMIME_THROW_REASONS,
               userId=u'me', sendAsEmail=sendAsEmail, id=smimeId)
      entityActionPerformed([Entity.USER, user, Entity.SENDAS_ADDRESS, sendAsEmail, Entity.SMIME_ID, smimeId], i, count)
    except GAPI_forbidden as e:
      entityActionFailedWarning([Entity.USER, user], e.message, i, count)
    except (GAPI_serviceNotAvailable, GAPI_badRequest):
      entityServiceNotApplicableWarning(Entity.USER, user, i, count)

# gam <UserTypeEntity> delete smime [id <SmimeID>] [sendas|sendasemail <EmailAddress>]
def deleteSmime(users):
  smimeIdBase = None
  sendAsEmailBase = None
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'id':
      smimeIdBase = getString(OB_SMIME_ID)
    elif myarg in [u'sendas', u'sendasemail']:
      sendAsEmailBase = getEmailAddress(noUid=True)
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(GMAIL_API, user)
    if not gmail:
      continue
    sendAsEmail = sendAsEmailBase if sendAsEmailBase else user
    if not smimeIdBase:
      smimeId = _getSmimeIds(gmail, user, i, count, sendAsEmail, u'delete')
      if not smimeId:
        continue
    else:
      smimeId = smimeIdBase
    try:
      callGAPI(gmail.users().settings().sendAs().smimeInfo(), u'delete',
               throw_reasons=GAPI_GMAIL_SMIME_THROW_REASONS,
               userId=u'me', sendAsEmail=sendAsEmail, id=smimeId)
      entityActionPerformed([Entity.USER, user, Entity.SENDAS_ADDRESS, sendAsEmail, Entity.SMIME_ID, smimeId], i, count)
    except GAPI_forbidden as e:
      entityActionFailedWarning([Entity.USER, user], e.message, i, count)
    except (GAPI_serviceNotAvailable, GAPI_badRequest):
      entityServiceNotApplicableWarning(Entity.USER, user, i, count)

def _printShowSmimes(users, csvFormat):
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile([u'User', u'id', u'isDefault', u'issuerCn', u'expiration', u'encryptedKeyPassword', u'pem'])
  primaryonly = False
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'primaryonly':
      primaryonly = True
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(GMAIL_API, user)
    if not gmail:
      continue
    try:
      if primaryonly:
        sendAsEmails = [user]
      else:
        result = callGAPI(gmail.users().settings().sendAs(), u'list',
                          throw_reasons=GAPI_GMAIL_THROW_REASONS,
                          userId=u'me', fields=u'sendAs(sendAsEmail)')
        sendAsEmails = [sendAs[u'sendAsEmail'] for sendAs in result[u'sendAs']] if result else []
      jcount = len(sendAsEmails)
      if not csvFormat:
        entityPerformActionSubItemModifierNumItems([Entity.USER, user], Entity.SMIME_ID, Action.MODIFIER_FROM, jcount, Entity.SENDAS_ADDRESS, i, count)
      if jcount == 0:
        setSysExitRC(NO_ENTITIES_FOUND)
        continue
      j = 0
      for sendAsEmail in sendAsEmails:
        j += 1
        result = callGAPI(gmail.users().settings().sendAs().smimeInfo(), u'list',
                          throw_reasons=GAPI_GMAIL_SMIME_THROW_REASONS,
                          userId=u'me', sendAsEmail=sendAsEmail)
        smimes = result.get(u'smimeInfo', [])
        kcount = len(smimes)
        if not csvFormat:
          Indent.Increment()
          printEntity([Entity.SENDAS_ADDRESS, sendAsEmail], j, jcount)
          Indent.Increment()
          k = 0
          for smime in smimes:
            k += 1
            printEntity([Entity.SMIME_ID, smime[u'id']], k, kcount)
            Indent.Increment()
            printKeyValueList([u'Default', smime.get(u'isDefault', False)])
            printKeyValueList([u'Issuer CN', smime[u'issuerCn']])
            printKeyValueList([u'Expiration', formatLocalTimestamp(smime[u'expiration'])])
            printKeyValueList([u'Password', smime.get(u'encryptedKeyPassword', u'')])
            printKeyValueList([u'PEM', None])
            Indent.Increment()
            printKeyValueList([Indent.MultiLineText(smime[u'pem'])])
            Indent.Decrement()
            Indent.Decrement()
          Indent.Decrement()
          Indent.Decrement()
        else:
          for smime in smimes:
            smime[u'expiration'] = formatLocalTimestamp(smime[u'expiration'])
            addRowTitlesToCSVfile(flattenJSON(smime, flattened={u'User': user}), csvRows, titles)
    except GAPI_forbidden as e:
      entityActionFailedWarning([Entity.USER, user], e.message, i, count)
    except (GAPI_serviceNotAvailable, GAPI_badRequest):
      entityServiceNotApplicableWarning(Entity.USER, user, i, count)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'S/MIME', todrive)

# gam <UserTypeEntity> print smimes [todrive [<ToDriveAttributes>]] [primaryonly]
def printSmimes(users):
  _printShowSmimes(users, True)

# gam <UserTypeEntity> show smimes [primaryonly]
def showSmimes(users):
  _printShowSmimes(users, False)

# gam <UserTypeEntity> shortcuts <Boolean>
def setShortCuts(users):
  emailSettings = getEmailSettingsObject()
  enable = getBoolean()
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, userName, emailSettings.domain = splitEmailAddressOrUID(user)
    result = _processEmailSettings(user, i, count, emailSettings, u'UpdateGeneral',
                                   username=userName, shortcuts=enable)
    if result:
      printEntity([Entity.USER, user, Entity.KEYBOARD_SHORTCUTS_ENABLED, result[u'shortcuts']], i, count)

# gam <UserTypeEntity> signature|sig <String>|(file <FileName> [charset <CharSet>]) (replace <RegularExpression> <String>)* [html] [name <String>] [replyto <EmailAddress>] [default] [primary] [treatasalias <Boolean>]
def setSignature(users):
  tagReplacements = {}
  if checkArgumentPresent(FILE_ARGUMENT):
    filename = getString(OB_FILE_NAME)
    encoding = getCharSet()
    signature = readFile(filename, encoding=encoding)
  else:
    signature = getString(OB_STRING, minLen=0)
  body = {}
  html = primary = False
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'primary':
      primary = True
    elif myarg == u'html':
      html = True
    else:
      getSendAsAttributes(myarg, body, tagReplacements)
  body[u'signature'] = _processSignature(tagReplacements, signature, html)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(GMAIL_API, user)
    if not gmail:
      continue
    if primary:
      try:
        result = callGAPI(gmail.users().settings().sendAs(), u'list',
                          throw_reasons=GAPI_GMAIL_THROW_REASONS,
                          userId=u'me')
        for sendas in result[u'sendAs']:
          if sendas.get(u'isPrimary', False):
            emailAddress = sendas[u'sendAsEmail']
            _processSendAs(user, i, count, Entity.SIGNATURE, emailAddress, i, count, gmail, u'patch', False, body=body, sendAsEmail=emailAddress, fields=u'')
            break
      except (GAPI_serviceNotAvailable, GAPI_badRequest):
        entityServiceNotApplicableWarning(Entity.USER, user, i, count)
    else:
      _processSendAs(user, i, count, Entity.SIGNATURE, user, i, count, gmail, u'patch', False, body=body, sendAsEmail=user, fields=u'')

# gam <UserTypeEntity> show signature|sig [format] [primary]
def showSignature(users):
  formatSig = primary = False
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'primary':
      primary = True
    elif myarg == u'format':
      formatSig = True
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(GMAIL_API, user)
    if not gmail:
      continue
    if primary:
      try:
        result = callGAPI(gmail.users().settings().sendAs(), u'list',
                          throw_reasons=GAPI_GMAIL_THROW_REASONS,
                          userId=u'me')
        printEntity([Entity.USER, user, Entity.SIGNATURE, u''], i, count)
        Indent.Increment()
        for sendas in result[u'sendAs']:
          if sendas.get(u'isPrimary', False):
            _showSendAs(sendas, 0, 0, formatSig)
            break
        Indent.Decrement()
      except (GAPI_serviceNotAvailable, GAPI_badRequest):
        entityServiceNotApplicableWarning(Entity.USER, user, i, count)
    else:
      _processSendAs(user, i, count, Entity.SIGNATURE, user, i, count, gmail, u'get', formatSig, sendAsEmail=user)

# gam <UserTypeEntity> snippets <Boolean>
def setSnippets(users):
  emailSettings = getEmailSettingsObject()
  enable = getBoolean()
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, userName, emailSettings.domain = splitEmailAddressOrUID(user)
    result = _processEmailSettings(user, i, count, emailSettings, u'UpdateGeneral',
                                   username=userName, snippets=enable)
    if result:
      printEntity([Entity.USER, user, Entity.SNIPPETS_ENABLED, result[u'snippets']], i, count)

# gam <UserTypeEntity> utf|utf8|utf-8|unicode <Boolean>
def setUnicode(users):
  emailSettings = getEmailSettingsObject()
  enable = getBoolean()
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, userName, emailSettings.domain = splitEmailAddressOrUID(user)
    result = _processEmailSettings(user, i, count, emailSettings, u'UpdateGeneral',
                                   username=userName, unicode=enable)
    if result:
      printEntity([Entity.USER, user, Entity.UNICODE_ENCODING_ENABLED, result[u'unicode']], i, count)

def _showVacation(user, i, count, result, formatReply):
  enabled = result[u'enableAutoReply']
  printEntity([Entity.USER, user, Entity.VACATION, None], i, count)
  Indent.Increment()
  printKeyValueList([u'Enabled', enabled])
  if enabled:
    printKeyValueList([u'Contacts Only', result[u'restrictToContacts']])
    printKeyValueList([u'Domain Only', result[u'restrictToDomain']])
    if u'startTime' in result:
      printKeyValueList([u'Start Date', formatLocalDatestamp(result[u'startTime'])])
    else:
      printKeyValueList([u'Start Date', u'Started'])
    if u'endTime' in result:
      printKeyValueList([u'End Date', formatLocalDatestamp(result[u'endTime'])])
    else:
      printKeyValueList([u'End Date', u'Not specified'])
    printKeyValueList([u'Subject', result.get(u'responseSubject', u'None')])
    if formatReply:
      printKeyValueList([u'Message', None])
      Indent.Increment()
      if result.get(u'responseBodyPlainText'):
        printKeyValueList([Indent.MultiLineText(result[u'responseBodyPlainText'])])
      elif result.get(u'responseBodyHtml'):
        printKeyValueList([Indent.MultiLineText(dehtml(result[u'responseBodyHtml']))])
      else:
        printKeyValueList([u'None'])
      Indent.Decrement()
    else:
      if result.get(u'responseBodyPlainText'):
        printKeyValueList([u'Message', convertCRsNLs(result[u'responseBodyPlainText'])])
      elif result.get(u'responseBodyHtml'):
        printKeyValueList([u'Message', result[u'responseBodyHtml']])
      else:
        printKeyValueList([u'Message', u'None'])
  Indent.Decrement()

# gam <UserTypeEntity> vacation <FalseValues>
# gam <UserTypeEntity> vacation <TrueValues> subject <String> (message <String>)|(file <FileName> [charset <CharSet>]) (replace <RegularExpression> <String>)* [html]
#	[contactsonly] [domainonly] [startdate <Date>] [enddate <Date>]
def setVacation(users):
  enable = getBoolean()
  body = {u'enableAutoReply': enable}
  if enable:
    responseBodyType = u'responseBodyPlainText'
    message = None
    tagReplacements = {}
    while CLArgs.ArgumentsRemaining():
      myarg = getArgument()
      if myarg == u'subject':
        body[u'responseSubject'] = getString(OB_STRING, checkBlank=True)
      elif myarg == u'message':
        message = getString(OB_STRING, checkBlank=True)
      elif myarg == u'file':
        filename = getString(OB_FILE_NAME)
        encoding = getCharSet()
        message = readFile(filename, encoding=encoding)
      elif myarg == u'replace':
        matchTag = getString(OB_TAG)
        matchReplacement = getString(OB_STRING, minLen=0)
        tagReplacements[matchTag] = matchReplacement
      elif myarg == u'html':
        responseBodyType = u'responseBodyHtml'
      elif myarg == u'contactsonly':
        body[u'restrictToContacts'] = True
      elif myarg == u'domainonly':
        body[u'restrictToDomain'] = True
      elif myarg == u'startdate':
        body[u'startTime'] = getYYYYMMDD(returnTimeStamp=True)
      elif myarg == u'enddate':
        body[u'endTime'] = getYYYYMMDD(returnTimeStamp=True)
      else:
        unknownArgumentExit()
    if message:
      if responseBodyType == u'responseBodyHtml':
        message = message.replace(u'\r', u'').replace(u'\\n', u'<br/>')
      else:
        message = message.replace(u'\r', u'').replace(u'\\n', u'\n')
      if tagReplacements:
        message = _processTags(tagReplacements, message)
      body[responseBodyType] = message
    if not message and not body.get(u'responseSubject'):
      missingArgumentExit(u'message or subject')
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(GMAIL_API, user)
    if not gmail:
      continue
    try:
      result = callGAPI(gmail.users().settings(), u'updateVacation',
                        throw_reasons=GAPI_GMAIL_THROW_REASONS+[GAPI_INVALID_ARGUMENT],
                        userId=u'me', body=body)
      printEntity([Entity.USER, user, Entity.VACATION_ENABLED, result[u'enableAutoReply']], i, count)
    except GAPI_invalidArgument as e:
      entityActionFailedWarning([Entity.USER, user, Entity.VACATION_ENABLED, enable], e.message, i, count)
    except (GAPI_serviceNotAvailable, GAPI_badRequest):
      entityServiceNotApplicableWarning(Entity.USER, user, i, count)

# gam <UserTypeEntity> show vacation [format]
def showVacation(users):
  formatReply = False
  while CLArgs.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'format':
      formatReply = True
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(GMAIL_API, user)
    if not gmail:
      continue
    try:
      result = callGAPI(gmail.users().settings(), u'getVacation',
                        throw_reasons=GAPI_GMAIL_THROW_REASONS,
                        userId=u'me')
      _showVacation(user, i, count, result, formatReply)
    except (GAPI_serviceNotAvailable, GAPI_badRequest):
      entityServiceNotApplicableWarning(Entity.USER, user, i, count)

# gam <UserTypeEntity> webclips <Boolean>
def setWebClips(users):
  emailSettings = getEmailSettingsObject()
  enable = getBoolean()
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, userName, emailSettings.domain = splitEmailAddressOrUID(user)
    result = _processEmailSettings(user, i, count, emailSettings, u'UpdateWebClipSettings',
                                   username=userName, enable=enable)
    if result:
      printEntity([Entity.USER, user, Entity.WEBCLIPS_ENABLED, result[u'enable']], i, count)

# Command line processing

# Keys into command tables
CMD_ACTION = u'acti'
CMD_FUNCTION = u'func'
CMD_OBJ_ALIASES = u'alia'

# Main commands
BATCH_CSV_COMMANDS = {
  u'batch':	{CMD_ACTION: Action.PERFORM, CMD_FUNCTION: doBatch},
  u'csv':	{CMD_ACTION: Action.PERFORM, CMD_FUNCTION: doCSV},
  }
MAIN_COMMANDS = {
  u'help':	{CMD_ACTION: Action.PERFORM, CMD_FUNCTION: doUsage},
  u'list':	{CMD_ACTION: Action.LIST, CMD_FUNCTION: doListType},
  u'report':	{CMD_ACTION: Action.REPORT, CMD_FUNCTION: doReport},
  u'version':	{CMD_ACTION: Action.PERFORM, CMD_FUNCTION: doVersion},
  u'whatis':	{CMD_ACTION: Action.INFO, CMD_FUNCTION: doWhatIs},
  }

# Main commands with objects
MAIN_COMMANDS_WITH_OBJECTS = {
  u'add':
    {CMD_ACTION: Action.ADD,
     CMD_FUNCTION:
       {CL_OB_SITEACLS:	doProcessDomainSiteACLs,
       },
     CMD_OBJ_ALIASES:
       {CL_OB_SITEACL:	CL_OB_SITEACLS,
       },
    },
  u'cancel':
    {CMD_ACTION: Action.CANCEL,
     CMD_FUNCTION:
       {CL_OB_GUARDIAN_INVITATION: doCancelGuardianInvitation,
       },
     CMD_OBJ_ALIASES:
       {CL_OB_GUARDIAN_INVITATIONS:	CL_OB_GUARDIAN_INVITATION,
       },
    },
  u'create':
    {CMD_ACTION: Action.CREATE,
     CMD_FUNCTION:
       {CL_OB_ADMIN:	doCreateAdmin,
        CL_OB_ALIASES:	doCreateAliases,
        CL_OB_CONTACT:	doCreateDomainContact,
        CL_OB_COURSE:	doCreateCourse,
        CL_OB_DATA_TRANSFER:doCreateDataTransfer,
        CL_OB_DOMAIN:	doCreateDomain,
        CL_OB_DOMAIN_ALIAS:	doCreateDomainAlias,
        CL_OB_GROUP:	doCreateGroup,
        CL_OB_GUARDIAN: doInviteGuardian,
        CL_OB_ORG:	doCreateOrg,
        CL_OB_PROJECT:	doCreateProject,
        CL_OB_RESOURCE:	doCreateResourceCalendar,
        CL_OB_SCHEMA:	doCreateUserSchema,
        CL_OB_SITE:	doCreateDomainSite,
        CL_OB_USER:	doCreateUser,
        CL_OB_VERIFY:	doCreateSiteVerification,
       },
     CMD_OBJ_ALIASES:
       {CL_OB_ALIAS:	CL_OB_ALIASES,
        u'aliasdomain':	CL_OB_DOMAIN_ALIAS,
        u'aliasdomains':	CL_OB_DOMAIN_ALIAS,
        u'apiproject':	CL_OB_PROJECT,
        u'class':	CL_OB_COURSE,
        CL_OB_CONTACTS:	CL_OB_CONTACT,
        CL_OB_DOMAIN_ALIASES:	CL_OB_DOMAIN_ALIAS,
        CL_OB_GUARDIANS:	CL_OB_GUARDIAN,
        u'guardianinvite':	CL_OB_GUARDIAN,
        u'inviteguardian':	CL_OB_GUARDIAN,
        u'transfer':	CL_OB_DATA_TRANSFER,
        u'nickname':	CL_OB_ALIASES,
        u'nicknames':	CL_OB_ALIASES,
        u'ou':		CL_OB_ORG,
        CL_OB_SCHEMAS:	CL_OB_SCHEMA,
        CL_OB_SITES:	CL_OB_SITE,
        u'verification':CL_OB_VERIFY,
       },
    },
  u'delete':
    {CMD_ACTION: Action.DELETE,
     CMD_FUNCTION:
       {CL_OB_ADMIN:	doDeleteAdmin,
        CL_OB_ALIASES:	doDeleteAliases,
        CL_OB_CONTACTS:	doDeleteDomainContacts,
        CL_OB_COURSE:	doDeleteCourse,
        CL_OB_COURSES:	doDeleteCourses,
        CL_OB_DOMAIN:	doDeleteDomain,
        CL_OB_DOMAIN_ALIAS:	doDeleteDomainAlias,
        CL_OB_GROUPS:	doDeleteGroups,
        CL_OB_GUARDIAN: doDeleteGuardian,
        CL_OB_MOBILES:	doDeleteMobileDevices,
        CL_OB_NOTIFICATION:	doDeleteNotification,
        CL_OB_ORG:	doDeleteOrg,
        CL_OB_ORGS:	doDeleteOrgs,
        CL_OB_PRINTERS:	doDeletePrinters,
        CL_OB_PROJECTS:	doDeleteProjects,
        CL_OB_RESOURCE:	doDeleteResourceCalendar,
        CL_OB_RESOURCES:doDeleteResourceCalendars,
        CL_OB_SCHEMAS:	doDeleteUserSchemas,
        CL_OB_SITEACLS:	doProcessDomainSiteACLs,
        CL_OB_USER:	doDeleteUser,
        CL_OB_USERS:	doDeleteUsers,
       },
     CMD_OBJ_ALIASES:
       {CL_OB_ALIAS:	CL_OB_ALIASES,
        u'aliasdomain':	CL_OB_DOMAIN_ALIAS,
        u'aliasdomains':	CL_OB_DOMAIN_ALIAS,
        u'class':	CL_OB_COURSE,
        CL_OB_CONTACT:	CL_OB_CONTACTS,
        CL_OB_DOMAIN_ALIASES:	CL_OB_DOMAIN_ALIAS,
        CL_OB_GROUP:	CL_OB_GROUPS,
        CL_OB_GUARDIANS:	CL_OB_GUARDIAN,
        CL_OB_MOBILE:	CL_OB_MOBILES,
        u'nickname':	CL_OB_ALIASES,
        u'nicknames':	CL_OB_ALIASES,
        u'ou':		CL_OB_ORG,
        u'ous':		CL_OB_ORGS,
        CL_OB_PROJECT:	CL_OB_PROJECTS,
        u'print':	CL_OB_PRINTERS,
        CL_OB_PRINTER:	CL_OB_PRINTERS,
        u'notifications':	CL_OB_NOTIFICATION,
        CL_OB_SCHEMA:	CL_OB_SCHEMAS,
        CL_OB_SITEACL:	CL_OB_SITEACLS,
       },
    },
  u'info':
    {CMD_ACTION: Action.INFO,
     CMD_FUNCTION:
       {CL_OB_ALIASES:	doInfoAliases,
        CL_OB_CONTACTS:	doInfoDomainContacts,
        CL_OB_COURSE:	doInfoCourse,
        CL_OB_COURSES:	doInfoCourses,
        CL_OB_CROSES:	doInfoCrOSDevices,
        CL_OB_CUSTOMER:	doInfoCustomer,
        CL_OB_DATA_TRANSFER:doInfoDataTransfer,
        CL_OB_DOMAIN:	doInfoDomain,
        CL_OB_DOMAIN_ALIAS:	doInfoDomainAlias,
        CL_OB_INSTANCE:	doInfoInstance,
        CL_OB_GAL:	doInfoGAL,
        CL_OB_GROUPS:	doInfoGroups,
        CL_OB_MOBILES:	doInfoMobileDevices,
        CL_OB_NOTIFICATION:	doInfoNotifications,
        CL_OB_ORG:	doInfoOrg,
        CL_OB_ORGS:	doInfoOrgs,
        CL_OB_PRINTERS:	doInfoPrinters,
        CL_OB_RESOURCE:	doInfoResourceCalendar,
        CL_OB_RESOURCES:doInfoResourceCalendars,
        CL_OB_SCHEMAS:	doInfoUserSchemas,
        CL_OB_SITES:	doInfoDomainSites,
        CL_OB_SITEACLS:	doProcessDomainSiteACLs,
        CL_OB_USER:	doInfoUser,
        CL_OB_USERS:	doInfoUsers,
        CL_OB_VERIFY:	doInfoSiteVerification,
       },
     CMD_OBJ_ALIASES:
       {CL_OB_ALIAS:	CL_OB_ALIASES,
        u'aliasdomain':	CL_OB_DOMAIN_ALIAS,
        u'aliasdomains':	CL_OB_DOMAIN_ALIAS,
        u'class':	CL_OB_COURSE,
        CL_OB_CONTACT:	CL_OB_CONTACTS,
        CL_OB_CROS:	CL_OB_CROSES,
        CL_OB_DOMAIN_ALIASES:	CL_OB_DOMAIN_ALIAS,
        CL_OB_GROUP:	CL_OB_GROUPS,
        CL_OB_MOBILE:	CL_OB_MOBILES,
        u'nickname':	CL_OB_ALIASES,
        u'nicknames':	CL_OB_ALIASES,
        u'notifications':	CL_OB_NOTIFICATION,
        u'ou':		CL_OB_ORG,
        u'ous':		CL_OB_ORGS,
        u'print':	CL_OB_PRINTERS,
        CL_OB_PRINTER:	CL_OB_PRINTERS,
        CL_OB_SCHEMA:	CL_OB_SCHEMAS,
        CL_OB_SITE:	CL_OB_SITES,
        CL_OB_SITEACL:	CL_OB_SITEACLS,
        u'transfer':	CL_OB_DATA_TRANSFER,
        u'verification':CL_OB_VERIFY,
       },
    },
  u'print':
    {CMD_ACTION: Action.PRINT,
     CMD_FUNCTION:
       {CL_OB_ADMINROLES:	doPrintAdminRoles,
        CL_OB_ADMINS:	doPrintAdmins,
        CL_OB_ALIASES:	doPrintAliases,
        CL_OB_CONTACTS:	doPrintDomainContacts,
        CL_OB_COURSES:	doPrintCourses,
        CL_OB_COURSE_PARTICIPANTS:	doPrintCourseParticipants,
        CL_OB_CROS:	doPrintCrOSDevices,
        CL_OB_DATA_TRANSFERS:	doPrintDataTransfers,
        CL_OB_DOMAINS:	doPrintDomains,
        CL_OB_DOMAIN_ALIASES:	doPrintDomainAliases,
        CL_OB_GAL:	doPrintGAL,
        CL_OB_GROUP_MEMBERS: doPrintGroupMembers,
        CL_OB_GROUPS:	doPrintGroups,
        CL_OB_GUARDIANS: doPrintGuardians,
        CL_OB_LICENSES:	doPrintLicenses,
        CL_OB_MOBILE:	doPrintMobileDevices,
        CL_OB_ORGS:	doPrintOrgs,
        CL_OB_PRINTERS:	doPrintPrinters,
        CL_OB_PRINTJOBS:doPrintPrintJobs,
        CL_OB_ORGS:	doPrintOrgs,
        CL_OB_RESOURCES:	doPrintResourceCalendars,
        CL_OB_SCHEMAS:	doPrintUserSchemas,
        CL_OB_SITES:	doPrintDomainSites,
        CL_OB_SITEACTIVITY:	doPrintDomainSiteActivity,
        CL_OB_TOKENS:	doPrintTokens,
        CL_OB_TRANSFERAPPS:	doPrintTransferApps,
        CL_OB_USERS:	doPrintUsers,
       },
     CMD_OBJ_ALIASES:
       {CL_OB_ALIAS:	CL_OB_ALIASES,
        u'aliasdomain':		CL_OB_DOMAIN_ALIASES,
        u'aliasdomains':	CL_OB_DOMAIN_ALIASES,
        u'classes':		CL_OB_COURSES,
        CL_OB_CONTACT:		CL_OB_CONTACTS,
        u'transfers':		CL_OB_DATA_TRANSFERS,
        u'classparticipants':	CL_OB_COURSE_PARTICIPANTS,
        u'class-participants':	CL_OB_COURSE_PARTICIPANTS,
        u'courseparticipants':	CL_OB_COURSE_PARTICIPANTS,
        CL_OB_DOMAIN_ALIAS:	CL_OB_DOMAIN_ALIASES,
        CL_OB_GROUP:		CL_OB_GROUPS,
        u'groupmembers':	CL_OB_GROUP_MEMBERS,
        u'groupsmembers':	CL_OB_GROUP_MEMBERS,
        u'groups-members':	CL_OB_GROUP_MEMBERS,
        CL_OB_GUARDIAN:		CL_OB_GUARDIANS,
        u'license':		CL_OB_LICENSES,
        u'licence':		CL_OB_LICENSES,
        u'licences':		CL_OB_LICENSES,
        u'nicknames':		CL_OB_ALIASES,
        u'ous':			CL_OB_ORGS,
        CL_OB_PRINTER:		CL_OB_PRINTERS,
        CL_OB_RESOURCE:		CL_OB_RESOURCES,
        u'roles':		CL_OB_ADMINROLES,
        CL_OB_SCHEMA:		CL_OB_SCHEMAS,
        CL_OB_SITE:		CL_OB_SITES,
        CL_OB_TOKEN:		CL_OB_TOKENS,
       },
    },
  u'show':
    {CMD_ACTION: Action.SHOW,
     CMD_FUNCTION:
       {CL_OB_CONTACTS:	doShowDomainContacts,
        CL_OB_GAL:	doShowGAL,
        CL_OB_GUARDIANS: doShowGuardians,
        CL_OB_ORGTREE:	doShowOrgTree,
        CL_OB_RESOURCES:	doShowResourceCalendars,
        CL_OB_SCHEMAS:	doShowUserSchemas,
        CL_OB_SITES:	doShowDomainSites,
        CL_OB_SITEACLS:	doProcessDomainSiteACLs,
       },
     CMD_OBJ_ALIASES:
       {CL_OB_CONTACT:	CL_OB_CONTACTS,
        CL_OB_GUARDIAN:	CL_OB_GUARDIANS,
        u'outree':	CL_OB_ORGTREE,
        CL_OB_RESOURCE:		CL_OB_RESOURCES,
        CL_OB_SCHEMA:	CL_OB_SCHEMAS,
        CL_OB_SITE:	CL_OB_SITES,
        CL_OB_SITEACL:	CL_OB_SITEACLS,
       },
    },
  u'update':
    {CMD_ACTION: Action.UPDATE,
     CMD_FUNCTION:
       {CL_OB_ALIASES:	doUpdateAliases,
        CL_OB_CONTACTS:	doUpdateDomainContacts,
        CL_OB_COURSE:	doUpdateCourse,
        CL_OB_COURSES:	doUpdateCourses,
        CL_OB_CROSES:	doUpdateCrOSDevices,
        CL_OB_CUSTOMER:	doUpdateCustomer,
        CL_OB_DOMAIN:	doUpdateDomain,
        CL_OB_INSTANCE:	doUpdateInstance,
        CL_OB_GROUPS:	doUpdateGroups,
        CL_OB_MOBILES:	doUpdateMobileDevices,
        CL_OB_NOTIFICATION:	doUpdateNotification,
        CL_OB_ORG:	doUpdateOrg,
        CL_OB_ORGS:	doUpdateOrgs,
        CL_OB_PRINTERS:	doUpdatePrinters,
        CL_OB_RESOURCE:	doUpdateResourceCalendar,
        CL_OB_RESOURCES:doUpdateResourceCalendars,
        CL_OB_SCHEMAS:	doUpdateUserSchemas,
        CL_OB_SITES:	doUpdateDomainSites,
        CL_OB_SITEACLS:	doProcessDomainSiteACLs,
        CL_OB_USER:	doUpdateUser,
        CL_OB_USERS:	doUpdateUsers,
        CL_OB_VERIFY:	doUpdateSiteVerification,
       },
     CMD_OBJ_ALIASES:
       {CL_OB_ALIAS:	CL_OB_ALIASES,
        u'class':	CL_OB_COURSE,
        CL_OB_CONTACT:	CL_OB_CONTACTS,
        CL_OB_CROS:	CL_OB_CROSES,
        CL_OB_GROUP:	CL_OB_GROUPS,
        CL_OB_MOBILE:	CL_OB_MOBILES,
        u'nickname':	CL_OB_ALIASES,
        u'nicknames':	CL_OB_ALIASES,
        u'notifications':	CL_OB_NOTIFICATION,
        u'ou':		CL_OB_ORG,
        u'ous':		CL_OB_ORGS,
        u'print':	CL_OB_PRINTERS,
        CL_OB_PRINTER:	CL_OB_PRINTERS,
        CL_OB_SCHEMA:	CL_OB_SCHEMAS,
        CL_OB_SITE:	CL_OB_SITES,
        CL_OB_SITEACL:	CL_OB_SITEACLS,
        u'verification':CL_OB_VERIFY,
       },
    },
  u'undelete':
    {CMD_ACTION: Action.UNDELETE,
     CMD_FUNCTION:
       {CL_OB_USER:	doUndeleteUser,
        CL_OB_USERS:	doUndeleteUsers,
       },
     CMD_OBJ_ALIASES:
       {
       },
    },
  }

# Oauth command sub-commands
OAUTH2_SUBCOMMANDS = {
  u'create':	{CMD_ACTION: Action.CREATE, CMD_FUNCTION: doOAuthRequest},
  u'delete':	{CMD_ACTION: Action.DELETE, CMD_FUNCTION: doOAuthDelete},
  u'info':	{CMD_ACTION: Action.INFO, CMD_FUNCTION: doOAuthInfo},
  }

# Oauth sub-command aliases
OAUTH2_SUBCOMMAND_ALIASES = {
  u'request':	u'create',
  u'revoke':	u'delete',
  u'verify':	u'info',
  }

def processOauthCommands():
  CL_subCommand = getChoice(OAUTH2_SUBCOMMANDS, choiceAliases=OAUTH2_SUBCOMMAND_ALIASES)
  Action.Set(OAUTH2_SUBCOMMANDS[CL_subCommand][CMD_ACTION])
  OAUTH2_SUBCOMMANDS[CL_subCommand][CMD_FUNCTION]()

# Audit command sub-commands
AUDIT_SUBCOMMANDS = {
  u'uploadkey': {CMD_ACTION: Action.UPLOAD, CMD_FUNCTION: doUploadAuditKey},
  }

# Audit command sub-commands with objects
AUDIT_SUBCOMMANDS_WITH_OBJECTS = {
  u'activity':
    {u'request':{CMD_ACTION: Action.SUBMIT, CMD_FUNCTION: doSubmitActivityRequest},
     u'delete':	{CMD_ACTION: Action.DELETE, CMD_FUNCTION: doDeleteActivityRequest},
     u'download':	{CMD_ACTION: Action.DOWNLOAD, CMD_FUNCTION: doDownloadActivityRequest},
     u'status':	{CMD_ACTION: Action.LIST, CMD_FUNCTION: doStatusActivityRequests},
    },
  u'export':
    {u'request':{CMD_ACTION: Action.SUBMIT, CMD_FUNCTION: doSubmitExportRequest},
     u'delete':	{CMD_ACTION: Action.DELETE, CMD_FUNCTION: doDeleteExportRequest},
     u'download':	{CMD_ACTION: Action.DOWNLOAD, CMD_FUNCTION: doDownloadExportRequest},
     u'status':	{CMD_ACTION: Action.LIST, CMD_FUNCTION: doStatusExportRequests},
     u'watch':	{CMD_ACTION: Action.WATCH, CMD_FUNCTION: doWatchExportRequest},
    },
  u'monitor':
    {u'create':	{CMD_ACTION: Action.CREATE, CMD_FUNCTION: doCreateMonitor},
     u'delete':	{CMD_ACTION: Action.DELETE, CMD_FUNCTION: doDeleteMonitor},
     u'list':	{CMD_ACTION: Action.LIST, CMD_FUNCTION: doShowMonitors},
    },
  }

def processAuditCommands():
  CL_subCommand = getChoice(AUDIT_SUBCOMMANDS.keys()+AUDIT_SUBCOMMANDS_WITH_OBJECTS.keys())
  if CL_subCommand in AUDIT_SUBCOMMANDS:
    Action.Set(AUDIT_SUBCOMMANDS[CL_subCommand][CMD_ACTION])
    AUDIT_SUBCOMMANDS[CL_subCommand][CMD_FUNCTION]()
  else:
    CL_objectName = getChoice(AUDIT_SUBCOMMANDS_WITH_OBJECTS[CL_subCommand])
    Action.Set(AUDIT_SUBCOMMANDS_WITH_OBJECTS[CL_subCommand][CL_objectName][CMD_ACTION])
    AUDIT_SUBCOMMANDS_WITH_OBJECTS[CL_subCommand][CL_objectName][CMD_FUNCTION]()

# Calendar command sub-commands
CALENDAR_SUBCOMMANDS = {
  u'showacl':	{CMD_ACTION: Action.SHOW, CMD_FUNCTION: doCalendarsShowACLs},
  u'addevent':	{CMD_ACTION: Action.ADD, CMD_FUNCTION: doCalendarsAddEvent},
  u'deleteevent':	{CMD_ACTION: Action.DELETE, CMD_FUNCTION: doCalendarsDeleteEvents},
  u'wipe':	{CMD_ACTION: Action.WIPE, CMD_FUNCTION: doCalendarsWipeEvents},
  }

CALENDAR_OLDACL_SUBCOMMANDS = {
  u'add':	{CMD_ACTION: Action.ADD, CMD_FUNCTION: doCalendarsAddACL},
  u'delete':	{CMD_ACTION: Action.DELETE, CMD_FUNCTION: doCalendarsDeleteACL},
  u'update':	{CMD_ACTION: Action.UPDATE, CMD_FUNCTION: doCalendarsUpdateACL},
  }

# Calendar sub-command aliases
CALENDAR_OLDACL_SUBCOMMAND_ALIASES = {
  u'del':	u'delete',
  }

# Calendars command sub-commands with objects
CALENDARS_SUBCOMMANDS_OBJECT_ALIASES = {
  CL_OB_ACL:	CL_OB_ACLS,
  CL_OB_CALENDARACL:	CL_OB_ACLS,
  CL_OB_CALENDARACLS:	CL_OB_ACLS,
  CL_OB_EVENT:	CL_OB_EVENTS,
  }

CALENDARS_SUBCOMMANDS_WITH_OBJECTS = {
  u'add':
    {CMD_ACTION: Action.ADD,
     CMD_FUNCTION:
       {CL_OB_ACLS:	doCalendarsAddACLs,
        CL_OB_EVENTS:	doCalendarsAddEvent,
       },
     CMD_OBJ_ALIASES:	CALENDARS_SUBCOMMANDS_OBJECT_ALIASES,
    },
  u'update':
    {CMD_ACTION: Action.UPDATE,
     CMD_FUNCTION:
       {CL_OB_ACLS:	doCalendarsUpdateACLs,
        CL_OB_EVENTS:	doCalendarsUpdateEvents,
       },
     CMD_OBJ_ALIASES:	CALENDARS_SUBCOMMANDS_OBJECT_ALIASES,
    },
  u'delete':
    {CMD_ACTION: Action.DELETE,
     CMD_FUNCTION:
       {CL_OB_ACLS:	doCalendarsDeleteACLs,
        CL_OB_EVENTS:	doCalendarsDeleteEvents,
       },
     CMD_OBJ_ALIASES:	CALENDARS_SUBCOMMANDS_OBJECT_ALIASES,
    },
  u'info':
    {CMD_ACTION: Action.INFO,
     CMD_FUNCTION:
       {CL_OB_ACLS:	doCalendarsInfoACLs,
        CL_OB_EVENTS:	doCalendarsInfoEvents,
       },
     CMD_OBJ_ALIASES:	CALENDARS_SUBCOMMANDS_OBJECT_ALIASES,
    },
  u'move':
    {CMD_ACTION: Action.MOVE,
     CMD_FUNCTION:
       {CL_OB_EVENTS:	doCalendarsMoveEvents,
       },
     CMD_OBJ_ALIASES:
       {CL_OB_EVENT:	CL_OB_EVENTS,
       },
    },
  u'print':
    {CMD_ACTION: Action.PRINT,
     CMD_FUNCTION:
       {CL_OB_ACLS:	doCalendarsPrintACLs,
        CL_OB_EVENTS:	doCalendarsPrintEvents,
       },
     CMD_OBJ_ALIASES:	CALENDARS_SUBCOMMANDS_OBJECT_ALIASES,
    },
  u'show':
    {CMD_ACTION: Action.SHOW,
     CMD_FUNCTION:
       {CL_OB_ACLS:	doCalendarsShowACLs,
        CL_OB_EVENTS:	doCalendarsShowEvents,
       },
     CMD_OBJ_ALIASES:	CALENDARS_SUBCOMMANDS_OBJECT_ALIASES,
    },
  u'wipe':
    {CMD_ACTION: Action.WIPE,
     CMD_FUNCTION:
       {CL_OB_EVENTS:	doCalendarsWipeEvents,
       },
     CMD_OBJ_ALIASES:
       {CL_OB_EVENT:	CL_OB_EVENTS,
       },
    },
  }

def processCalendarsCommands():
  cal = buildGAPIObject(CALENDAR_API)
  calendarList = getEntityList(OB_EMAIL_ADDRESS_ENTITY)
  CL_subCommand = getChoice(CALENDAR_SUBCOMMANDS, defaultChoice=None)
  if CL_subCommand:
    Action.Set(CALENDAR_SUBCOMMANDS[CL_subCommand][CMD_ACTION])
    CALENDAR_SUBCOMMANDS[CL_subCommand][CMD_FUNCTION](cal, calendarList)
    return
  CL_subCommand = getChoice(CALENDAR_OLDACL_SUBCOMMANDS, choiceAliases=CALENDAR_OLDACL_SUBCOMMAND_ALIASES, defaultChoice=None)
  if CL_subCommand:
    Action.Set(CALENDAR_OLDACL_SUBCOMMANDS[CL_subCommand][CMD_ACTION])
    CL_objectName = getChoice([CL_OB_ACLS, CL_OB_EVENTS], choiceAliases=CALENDARS_SUBCOMMANDS_OBJECT_ALIASES, defaultChoice=None)
    if not CL_objectName:
      CALENDAR_OLDACL_SUBCOMMANDS[CL_subCommand][CMD_FUNCTION](cal, calendarList)
    else:
      CALENDARS_SUBCOMMANDS_WITH_OBJECTS[CL_subCommand][CMD_FUNCTION][CL_objectName](cal, calendarList)
    return
  CL_subCommand = getChoice(CALENDARS_SUBCOMMANDS_WITH_OBJECTS)
  Action.Set(CALENDARS_SUBCOMMANDS_WITH_OBJECTS[CL_subCommand][CMD_ACTION])
  CL_objectName = getChoice(CALENDARS_SUBCOMMANDS_WITH_OBJECTS[CL_subCommand][CMD_FUNCTION], choiceAliases=CALENDARS_SUBCOMMANDS_WITH_OBJECTS[CL_subCommand][CMD_OBJ_ALIASES])
  CALENDARS_SUBCOMMANDS_WITH_OBJECTS[CL_subCommand][CMD_FUNCTION][CL_objectName](cal, calendarList)

# Course command sub-commands
COURSE_SUBCOMMANDS = {
  u'add':	{CMD_ACTION: Action.ADD, CMD_FUNCTION: doCourseAddParticipants},
  u'remove':	{CMD_ACTION: Action.REMOVE, CMD_FUNCTION: doCourseRemoveParticipants},
  u'sync':	{CMD_ACTION: Action.SYNC, CMD_FUNCTION: doCourseSyncParticipants},
  }

# Course sub-command aliases
COURSE_SUBCOMMAND_ALIASES = {
  u'create':	u'add',
  u'del':	u'remove',
  u'delete':	u'remove',
  }

def executeCourseCommands(courseIdList, getEntityListArg):
  CL_subCommand = getChoice(COURSE_SUBCOMMANDS, choiceAliases=COURSE_SUBCOMMAND_ALIASES)
  Action.Set(COURSE_SUBCOMMANDS[CL_subCommand][CMD_ACTION])
  COURSE_SUBCOMMANDS[CL_subCommand][CMD_FUNCTION](courseIdList, getEntityListArg)

def processCourseCommands():
  executeCourseCommands(getStringReturnInList(OB_COURSE_ID), False)

def processCoursesCommands():
  executeCourseCommands(getEntityList(OB_COURSE_ENTITY), True)

# Printer command sub-commands
PRINTER_SUBCOMMANDS = {
  u'add':	{CMD_ACTION: Action.ADD, CMD_FUNCTION: doPrinterAddACL},
  u'delete':	{CMD_ACTION: Action.DELETE, CMD_FUNCTION: doPrinterDeleteACLs},
  u'printacls':	{CMD_ACTION: Action.SHOW, CMD_FUNCTION: doPrinterPrintACLs},
  u'showacls':	{CMD_ACTION: Action.SHOW, CMD_FUNCTION: doPrinterShowACLs},
  u'sync':	{CMD_ACTION: Action.SYNC, CMD_FUNCTION: doPrinterSyncACLs},
  u'wipe':	{CMD_ACTION: Action.DELETE, CMD_FUNCTION: doPrinterWipeACLs},
  }

# Printer sub-command aliases
PRINTER_SUBCOMMAND_ALIASES = {
  u'del':	u'delete',
  u'printacl':	u'printacls',
  u'showacl':	u'showacls',
  u'remove':	u'delete',
  }

def processPrintersCommands():
  printerIdList = getEntityList(OB_PRINTER_ID_ENTITY)
  if printerIdList[0] == u'register':
    Action.Set(Action.REGISTER)
    doPrinterRegister()
    return
  CL_subCommand = getChoice(PRINTER_SUBCOMMANDS, choiceAliases=PRINTER_SUBCOMMAND_ALIASES)
  Action.Set(PRINTER_SUBCOMMANDS[CL_subCommand][CMD_ACTION])
  PRINTER_SUBCOMMANDS[CL_subCommand][CMD_FUNCTION](printerIdList)

# Printjob command sub-commands
PRINTJOB_SUBCOMMANDS = {
  u'cancel':	{CMD_ACTION: Action.CANCEL, CMD_FUNCTION: doPrintJobCancel},
  u'delete':	{CMD_ACTION: Action.DELETE, CMD_FUNCTION: doPrintJobDelete},
  u'fetch':	{CMD_ACTION: Action.DOWNLOAD, CMD_FUNCTION: doPrintJobFetch},
  u'resubmit':	{CMD_ACTION: Action.RESUBMIT, CMD_FUNCTION: doPrintJobResubmit},
  u'submit':	{CMD_ACTION: Action.SUBMIT, CMD_FUNCTION: doPrintJobSubmit},
  }

def processPrintjobsCommands():
  jobPrinterIdList = getEntityList(OB_PRINTER_ID_ENTITY)
  CL_subCommand = getChoice(PRINTJOB_SUBCOMMANDS)
  Action.Set(PRINTJOB_SUBCOMMANDS[CL_subCommand][CMD_ACTION])
  PRINTJOB_SUBCOMMANDS[CL_subCommand][CMD_FUNCTION](jobPrinterIdList)

# Resource command sub-commands
RESOURCE_SUBCOMMANDS_OBJECT_ALIASES = {
  CL_OB_ACL:	CL_OB_ACLS,
  CL_OB_CALENDARACL:	CL_OB_ACLS,
  CL_OB_CALENDARACLS:	CL_OB_ACLS,
  }

RESOURCE_SUBCOMMANDS_WITH_OBJECTS = {
  u'add':
    {CMD_ACTION: Action.ADD,
     CMD_FUNCTION:
       {CL_OB_ACLS:	doResourceAddCalendarACLs,
       },
     CMD_OBJ_ALIASES:	RESOURCE_SUBCOMMANDS_OBJECT_ALIASES,
    },
  u'update':
    {CMD_ACTION: Action.UPDATE,
     CMD_FUNCTION:
       {CL_OB_ACLS:	doResourceUpdateCalendarACLs,
       },
     CMD_OBJ_ALIASES:	RESOURCE_SUBCOMMANDS_OBJECT_ALIASES,
    },
  u'delete':
    {CMD_ACTION: Action.DELETE,
     CMD_FUNCTION:
       {CL_OB_ACLS:	doResourceDeleteCalendarACLs,
       },
     CMD_OBJ_ALIASES:	RESOURCE_SUBCOMMANDS_OBJECT_ALIASES,
    },
  u'info':
    {CMD_ACTION: Action.INFO,
     CMD_FUNCTION:
       {CL_OB_ACLS:	doResourceInfoCalendarACLs,
       },
     CMD_OBJ_ALIASES:	RESOURCE_SUBCOMMANDS_OBJECT_ALIASES,
    },
  u'print':
    {CMD_ACTION: Action.PRINT,
     CMD_FUNCTION:
       {CL_OB_ACLS:	doResourcePrintCalendarACLs,
       },
     CMD_OBJ_ALIASES:	RESOURCE_SUBCOMMANDS_OBJECT_ALIASES,
    },
  u'show':
    {CMD_ACTION: Action.SHOW,
     CMD_FUNCTION:
       {CL_OB_ACLS:	doResourceShowCalendarACLs,
       },
     CMD_OBJ_ALIASES:	RESOURCE_SUBCOMMANDS_OBJECT_ALIASES,
    },
  }

# Resource sub-command aliases
RESOURCE_SUBCOMMAND_ALIASES = {
  u'del':	u'delete',
  }

def executeResourceCommands(resourceEntity):
  CL_subCommand = getChoice(RESOURCE_SUBCOMMANDS_WITH_OBJECTS, choiceAliases=RESOURCE_SUBCOMMAND_ALIASES)
  Action.Set(RESOURCE_SUBCOMMANDS_WITH_OBJECTS[CL_subCommand][CMD_ACTION])
  CL_objectName = getChoice(RESOURCE_SUBCOMMANDS_WITH_OBJECTS[CL_subCommand][CMD_FUNCTION], choiceAliases=RESOURCE_SUBCOMMANDS_WITH_OBJECTS[CL_subCommand][CMD_OBJ_ALIASES])
  RESOURCE_SUBCOMMANDS_WITH_OBJECTS[CL_subCommand][CMD_FUNCTION][CL_objectName](resourceEntity)

def processResourceCommands():
  executeResourceCommands(getStringReturnInList(OB_RESOURCE_ID))

def processResourcesCommands():
  executeResourceCommands(getEntityList(OB_RESOURCE_ENTITY))

# Commands
COMMANDS_MAP = {
  u'oauth':	processOauthCommands,
  u'audit':	processAuditCommands,
  u'calendars':	processCalendarsCommands,
  u'course':	processCourseCommands,
  u'courses':	processCoursesCommands,
  u'printers':	processPrintersCommands,
  u'printjobs':	processPrintjobsCommands,
  u'resource':	processResourceCommands,
  u'resources':	processResourcesCommands,
  }

# Commands aliases
COMMANDS_ALIASES = {
  u'oauth2':	u'oauth',
  u'calendar':	u'calendars',
  u'printer':	u'printers',
  u'printjob':	u'printjobs',
  u'site':	u'sites',
  }

# <CrOSTypeEntity> commands
CROS_COMMANDS = {
  u'info':	{CMD_ACTION: Action.INFO, CMD_FUNCTION: infoCrOSDevices},
  u'list':	{CMD_ACTION: Action.LIST, CMD_FUNCTION: doListCrOS},
  u'print':	{CMD_ACTION: Action.PRINT, CMD_FUNCTION: doPrintCrOSEntity},
  u'update':	{CMD_ACTION: Action.UPDATE, CMD_FUNCTION: updateCrOSDevices},
  }

# <UserTypeEntity> commands
USER_COMMANDS = {
  u'arrows':	{CMD_ACTION: Action.SET, CMD_FUNCTION: setArrows},
  CL_OB_DELEGATE:	{CMD_ACTION: Action.ADD, CMD_FUNCTION: delegateTo},
  u'deprovision':	{CMD_ACTION: Action.DEPROVISION, CMD_FUNCTION: deprovisionUser},
  CL_OB_FILTER:	{CMD_ACTION: Action.ADD, CMD_FUNCTION: addFilter},
  CL_OB_FORWARD:	{CMD_ACTION: Action.SET, CMD_FUNCTION: setForward},
  CL_OB_IMAP:	{CMD_ACTION: Action.SET, CMD_FUNCTION: setImap},
  u'label':	{CMD_ACTION: Action.ADD, CMD_FUNCTION: addLabel},
  u'list':	{CMD_ACTION: Action.LIST, CMD_FUNCTION: doListUser},
  u'language':	{CMD_ACTION: Action.SET, CMD_FUNCTION: setLanguage},
  u'pagesize':	{CMD_ACTION: Action.SET, CMD_FUNCTION: setPageSize},
  CL_OB_POP:	{CMD_ACTION: Action.SET, CMD_FUNCTION: setPop},
  CL_OB_PROFILE:	{CMD_ACTION: Action.SET, CMD_FUNCTION: setProfile},
  CL_OB_SENDAS:	{CMD_ACTION: Action.ADD, CMD_FUNCTION: addSendAs},
  u'shortcuts':	{CMD_ACTION: Action.SET, CMD_FUNCTION: setShortCuts},
  u'signature':	{CMD_ACTION: Action.SET, CMD_FUNCTION: setSignature},
  u'snippets':	{CMD_ACTION: Action.SET, CMD_FUNCTION: setSnippets},
  u'unicode':	{CMD_ACTION: Action.SET, CMD_FUNCTION: setUnicode},
  CL_OB_VACATION:	{CMD_ACTION: Action.SET, CMD_FUNCTION: setVacation},
  u'webclips':	{CMD_ACTION: Action.SET, CMD_FUNCTION: setWebClips},
  }

# User commands with objects
#
USER_COMMANDS_WITH_OBJECTS = {
  u'add':
    {CMD_ACTION: Action.ADD,
     CMD_FUNCTION:
       {CL_OB_CALENDARS:	addCalendars,
        CL_OB_CALENDARACLS:	addCalendarACLs,
        CL_OB_DELEGATE:	addDelegate,
        CL_OB_DRIVEFILE:addDriveFile,
        CL_OB_DRIVEFILEACL:	addDriveFileACL,
        CL_OB_EVENT:	addCalendarEvent,
        CL_OB_FILTER:	addFilter,
        CL_OB_FORWARDINGADDRESSES:	addForwardingAddresses,
        CL_OB_GROUPS:	addUserToGroups,
        CL_OB_LABEL:	addLabel,
        CL_OB_LICENSE:	addLicense,
        CL_OB_PERMISSIONS:	addDriveFilePermissions,
        CL_OB_SENDAS:	addSendAs,
        CL_OB_SMIME:	addSmime,
        CL_OB_SITEACLS:	processUserSiteACLs,
       },
     CMD_OBJ_ALIASES:
       {CL_OB_CALENDAR:	CL_OB_CALENDARS,
        CL_OB_CALENDARACL:	CL_OB_CALENDARACLS,
        CL_OB_DELEGATES:	CL_OB_DELEGATE,
        CL_OB_EVENTS:	CL_OB_EVENT,
        CL_OB_FILTERS:	CL_OB_FILTER,
        CL_OB_FORWARDINGADDRESS:	CL_OB_FORWARDINGADDRESSES,
        CL_OB_GROUP:	CL_OB_GROUPS,
        CL_OB_LABELS:	CL_OB_LABEL,
        u'licence':	CL_OB_LICENSE,
        CL_OB_SITEACL:	CL_OB_SITEACLS,
       },
    },
  u'archive':
    {CMD_ACTION: Action.ARCHIVE,
     CMD_FUNCTION:
       {CL_OB_MESSAGES:	archiveMessages,
       },
     CMD_OBJ_ALIASES:
       {CL_OB_MESSAGE:	CL_OB_MESSAGES,
       },
    },
  u'check':
    {CMD_ACTION: Action.CHECK,
     CMD_FUNCTION:
       {CL_OB_SERVICEACCOUNT:	checkServiceAccount,
       },
     CMD_OBJ_ALIASES:
       {
       },
    },
  u'claim':
    {CMD_ACTION: Action.CLAIM,
     CMD_FUNCTION:
       {CL_OB_OWNERSHIP: claimDriveFolderOwnership,
       },
     CMD_OBJ_ALIASES:
       {
       },
    },
  u'copy':
    {CMD_ACTION: Action.COPY,
     CMD_FUNCTION:
       {CL_OB_DRIVEFILE:copyDriveFile,
       },
     CMD_OBJ_ALIASES:
       {
       },
    },
  u'create':
    {CMD_ACTION: Action.CREATE,
     CMD_FUNCTION:
       {CL_OB_CALENDAR:	createCalendar,
        CL_OB_CONTACT:	createUserContact,
        CL_OB_CONTACT_GROUP:	createUserContactGroup,
        CL_OB_SITE:	createUserSite,
       },
     CMD_OBJ_ALIASES:
       {CL_OB_CALENDARS:	CL_OB_CALENDAR,
        CL_OB_CONTACTS:	CL_OB_CONTACT,
        CL_OB_CONTACT_GROUPS:	CL_OB_CONTACT_GROUP,
        CL_OB_SITES:	CL_OB_SITE,
       },
    },
  u'delete':
    {CMD_ACTION: Action.DELETE,
     CMD_FUNCTION:
       {CL_OB_ALIASES:	deleteUsersAliases,
        CL_OB_ASP:	deleteASP,
        CL_OB_BACKUPCODES:	deleteBackupCodes,
        CL_OB_CALENDARS:	deleteCalendars,
        CL_OB_CALENDARACLS:	deleteCalendarACLs,
        CL_OB_CONTACTS:	deleteUserContacts,
        CL_OB_CONTACT_GROUPS:	deleteUserContactGroups,
        CL_OB_DELEGATE:	deleteDelegate,
        CL_OB_DRIVEFILE:	deleteDriveFile,
        CL_OB_DRIVEFILEACLS:	deleteDriveFileACLs,
        CL_OB_EMPTYDRIVEFOLDERS:	deleteEmptyDriveFolders,
        CL_OB_EVENTS:	deleteCalendarEvents,
        CL_OB_FILTERS:	deleteFilters,
        CL_OB_FORWARDINGADDRESSES:	deleteForwardingAddresses,
        CL_OB_GROUPS:	deleteUserFromGroups,
        CL_OB_LABEL:	deleteLabel,
        CL_OB_LICENSE:	deleteLicense,
        CL_OB_MESSAGES:	processMessages,
        CL_OB_PERMISSIONS:	deleteDriveFilePermissions,
        CL_OB_PHOTO:	deletePhoto,
        CL_OB_SENDAS:	deleteSendAs,
        CL_OB_SMIME:	deleteSmime,
        CL_OB_SITEACLS:	processUserSiteACLs,
        CL_OB_THREADS:	processThreads,
        CL_OB_TOKEN:	deleteTokens,
        CL_OB_USERS:	deleteUsers,
       },
     CMD_OBJ_ALIASES:
       {CL_OB_ALIAS:	CL_OB_ALIASES,
        u'applicationspecificpasswords':	CL_OB_ASP,
        CL_OB_ASPS:	CL_OB_ASP,
        u'backupcode':	CL_OB_BACKUPCODES,
        u'verificationcodes':	CL_OB_BACKUPCODES,
        CL_OB_CALENDAR:	CL_OB_CALENDARS,
        CL_OB_CALENDARACL:	CL_OB_CALENDARACLS,
        CL_OB_CONTACT:	CL_OB_CONTACTS,
        CL_OB_CONTACT_GROUP:	CL_OB_CONTACT_GROUPS,
        CL_OB_DELEGATES:	CL_OB_DELEGATE,
        CL_OB_DRIVEFILEACL:	CL_OB_DRIVEFILEACLS,
        CL_OB_EVENT:	CL_OB_EVENTS,
        CL_OB_FILTER:	CL_OB_FILTERS,
        CL_OB_GROUP:	CL_OB_GROUPS,
        u'licence':	CL_OB_LICENSE,
        CL_OB_LABELS:	CL_OB_LABEL,
        CL_OB_MESSAGE:	CL_OB_MESSAGES,
        CL_OB_SITEACL:	CL_OB_SITEACLS,
        CL_OB_THREAD:	CL_OB_THREADS,
        CL_OB_TOKENS:	CL_OB_TOKEN,
        u'3lo':		CL_OB_TOKEN,
        u'oauth':	CL_OB_TOKEN,
        CL_OB_USER:	CL_OB_USERS,
       },
    },
  u'empty':
    {CMD_ACTION: Action.EMPTY,
     CMD_FUNCTION:
       {CL_OB_DRIVETRASH:	emptyDriveTrash,
       },
     CMD_OBJ_ALIASES:
       {
       },
    },
  u'get':
    {CMD_ACTION: Action.DOWNLOAD,
     CMD_FUNCTION:
       {CL_OB_DRIVEFILE:getDriveFile,
        CL_OB_PHOTO:	getPhoto,
       },
     CMD_OBJ_ALIASES:
       {
       },
    },
  u'info':
    {CMD_ACTION: Action.INFO,
     CMD_FUNCTION:
       {CL_OB_CALENDARS:infoCalendars,
        CL_OB_CALENDARACLS:	infoCalendarACLs,
        CL_OB_CONTACTS:	infoUserContacts,
        CL_OB_CONTACT_GROUPS:	infoUserContactGroups,
        CL_OB_EVENTS:	infoCalendarEvents,
        CL_OB_FILTERS:	infoFilters,
        CL_OB_FORWARDINGADDRESSES:	infoForwardingAddresses,
        CL_OB_SENDAS:	infoSendAs,
        CL_OB_SITES:	infoUserSites,
        CL_OB_SITEACLS:	processUserSiteACLs,
        CL_OB_USERS:	infoUsers,
       },
     CMD_OBJ_ALIASES:
       {CL_OB_CALENDAR:	CL_OB_CALENDARS,
        CL_OB_CALENDARACL:	CL_OB_CALENDARACLS,
        CL_OB_CONTACT:	CL_OB_CONTACTS,
        CL_OB_CONTACT_GROUP:	CL_OB_CONTACT_GROUPS,
        CL_OB_EVENT:	CL_OB_EVENTS,
        CL_OB_FILTER:	CL_OB_FILTERS,
        CL_OB_FORWARDINGADDRESS:	CL_OB_FORWARDINGADDRESSES,
        CL_OB_SITE:	CL_OB_SITES,
        CL_OB_SITEACL:	CL_OB_SITEACLS,
        CL_OB_USER:	CL_OB_USERS,
       },
    },
  u'modify':
    {CMD_ACTION: Action.MODIFY,
     CMD_FUNCTION:
       {CL_OB_CALENDARS:	modifyCalendars,
        CL_OB_MESSAGES:	processMessages,
        CL_OB_THREADS:	processThreads,
       },
     CMD_OBJ_ALIASES:
       {CL_OB_CALENDAR:	CL_OB_CALENDARS,
        CL_OB_MESSAGE:	CL_OB_MESSAGES,
        CL_OB_THREAD:	CL_OB_THREADS,
       },
    },
  u'move':
    {CMD_ACTION: Action.MOVE,
     CMD_FUNCTION:
       {CL_OB_EVENTS:	moveCalendarEvents,
       },
     CMD_OBJ_ALIASES:
       {CL_OB_EVENT:	CL_OB_EVENTS,
       },
    },
  u'purge':
    {CMD_ACTION: Action.PURGE,
     CMD_FUNCTION:
       {CL_OB_DRIVEFILE:	purgeDriveFile,
       },
     CMD_OBJ_ALIASES:
       {
       },
    },
  u'print':
    {CMD_ACTION: Action.PRINT,
     CMD_FUNCTION:
       {CL_OB_CALENDARS:	printCalendars,
        CL_OB_CALENDARACLS:	printCalendarACLs,
        CL_OB_CONTACTS:	printUserContacts,
        CL_OB_CONTACT_GROUPS:	printUserContactGroups,
        CL_OB_DELEGATES:	printDelegates,
        CL_OB_DRIVEACTIVITY:	printDriveActivity,
        CL_OB_DRIVEFILEACLS:	printDriveFileACLs,
        CL_OB_DRIVESETTINGS:	printDriveSettings,
        CL_OB_EVENTS:	printCalendarEvents,
        CL_OB_FILEINFO:	showDriveFileInfo,
        CL_OB_FILELIST:	printDriveFileList,
        CL_OB_FILTERS:	printFilters,
        CL_OB_FORWARD:	printForward,
        CL_OB_FORWARDINGADDRESSES:	printForwardingAddresses,
        CL_OB_GMAILPROFILE:	printGmailProfile,
        CL_OB_GPLUSPROFILE:	printGplusProfile,
        CL_OB_MESSAGES:	printMessages,
        CL_OB_SENDAS:	printSendAs,
        CL_OB_SMIMES:	printSmimes,
        CL_OB_SITES:	printUserSites,
        CL_OB_SITEACTIVITY:	printUserSiteActivity,
        CL_OB_THREADS:	printThreads,
        CL_OB_TOKENS:	printTokens,
        CL_OB_USERS:	doPrintUserEntity,
       },
     CMD_OBJ_ALIASES:
       {CL_OB_CALENDAR:	CL_OB_CALENDARS,
        CL_OB_CALENDARACL:	CL_OB_CALENDARACLS,
        CL_OB_CONTACT:	CL_OB_CONTACTS,
        CL_OB_CONTACT_GROUP:	CL_OB_CONTACT_GROUPS,
        CL_OB_DELEGATE:	CL_OB_DELEGATES,
        CL_OB_DRIVEFILEACL:	CL_OB_DRIVEFILEACLS,
        CL_OB_EVENT:	CL_OB_EVENTS,
        CL_OB_FILTER:	CL_OB_FILTERS,
        CL_OB_FORWARDINGADDRESS:	CL_OB_FORWARDINGADDRESSES,
        CL_OB_MESSAGE:	CL_OB_MESSAGES,
        CL_OB_SITE:	CL_OB_SITES,
        CL_OB_SMIME:	CL_OB_SMIMES,
        CL_OB_THREAD:	CL_OB_THREADS,
        CL_OB_TOKEN:	CL_OB_TOKENS,
        u'3lo':		CL_OB_TOKENS,
        u'oauth':	CL_OB_TOKENS,
        CL_OB_USER:	CL_OB_USERS,
       },
    },
  u'remove':
    {CMD_ACTION: Action.REMOVE,
     CMD_FUNCTION:
       {CL_OB_CALENDARS:	removeCalendars,
       },
     CMD_OBJ_ALIASES:
       {CL_OB_CALENDAR:	CL_OB_CALENDARS,
       },
    },
  u'show':
    {CMD_ACTION: Action.SHOW,
     CMD_FUNCTION:
       {CL_OB_ASPS:	showASPs,
        CL_OB_BACKUPCODES:	showBackupCodes,
        CL_OB_CALENDARS:	showCalendars,
        CL_OB_CALENDARACLS:	showCalendarACLs,
        CL_OB_CALSETTINGS:	showCalSettings,
        CL_OB_CONTACTS:	showUserContacts,
        CL_OB_CONTACT_GROUPS:	showUserContactGroups,
        CL_OB_DELEGATES:	showDelegates,
        CL_OB_DRIVEACTIVITY:	printDriveActivity,
        CL_OB_DRIVEFILEACLS:	showDriveFileACLs,
        CL_OB_DRIVESETTINGS:	printDriveSettings,
        CL_OB_EVENTS:	showCalendarEvents,
        CL_OB_FILEINFO:	showDriveFileInfo,
        CL_OB_FILELIST:	printDriveFileList,
        CL_OB_FILEPATH:	showDriveFilePath,
        CL_OB_FILEREVISIONS:	showDriveFileRevisions,
        CL_OB_FILETREE:	showDriveFileTree,
        CL_OB_FILTERS:	showFilters,
        CL_OB_FORWARD:	showForward,
        CL_OB_FORWARDINGADDRESSES:	showForwardingAddresses,
        CL_OB_GMAILPROFILE:	showGmailProfile,
        CL_OB_GPLUSPROFILE:	showGplusProfile,
        CL_OB_IMAP:	showImap,
        CL_OB_LABELS:	showLabels,
        CL_OB_MESSAGES:	showMessages,
        CL_OB_POP:	showPop,
        CL_OB_PROFILE:	showProfile,
        CL_OB_SENDAS:	showSendAs,
        CL_OB_SMIMES:	showSmimes,
        CL_OB_SIGNATURE:showSignature,
        CL_OB_SITES:	showUserSites,
        CL_OB_SITEACLS:	processUserSiteACLs,
        CL_OB_THREADS:	showThreads,
        CL_OB_TOKENS:	showTokens,
        CL_OB_VACATION:	showVacation,
       },
     CMD_OBJ_ALIASES:
       {u'applicationspecificpasswords':	CL_OB_ASPS,
        CL_OB_ASP:	CL_OB_ASPS,
        u'backupcode':	CL_OB_BACKUPCODES,
        u'verificationcodes':	CL_OB_BACKUPCODES,
        CL_OB_CALENDAR:	CL_OB_CALENDARS,
        CL_OB_CALENDARACL:	CL_OB_CALENDARACLS,
        CL_OB_CONTACT:	CL_OB_CONTACTS,
        CL_OB_CONTACT_GROUP:	CL_OB_CONTACT_GROUPS,
        CL_OB_DELEGATE:	CL_OB_DELEGATES,
        CL_OB_DRIVEFILEACL:	CL_OB_DRIVEFILEACLS,
        CL_OB_EVENT:	CL_OB_EVENTS,
        CL_OB_FILTER:	CL_OB_FILTERS,
        CL_OB_FORWARDINGADDRESS:	CL_OB_FORWARDINGADDRESSES,
        u'imap4':	CL_OB_IMAP,
        u'pop3':	CL_OB_POP,
        CL_OB_LABEL:	CL_OB_LABELS,
        CL_OB_MESSAGE:	CL_OB_MESSAGES,
        u'sig':		CL_OB_SIGNATURE,
        CL_OB_SITE:	CL_OB_SITES,
        CL_OB_SITEACL:	CL_OB_SITEACLS,
        CL_OB_SMIME:	CL_OB_SMIMES,
        CL_OB_THREAD:	CL_OB_THREADS,
        CL_OB_TOKEN:	CL_OB_TOKENS,
        u'3lo':		CL_OB_TOKENS,
        u'oauth':	CL_OB_TOKENS,
       },
    },
  u'spam':
    {CMD_ACTION: Action.SPAM,
     CMD_FUNCTION:
       {CL_OB_MESSAGES:	processMessages,
        CL_OB_THREADS:	processThreads,
       },
     CMD_OBJ_ALIASES:
       {CL_OB_MESSAGE:	CL_OB_MESSAGES,
        CL_OB_THREAD:	CL_OB_THREADS,
       },
    },
  u'transfer':
    {CMD_ACTION: Action.TRANSFER,
     CMD_FUNCTION:
       {CL_OB_DRIVE:	transferDriveFiles,
        CL_OB_CALENDARS:	transferCalendars,
        CL_OB_OWNERSHIP: transferDriveFileOwnership,
       },
     CMD_OBJ_ALIASES:
       {CL_OB_CALENDAR:	CL_OB_CALENDARS,
        u'seccals':	CL_OB_CALENDARS,
       },
    },
  u'trash':
    {CMD_ACTION: Action.TRASH,
     CMD_FUNCTION:
       {CL_OB_DRIVEFILE:	trashDriveFile,
        CL_OB_MESSAGES:	processMessages,
        CL_OB_THREADS:	processThreads,
       },
     CMD_OBJ_ALIASES:
       {CL_OB_MESSAGE:	CL_OB_MESSAGES,
        CL_OB_THREAD:	CL_OB_THREADS,
       },
    },
  u'untrash':
    {CMD_ACTION: Action.UNTRASH,
     CMD_FUNCTION:
       {CL_OB_DRIVEFILE:	untrashDriveFile,
        CL_OB_MESSAGES:	processMessages,
        CL_OB_THREADS:	processThreads,
       },
     CMD_OBJ_ALIASES:
       {CL_OB_MESSAGE:	CL_OB_MESSAGES,
        CL_OB_THREAD:	CL_OB_THREADS,
       },
    },
  u'undelete':
    {CMD_ACTION: Action.UNDELETE,
     CMD_FUNCTION:
       {CL_OB_USERS:	undeleteUsers,
       },
     CMD_OBJ_ALIASES:
       {CL_OB_USER:	CL_OB_USERS,
       },
    },
  u'update':
    {CMD_ACTION: Action.UPDATE,
     CMD_FUNCTION:
       {CL_OB_BACKUPCODES:	updateBackupCodes,
        CL_OB_CALATTENDEES:	updateCalendarAttendees,
        CL_OB_CALENDARS:	updateCalendars,
        CL_OB_CALENDARACLS:	updateCalendarACLs,
        CL_OB_CONTACTS:	updateUserContacts,
        CL_OB_CONTACT_GROUP:	updateUserContactGroup,
        CL_OB_DRIVEFILE:updateDriveFile,
        CL_OB_DRIVEFILEACLS:	updateDriveFileACLs,
        CL_OB_EVENTS:	updateCalendarEvents,
        CL_OB_LABELS:	updateLabels,
        CL_OB_LABELSETTINGS:updateLabelSettings,
        CL_OB_LICENSE:	updateLicense,
        CL_OB_PHOTO:	updatePhoto,
        CL_OB_SENDAS:	updateSendAs,
        CL_OB_SMIME:	updateSmime,
        CL_OB_SITES:	updateUserSites,
        CL_OB_SITEACLS:	processUserSiteACLs,
        CL_OB_USERS:	updateUsers,
       },
     CMD_OBJ_ALIASES:
       {u'backupcode':	CL_OB_BACKUPCODES,
        u'verificationcodes':	CL_OB_BACKUPCODES,
        CL_OB_CALENDAR:	CL_OB_CALENDARS,
        CL_OB_CALENDARACL:	CL_OB_CALENDARACLS,
        CL_OB_CONTACT:	CL_OB_CONTACTS,
        CL_OB_CONTACT_GROUPS:	CL_OB_CONTACT_GROUP,
        CL_OB_DRIVEFILEACL:	CL_OB_DRIVEFILEACLS,
        CL_OB_EVENT:	CL_OB_EVENTS,
        CL_OB_LABEL:	CL_OB_LABELS,
        u'licence':	CL_OB_LICENSE,
        CL_OB_SITE:	CL_OB_SITES,
        CL_OB_SITEACL:	CL_OB_SITEACLS,
        CL_OB_USER:	CL_OB_USERS,
       },
    },
  u'wipe':
    {CMD_ACTION: Action.WIPE,
     CMD_FUNCTION:
       {CL_OB_EVENTS:	wipeCalendarEvents,
       },
     CMD_OBJ_ALIASES:
       {CL_OB_EVENT:	CL_OB_EVENTS,
       },
    },
  }

# User commands aliases
USER_COMMANDS_ALIASES = {
  u'del':	u'delete',
  CL_OB_DELEGATES:	CL_OB_DELEGATE,
  u'deprov':	u'deprovision',
  u'imap4':	u'imap',
  u'pop3':	u'pop',
  u'sig':	u'signature',
  u'utf':	u'unicode',
  u'utf-8':	u'unicode',
  u'utf8':	u'unicode',
  }

def adjustRedirectedSTDFilesIfNotMultiprocessing():
  def adjustRedirectedSTDFile(stdtype):
    rdFd = GM_Globals[stdtype].get(GM_REDIRECT_FD)
    rdMultiFd = GM_Globals[stdtype].get(GM_REDIRECT_MULTI_FD)
    if rdFd and rdMultiFd and rdFd != rdMultiFd:
      try:
        rdFd.write(rdMultiFd.getvalue())
        rdMultiFd.close()
        GM_Globals[stdtype][GM_REDIRECT_MULTI_FD] = rdFd
        if (stdtype == GM_STDOUT) and (GM_Globals.get(GM_SAVED_STDOUT) is not None):
          sys.stdout = rdFd
      except IOError as e:
        systemErrorExit(FILE_ERROR_RC, e)

  adjustRedirectedSTDFile(GM_STDOUT)
  if GM_Globals[GM_STDERR].get(GM_REDIRECT_NAME) != u'stdout':
    adjustRedirectedSTDFile(GM_STDERR)
  else:
    GM_Globals[GM_STDERR][GM_REDIRECT_MULTI_FD] = GM_Globals[GM_STDOUT][GM_REDIRECT_MULTI_FD]

# Process GAM command
def ProcessGAMCommand(args, processGamCfg=True):
  setSysExitRC(0)
  CLArgs.InitializeArguments(args)
  Indent.Reset()
  try:
    if checkArgumentPresent([LOOP_CMD,]):
      if processGamCfg and (not SetGlobalVariables()):
        sys.exit(GM_Globals[GM_SYSEXITRC])
      doLoop(processGamCfg=True)
      sys.exit(GM_Globals[GM_SYSEXITRC])
    if processGamCfg and (not SetGlobalVariables()):
      sys.exit(GM_Globals[GM_SYSEXITRC])
    if checkArgumentPresent([LOOP_CMD,]):
      doLoop(processGamCfg=False)
      sys.exit(GM_Globals[GM_SYSEXITRC])
    if not CLArgs.ArgumentsRemaining():
      doUsage()
      sys.exit(GM_Globals[GM_SYSEXITRC])
    CL_command = getChoice(BATCH_CSV_COMMANDS, defaultChoice=None)
    if CL_command:
      Action.Set(BATCH_CSV_COMMANDS[CL_command][CMD_ACTION])
      BATCH_CSV_COMMANDS[CL_command][CMD_FUNCTION]()
      sys.exit(GM_Globals[GM_SYSEXITRC])
    CL_command = getChoice(MAIN_COMMANDS, defaultChoice=None)
    if CL_command:
      adjustRedirectedSTDFilesIfNotMultiprocessing()
      Action.Set(MAIN_COMMANDS[CL_command][CMD_ACTION])
      MAIN_COMMANDS[CL_command][CMD_FUNCTION]()
      sys.exit(GM_Globals[GM_SYSEXITRC])
    CL_command = getChoice(MAIN_COMMANDS_WITH_OBJECTS, defaultChoice=None)
    if CL_command:
      adjustRedirectedSTDFilesIfNotMultiprocessing()
      Action.Set(MAIN_COMMANDS_WITH_OBJECTS[CL_command][CMD_ACTION])
      CL_objectName = getChoice(MAIN_COMMANDS_WITH_OBJECTS[CL_command][CMD_FUNCTION], choiceAliases=MAIN_COMMANDS_WITH_OBJECTS[CL_command][CMD_OBJ_ALIASES])
      MAIN_COMMANDS_WITH_OBJECTS[CL_command][CMD_FUNCTION][CL_objectName]()
      sys.exit(GM_Globals[GM_SYSEXITRC])
    CL_command = getChoice(COMMANDS_MAP, choiceAliases=COMMANDS_ALIASES, defaultChoice=None)
    if CL_command:
      adjustRedirectedSTDFilesIfNotMultiprocessing()
      COMMANDS_MAP[CL_command]()
      sys.exit(GM_Globals[GM_SYSEXITRC])
    GM_Globals[GM_ENTITY_CL_START] = CLArgs.Location()
    entityType, entityList = getEntityToModify(crosAllowed=True, returnOnError=True, delayGet=True)
    if entityType is None:
      usageErrorExit(PHRASE_UNKNOWN_COMMAND_SELECTOR)
    if entityType == CL_ENTITY_USERS:
      CL_command = getChoice(USER_COMMANDS.keys()+USER_COMMANDS_WITH_OBJECTS.keys(), choiceAliases=USER_COMMANDS_ALIASES)
      if (CL_command != u'list') and (GC_Values[GC_AUTO_BATCH_MIN] > 0):
        _, count, entityList = getEntityArgument(entityList)
        if count > GC_Values[GC_AUTO_BATCH_MIN]:
          doAutoBatch(CL_ENTITY_USER, entityList, CL_command)
          sys.exit(GM_Globals[GM_SYSEXITRC])
      adjustRedirectedSTDFilesIfNotMultiprocessing()
      if CL_command in USER_COMMANDS:
        Action.Set(USER_COMMANDS[CL_command][CMD_ACTION])
        USER_COMMANDS[CL_command][CMD_FUNCTION](entityList)
      else:
        Action.Set(USER_COMMANDS_WITH_OBJECTS[CL_command][CMD_ACTION])
        CL_objectName = getChoice(USER_COMMANDS_WITH_OBJECTS[CL_command][CMD_FUNCTION], choiceAliases=USER_COMMANDS_WITH_OBJECTS[CL_command][CMD_OBJ_ALIASES],
                                  defaultChoice=[CL_OB_USERS, NO_DEFAULT][CL_command != u'print'])
        USER_COMMANDS_WITH_OBJECTS[CL_command][CMD_FUNCTION][CL_objectName](entityList)
    else:
      CL_command = getChoice(CROS_COMMANDS)
      if (CL_command != u'list') and (GC_Values[GC_AUTO_BATCH_MIN] > 0):
        _, count, entityList = getEntityArgument(entityList)
        if count > GC_Values[GC_AUTO_BATCH_MIN]:
          doAutoBatch(CL_ENTITY_CROS, entityList, CL_command)
          sys.exit(GM_Globals[GM_SYSEXITRC])
      adjustRedirectedSTDFilesIfNotMultiprocessing()
      Action.Set(CROS_COMMANDS[CL_command][CMD_ACTION])
      CROS_COMMANDS[CL_command][CMD_FUNCTION](entityList)
    sys.exit(GM_Globals[GM_SYSEXITRC])
  except KeyboardInterrupt:
    setSysExitRC(KEYBOARD_INTERRUPT_RC)
    adjustRedirectedSTDFilesIfNotMultiprocessing()
  except socket.error as e:
    printErrorMessage(SOCKET_ERROR_RC, formatExceptionMessage(e))
    adjustRedirectedSTDFilesIfNotMultiprocessing()
  except MemoryError:
    printErrorMessage(MEMORY_ERROR_RC, MESSAGE_GAM_OUT_OF_MEMORY)
    adjustRedirectedSTDFilesIfNotMultiprocessing()
  except SystemExit as e:
    GM_Globals[GM_SYSEXITRC] = e.code
    try:
      adjustRedirectedSTDFilesIfNotMultiprocessing()
    except SystemExit:
      pass
  except Exception:
    from traceback import print_exc
    print_exc(file=sys.stderr)
    setSysExitRC(UNKNOWN_ERROR_RC)
    adjustRedirectedSTDFilesIfNotMultiprocessing()
  if GM_Globals.get(GM_SAVED_STDOUT) is not None:
    sys.stdout = GM_Globals[GM_SAVED_STDOUT]
  return GM_Globals[GM_SYSEXITRC]

# gam loop <FileName>|- [charset <String>] [columndelimiter <String>] [fields <FieldNameList>] (matchfield <FieldName> <RegularExpression>)* gam <GAM argument list>
def doLoop(processGamCfg=True):
  filename = getString(OB_FILE_NAME)
  if (filename == u'-') and (GC_Values[GC_DEBUG_LEVEL] > 0):
    CLArgs.Backup()
    usageErrorExit(MESSAGE_BATCH_CSV_LOOP_DASH_DEBUG_INCOMPATIBLE.format(u'loop'))
  f, csvFile = openCSVFileReader(filename)
  matchFields = getMatchFields(csvFile.fieldnames)
  checkArgumentPresent([GAM_CMD,], required=True)
  if not CLArgs.ArgumentsRemaining():
    missingArgumentExit(OB_GAM_ARGUMENT_LIST)
  choice = CLArgs.Current().strip().lower()
  if choice == LOOP_CMD:
    usageErrorExit(PHRASE_NESTED_LOOP_CMD_NOT_ALLOWED)
# gam loop ... gam redirect|select|config ... process gam.cfg on each iteration
# gam redirect|select|config ... loop ... gam redirect|select|config ... process gam.cfg on each iteration
# gam loop ... gam !redirect|select|config ... no further processing of gam.cfg
# gam redirect|select|config ... loop ... gam !redirect|select|config ... no further processing of gam.cfg
  processGamCfg = choice in GAM_META_COMMANDS
  GAM_argv, subFields = getSubFields([GAM_CMD,], csvFile.fieldnames)
  multi = GM_Globals[GM_CSVFILE][GM_REDIRECT_MULTIPROCESS]
  if multi:
    mpQueue, mpQueueHandler = initializeCSVFileQueueHandler()
  else:
    mpQueue = None
  GM_Globals[GM_CSVFILE][GM_REDIRECT_QUEUE] = mpQueue
  for row in csvFile:
    if (not matchFields) or checkMatchFields(row, matchFields):
      ProcessGAMCommand(processSubFields(GAM_argv, row, subFields), processGamCfg=processGamCfg)
      if (GM_Globals[GM_SYSEXITRC] > 0) and (GM_Globals[GM_SYSEXITRC] <= HARD_ERROR_RC):
        break
  closeFile(f)
  if multi:
    terminateCSVFileQueueHandler(mpQueue, mpQueueHandler)
#
if sys.platform.startswith('win'):
  from multiprocessing import freeze_support
  try:
    import multiprocessing.popen_spawn_win32 as forking
  except ImportError:
    import multiprocessing.forking as forking

  # First define a modified version of Popen.
  class _Popen(forking.Popen):
    def __init__(self, *args, **kw):
      if hasattr(sys, 'frozen'):
        # We have to set original _MEIPASS2 value from sys._MEIPASS
        # to get --onefile mode working.
        os.putenv('_MEIPASS2', sys._MEIPASS)
      try:
        super(_Popen, self).__init__(*args, **kw)
      finally:
        if hasattr(sys, 'frozen'):
          # On some platforms (e.g. AIX) 'os.unsetenv()' is not
          # available. In those cases we cannot delete the variable
          # but only set it to the empty string. The bootloader
          # can handle this case.
          if hasattr(os, 'unsetenv'):
            os.unsetenv('_MEIPASS2')
          else:
            os.putenv('_MEIPASS2', '')

  # Second override 'Popen' class with our modified version.
  forking.Popen = _Popen

  def win32_unicode_argv():
    from ctypes import POINTER, byref, cdll, c_int, windll
    from ctypes.wintypes import LPCWSTR, LPWSTR

    GetCommandLineW = cdll.kernel32.GetCommandLineW
    GetCommandLineW.argtypes = []
    GetCommandLineW.restype = LPCWSTR

    CommandLineToArgvW = windll.shell32.CommandLineToArgvW
    CommandLineToArgvW.argtypes = [LPCWSTR, POINTER(c_int)]
    CommandLineToArgvW.restype = POINTER(LPWSTR)

    cmd = GetCommandLineW()
    argc = c_int(0)
    argv = CommandLineToArgvW(cmd, byref(argc))
    if argc.value > 0:
      # Remove Python executable and commands if present
      argc_value = int(argc.value)
      sys.argv = argv[argc_value-len(sys.argv):argc_value]

# Run from command line
if __name__ == "__main__":
  resetDefaultEncodingToUTF8()
  if sys.platform.startswith('win'):
    freeze_support()
    win32_unicode_argv() # cleanup sys.argv on Windows
  initializeLogging()
  rc = ProcessGAMCommand(sys.argv)
  try:
    sys.stdout.flush()
  except (IOError, ValueError):
    pass
  sys.exit(rc)
